name: Fetch DEFCON Stats

on:
  schedule:
    # Run daily at 3 AM UTC
    - cron: '0 3 * * *'
  workflow_dispatch:
    inputs:
      start_gw:
        description: 'Start gameweek (for backfill)'
        required: false
        default: ''
      end_gw:
        description: 'End gameweek (for backfill)'
        required: false
        default: ''

jobs:
  fetch-defcon-stats:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: Install dependencies
        run: |
          npm install @supabase/supabase-js
      
      - name: Fetch and store DEFCON stats
        env:
          SUPABASE_URL: ${{ secrets.SUPABASE_URL }}
          SUPABASE_SERVICE_ROLE_KEY: ${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}
          START_GW: ${{ github.event.inputs.start_gw }}
          END_GW: ${{ github.event.inputs.end_gw }}
        run: |
          node --input-type=module <<'EOF'
          import { createClient } from '@supabase/supabase-js';

          const supabaseUrl = process.env.SUPABASE_URL;
          const supabaseKey = process.env.SUPABASE_SERVICE_ROLE_KEY;
          const supabase = createClient(supabaseUrl, supabaseKey);

          // Calculate DEFCON points based on position and defensive contribution
          function calculateDefconPoints(position, defensiveContribution) {
            // Goalkeepers (position 1) are not eligible for DEFCON
            if (position === 1) return 0;
            
            // Defenders need 10+, midfielders/forwards need 12+
            const threshold = position === 2 ? 10 : 12;
            return defensiveContribution >= threshold ? 2 : 0;
          }

          async function fetchBootstrapData() {
            try {
              const response = await fetch('https://fantasy.premierleague.com/api/bootstrap-static/');
              if (!response.ok) throw new Error('Failed to fetch bootstrap data');
              return await response.json();
            } catch (error) {
              console.error('Error fetching bootstrap data:', error);
              throw error;
            }
          }

          async function fetchLiveData(gameweek) {
            try {
              const response = await fetch(`https://fantasy.premierleague.com/api/event/${gameweek}/live/`);
              if (!response.ok) throw new Error(`Failed to fetch live data for GW${gameweek}`);
              return await response.json();
            } catch (error) {
              console.error(`Error fetching live data for GW${gameweek}:`, error);
              throw error;
            }
          }

          async function processGameweek(gameweek, playerPositions) {
            console.log(`Processing gameweek ${gameweek}...`);
            
            try {
              const liveData = await fetchLiveData(gameweek);
              const elements = liveData.elements || [];
              
              const records = [];
              
              for (const element of elements) {
                const playerId = element.id;
                const position = playerPositions.get(playerId);
                
                if (!position) {
                  console.warn(`Player ${playerId} not found in bootstrap data`);
                  continue;
                }
                
                const stats = element.stats || {};
                const minutes = Number(stats.minutes) || 0;
                
                // Skip if player didn't play
                if (minutes === 0) continue;
                
                // Get defensive stats
                const defensiveContribution = Number(stats.defensive_contribution) || 0;
                const clearancesBlocksInterceptions = Number(stats.clearances_blocks_interceptions) || 0;
                const recoveries = Number(stats.recoveries) || 0;
                const tackles = Number(stats.tackles) || 0;
                
                // Calculate DEFCON points
                const defconPoints = calculateDefconPoints(position, defensiveContribution);
                
                records.push({
                  player_id: playerId,
                  gameweek: gameweek,
                  position: position,
                  minutes: minutes,
                  // FPL API provides combined clearances_blocks_interceptions
                  // We store it in clearances for simplicity
                  clearances: clearancesBlocksInterceptions,
                  recoveries: recoveries,
                  tackles: tackles,
                  interceptions: 0,
                  blocks: 0,
                  defensive_contribution: defensiveContribution,
                  defcon_points: defconPoints
                });
              }
              
              console.log(`Found ${records.length} records for GW${gameweek}`);
              
              // Upsert to Supabase
              if (records.length > 0) {
                const { data, error } = await supabase
                  .from('player_defensive_stats')
                  .upsert(records, { 
                    onConflict: 'player_id,gameweek',
                    ignoreDuplicates: false 
                  });
                
                if (error) {
                  console.error(`Error upserting data for GW${gameweek}:`, error);
                  throw error;
                }
                
                console.log(`âœ… Successfully stored ${records.length} records for GW${gameweek}`);
              } else {
                console.log(`âš ï¸ No records to store for GW${gameweek}`);
              }
              
              return records.length;
            } catch (error) {
              console.error(`Error processing GW${gameweek}:`, error);
              throw error;
            }
          }

          async function main() {
            try {
              console.log('Fetching bootstrap data...');
              const bootstrapData = await fetchBootstrapData();
              
              // Build a map of player ID to position
              const playerPositions = new Map();
              for (const player of bootstrapData.elements) {
                playerPositions.set(player.id, player.element_type);
              }
              console.log(`Loaded ${playerPositions.size} players from bootstrap data`);
              
              // Determine current gameweek
              const currentEvent = bootstrapData.events.find(e => e.is_current);
              const currentGW = currentEvent ? currentEvent.id : 1;
              console.log(`Current gameweek: ${currentGW}`);
              
              // Check if we're in backfill mode
              const startGwInput = process.env.START_GW;
              const endGwInput = process.env.END_GW;
              
              let gameweeksToProcess = [];
              
              if (startGwInput && endGwInput) {
                // Backfill mode
                const startGw = parseInt(startGwInput);
                const endGw = parseInt(endGwInput);
                
                if (isNaN(startGw) || isNaN(endGw) || startGw < 1 || endGw > 38 || startGw > endGw) {
                  console.error('Invalid gameweek range. Start and end must be between 1 and 38, and start <= end.');
                  process.exit(1);
                }
                
                console.log(`\nðŸ”„ BACKFILL MODE: Processing gameweeks ${startGw} to ${endGw}\n`);
                for (let gw = startGw; gw <= endGw; gw++) {
                  gameweeksToProcess.push(gw);
                }
              } else {
                // Normal mode: process current gameweek
                console.log(`\nðŸ“Š NORMAL MODE: Processing current gameweek ${currentGW}\n`);
                gameweeksToProcess.push(currentGW);
              }
              
              let totalRecordsProcessed = 0;
              
              for (const gw of gameweeksToProcess) {
                try {
                  const recordCount = await processGameweek(gw, playerPositions);
                  totalRecordsProcessed += recordCount;
                  
                  // Add a small delay between requests to be respectful to the API
                  if (gameweeksToProcess.length > 1) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                  }
                } catch (error) {
                  console.error(`Failed to process GW${gw}, continuing with next gameweek...`);
                }
              }
              
              console.log(`\nâœ… COMPLETE: Processed ${totalRecordsProcessed} total records across ${gameweeksToProcess.length} gameweek(s)`);
            } catch (error) {
              console.error('Fatal error:', error);
              process.exit(1);
            }
          }

          main();
          EOF

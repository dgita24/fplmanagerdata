---
import Nav from '../components/Nav.astro';
---

<Nav />
<h1>Transfers & Free Transfers (FTs) for Next GW</h1>
<p>Display calculated FTs for next GW for all managers.</p>

<div style="margin-bottom: 1em;">
  <span id="manager-count" style="font-weight: bold;">Loading managers...</span>
  <a href="/managers" style="margin-left: 1em; color: #3182ce;">Manage IDs</a>
</div>

<div style="margin-bottom: 1em;">
  <label for="gw-filter">Filter by Gameweek:</label><br>
  <input type="number" id="gw-filter" min="1" max="38" placeholder="Auto" style="width: 100px; padding: 5px;">
  <button id="clear-filter-btn" style="margin-left: 0.5em; padding: 5px 12px;">Show All GWs</button>
  <button id="refresh-btn" style="margin-left: 1em; padding: 5px 12px;">Refresh Data</button>
</div>

<div id="loading-status" style="margin-bottom: 1em; color: #666;"></div>
<div id="transfers-table" style="margin-top:1.5em"></div>

<script type="module">
// Inline FT calculation logic - MATCHES EXCEL EXACTLY
function calculateFTs(managerHistory) {
  const byGW = new Map();
  managerHistory.forEach(row => byGW.set(row.gw, row));

  for (let i = 0; i < managerHistory.length; ++i) {
    const row = managerHistory[i];
    const E = Number(row.gw);
    const M = Number(row.transfers);
    let Q = 1;
    const prevRow = byGW.get(E - 1);
    const S = prevRow ? 1 : 0;
    
    if (E === 16) {
      Q = 5;
    } else if (E === 1) {
      Q = 0;
    } else if (S === 0) {
      Q = 1;
    } else if (!prevRow) {
      Q = 1;
    } else {
      const prevChip = prevRow.chipPlayed || "";
      const prevFTs = Number(prevRow.FTsStartOfGW);
      const prevTransfers = Number(prevRow.transfers);
      
      if (prevChip === "WC" || prevChip === "FH") {
        Q = Math.max(1, prevFTs - prevTransfers);
      } else {
        Q = Math.min(Math.max(1, prevFTs - prevTransfers + 1), 5);
      }
    }
    row.FTsStartOfGW = Q;
  }

  const maxGW = Math.max(...managerHistory.map(r => r.gw));
  managerHistory.forEach(row => {
    if (row.gw === maxGW) {
      const E = Number(row.gw);
      const Q = Number(row.FTsStartOfGW);
      const M = Number(row.transfers);
      const F = row.chipPlayed || "";
      
      if (E === 15) {
        row.FTsForNextGW = 5;
      } else {
        const inc = (F === "WC" || F === "FH") ? 0 : 1;
        row.FTsForNextGW = Math.min(Math.max(1, Q - M + inc), 5);
      }
    } else {
      row.FTsForNextGW = "";
    }
  });
}

function loadManagerIds() {
  try {
    return JSON.parse(localStorage.getItem("globalManagerIds")) || [];
  } catch {
    return [];
  }
}

const out = document.getElementById("transfers-table");
const gwFilterInput = document.getElementById("gw-filter");
const clearFilterBtn = document.getElementById("clear-filter-btn");
const loadingStatus = document.getElementById("loading-status");
const managerCountEl = document.getElementById("manager-count");
const refreshBtn = document.getElementById("refresh-btn");

let allHistories = [];
let latestGW = null;

async function fetchHistory(id) {
  const url = `/api/fpl/entry/${id}/history`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("Load error");
  const data = await res.json();
  let history = data.current.map(gw => ({
    entryId: Number(id),
    gw: gw.event,
    chipPlayed: "",
    transfers: gw.event_transfers,
    transferCost: gw.event_transfers_cost ?? 0,
    benchPoints: gw.points_on_bench ?? 0,
    gwPoints: gw.points,
    totalPoints: gw.total_points
  }));
  if (Array.isArray(data.chips)) {
    data.chips.forEach(c => {
      const row = history.find(gw => gw.gw === c.event);
      if (row) {
        row.chipPlayed = (
          c.name === "wildcard" ? "WC" :
          c.name === "bboost" ? "BB" :
          c.name === "3xc" ? "TC" :
          c.name === "freehit" ? "FH" : c.name
        );
      }
    });
  }
  return history;
}

function makeTable(histories, filterGW = null) {
  let rows = histories.flat();
  
  // Apply GW filter if specified
  if (filterGW !== null && filterGW !== "") {
    const gwNum = Number(filterGW);
    rows = rows.filter(r => r.gw === gwNum);
    
    // When filtering by GW, sort by Total Points DESC (best first)
    rows.sort((a, b) => b.totalPoints - a.totalPoints);
  } else {
    // When showing all GWs, sort by EntryID then GW
    rows.sort((a,b) => a.entryId-b.entryId || a.gw-b.gw);
  }

  let html = `<table border="1" cellpadding="4" style="border-collapse:collapse">
    <tr>
      <th>EntryID</th>
      <th>GW</th>
      <th>ChipPlayed</th>
      <th>Transfers</th>
      <th>TransferCost</th>
      <th>GW Points</th>
      <th>Total Points</th>
      <th>FTs Start of GW</th>
      <th style="background:lightyellow">FTs for next GW</th>
    </tr>`;
  for (const r of rows) {
    html += `<tr>
      <td>${r.entryId}</td>
      <td>${r.gw}</td>
      <td>${r.chipPlayed || ""}</td>
      <td>${r.transfers ?? ""}</td>
      <td>${r.transferCost ?? ""}</td>
      <td>${r.gwPoints ?? ""}</td>
      <td>${r.totalPoints ?? ""}</td>
      <td>${r.FTsStartOfGW ?? ""}</td>
      <td style="background:lightyellow">${r.FTsForNextGW ?? ""}</td>
    </tr>`;
  }
  html += "</table>";
  return html;
}

async function loadManagers(ids) {
  if (ids.length === 0) {
    out.innerHTML = "<span style='color:red'>No manager IDs found. <a href='/managers'>Add managers here</a>.</span>";
    return;
  }

  allHistories = [];
  latestGW = null;
  out.innerHTML = "";
  loadingStatus.textContent = `Loading 0 of ${ids.length} managers...`;

  let loaded = 0;
  for (const id of ids) {
    try {
      let history = await fetchHistory(id);
      calculateFTs(history);
      allHistories.push(history);
      
      // Track the latest GW across all managers
      const managerMaxGW = Math.max(...history.map(h => h.gw));
      if (latestGW === null || managerMaxGW > latestGW) {
        latestGW = managerMaxGW;
      }
      
      loaded++;
      
      // Update status
      loadingStatus.textContent = `Loading ${loaded} of ${ids.length} managers...`;
      
      // Progressive render WITHOUT filter during loading
      out.innerHTML = makeTable(allHistories, "");
    } catch (e) {
      console.error(`Failed to load manager ${id}:`, e);
      loaded++;
      loadingStatus.innerHTML = `<span style='color:orange'>⚠️ Failed to load manager ${id}</span>`;
    }
  }
  
  loadingStatus.innerHTML = `<span style='color:#38a169'>✅ Loaded ${loaded} of ${ids.length} managers</span>`;
  
  // AFTER all managers loaded, auto-set filter to latest GW
  if (latestGW) {
    gwFilterInput.value = latestGW;
    gwFilterInput.placeholder = `Latest: GW${latestGW}`;
    filterByGW(); // Apply the filter
  }
}

function filterByGW() {
  const filterGW = gwFilterInput.value.trim();
  out.innerHTML = makeTable(allHistories, filterGW);
}

// Initial load
const managerIds = loadManagerIds();
managerCountEl.textContent = `${managerIds.length} manager(s) configured`;

if (managerIds.length > 0) {
  loadManagers(managerIds);
} else {
  out.innerHTML = "<span style='color:red'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</span>";
}

gwFilterInput.addEventListener('input', filterByGW);

clearFilterBtn.addEventListener('click', () => {
  gwFilterInput.value = "";
  filterByGW();
});

refreshBtn.addEventListener('click', () => {
  gwFilterInput.value = ""; // Clear filter on refresh
  const ids = loadManagerIds();
  loadManagers(ids);
});
</script>

<style>
  button {
    background: #3182ce;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
  }
  button:hover {
    background: #2c5aa0;
  }
</style>
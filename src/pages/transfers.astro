---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="Transfers & Free Transfers - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">üîÑ  Transfers (Hits & FTs)  üîÑ </h1>
      <p class="page-subtitle">Calculated FTs for next GW for all managers.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">‚öô Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">All GWs</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="manager-filter">Manager</label>
        <select class="select-small" id="manager-filter">
         <option value="">All</option>
       </select>
      </div>
      <div class="control-inline">
        <label class="label-small">&nbsp;</label>
        <button id="refresh-btn" class="btn-row" type="button">üîÑ Refresh</button>
      </div>
    </div>

    <div id="loading-status" class="meta-row"></div>
    <section id="transfers-table" aria-live="polite"></section>
  </main>

  <!-- Transfer History Modal -->
  <div id="transfer-modal" class="modal">
    <div class="modal-panel">
      <div id="modal-content"></div>
    </div>
  </div>

  <!-- Chip Detail Modal -->
  <div id="chip-modal" class="modal modal--nested">
    <div class="modal-panel">
      <button id="close-chip-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="chip-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 36px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .btn-row {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
  }

  .btn-row:hover {
    background: var(--color-primary-hover);
  }

  /* Chip headings */
  .chip-text {
    font-size: 13px;
    font-weight: 600;
    font-family: inherit;
    color: var(--color-text);
    background: none;
    border: none;
    padding: 0;
    margin: 0;
    display: inline;
    appearance: none;
    -webkit-appearance: none;
    box-shadow: none;
    outline: none;
    line-height: inherit;
    text-align: left;
  }

  .chip-text--clickable {
    color: var(--color-primary);
    cursor: pointer;
  }

  .chip-text--clickable:hover {
    color: var(--color-primary-hover);
    text-decoration: underline;
  }

  .chip-row {
    margin-bottom: var(--space-2);
  }

  /* Highlight styles for table */
  .hit-highlight {
    color: var(--color-danger) !important;
    font-weight: 700 !important;
  }

  .top-scorer-row {
    color: var(--color-success) !important;
    font-weight: 700 !important;
  }

  .top-scorer-row a {
    color: var(--color-success) !important;
    font-weight: 700 !important;
  }
</style>

<script>
  function calculateFTs(managerHistory) {
    const byGW = new Map();
    managerHistory.forEach(row => byGW.set(row.gw, row));

    for (let i = 0; i < managerHistory.length; ++i) {
      const row = managerHistory[i];
      const E = Number(row.gw);
      const M = Number(row.transfers);
      let Q = 1;
      const prevRow = byGW.get(E - 1);
      const S = prevRow ? 1 : 0;

      if (E === 16) {
        Q = 5;
      } else if (E === 1) {
        Q = 0;
      } else if (S === 0) {
        Q = 1;
      } else if (!prevRow) {
        Q = 1;
      } else {
        const prevChip = prevRow.chipPlayed || "";
        const prevFTs = Number(prevRow.FTsStartOfGW);
        const prevTransfers = Number(prevRow.transfers);

        if (prevChip === "WC" || prevChip === "FH") {
          Q = Math.max(1, prevFTs - prevTransfers);
        } else {
          Q = Math.min(Math.max(1, prevFTs - prevTransfers + 1), 5);
        }
      }
      row.FTsStartOfGW = Q;
    }

    const maxGW = Math.max(...managerHistory.map(r => r.gw));
    managerHistory.forEach(row => {
      if (row.gw === maxGW) {
        const E = Number(row.gw);
        const Q = Number(row.FTsStartOfGW);
        const M = Number(row.transfers);
        const F = row.chipPlayed || "";

        if (E === 15) {
          row.FTsForNextGW = 5;
        } else {
          const inc = (F === "WC" || F === "FH") ? 0 : 1;
          row.FTsForNextGW = Math.min(Math.max(1, Q - M + inc), 5);
        }
      } else {
        row.FTsForNextGW = "";
      }
    });
  }

  import { supabase } from '../lib/supabase.ts'

  let managerIds = []

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("transfers-table");
  const gwFilterSelect = document.getElementById("gw-filter");
  const managerFilterSelect = document.getElementById("manager-filter")
  const loadingStatus = document.getElementById("loading-status");
  const managerCountEl = document.getElementById("manager-count");
  const refreshBtn = document.getElementById("refresh-btn");

  function populateManagerSelectorFromHistories() {
    if (!managerFilterSelect) return

    const prev = managerFilterSelect.value || ""

    // Build unique managers from histories
    const seen = new Set()
    const mgrs = []

    for (const history of allHistories || []) {
      const entryId = String(history?.[0]?.entryId ?? "")
      const managerName = String(history?.[0]?.managerName ?? "")
      if (!entryId || !managerName) continue
      if (seen.has(entryId)) continue
      seen.add(entryId)
      mgrs.push({ entryId, managerName })
    }

    mgrs.sort((a, b) => a.managerName.localeCompare(b.managerName))

    managerFilterSelect.innerHTML = `<option value="">All</option>`
    for (const m of mgrs) {
      const opt = document.createElement("option")
      opt.value = m.entryId
      opt.textContent = m.managerName
      managerFilterSelect.appendChild(opt)
    }

    // restore selection if it still exists
    if (prev && mgrs.some((m) => m.entryId === prev)) managerFilterSelect.value = prev
    else managerFilterSelect.value = ""
  }
  

  const transferModal = document.getElementById("transfer-modal");
  const modalContent = document.getElementById("modal-content");
  const chipModal = document.getElementById("chip-modal");
  const chipModalContent = document.getElementById("chip-modal-content");
  const closeChipModal = document.getElementById("close-chip-modal");

  let allHistories = [];
  let latestGW = null;
  let allPlayersMap = {};

  // Load token for cancellation
  let currentLoadToken = 0;
  const DEFAULT_FETCH_CONCURRENCY = 4;

  closeChipModal.addEventListener("click", () => {
    chipModal.classList.remove("is-open");
  });

  // ==== Persistent cache (localStorage) ====
  const TRANSFERS_CACHE_KEY = "fpl_cache_v1_transfers";
  const TRANSFERS_CACHE_TTL_MS = 12 * 60 * 60 * 1000; // 12h

  function safeJsonParse(v) {
    try { return JSON.parse(v); } catch { return null; }
  }

  function isFresh(savedAt, ttlMs) {
    if (!savedAt) return false;
    return (Date.now() - Number(savedAt)) < ttlMs;
  }

  function sameManagerIds(a, b) {
    return JSON.stringify(a || []) === JSON.stringify(b || []);
  }

  function saveTransfersSnapshot() {
    const snapshot = {
      savedAt: Date.now(),
      managerIds: managerIds || [],
      allHistories,
      latestGW,
      allPlayersMap,
      ui: {
        sortKey,
        sortDir,
        gwFilter: gwFilterSelect.value || "",
        managerFilter: managerFilterSelect?.value ?? "",
      },
    };
    localStorage.setItem(TRANSFERS_CACHE_KEY, JSON.stringify(snapshot));
  }

  function loadTransfersSnapshot() {
    const raw = localStorage.getItem(TRANSFERS_CACHE_KEY);
    const snap = safeJsonParse(raw);
    if (!snap || !Array.isArray(snap.allHistories)) return null;
    return snap;
  }

  /**
   * Concurrent mapping with limited concurrency
   */
  async function mapWithConcurrency(items, limit, fn, onProgress) {
    const results = [];
    let currentIndex = 0;
    let completed = 0;

    async function worker() {
      while (currentIndex < items.length) {
        const index = currentIndex++;
        const item = items[index];
        try {
          results[index] = await fn(item, index);
        } catch (e) {
          console.error(`Error processing item ${index}:`, e);
          results[index] = null;
        }
        completed++;
        if (onProgress) onProgress(completed, items.length);
      }
    }

    const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
    await Promise.all(workers);
    return results;
  }

  function populateGWSelector(currentGW) {
    gwFilterSelect.innerHTML = '<option value="">All GWs</option>';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = i;
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  async function fetchPlayers(cacheBuster) {
    try {
      const url = cacheBuster
        ? `/api/fpl/bootstrap-static?v=${cacheBuster}`
        : `/api/fpl/bootstrap-static`;

      const res = await fetch(url);
      if (!res.ok) return;
      const data = await res.json();

      allPlayersMap = {};
      data.elements.forEach(p => {
        allPlayersMap[p.id] = p.web_name;
      });

      const currentEvent = (data.events || []).find(e => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;
      populateGWSelector(latestGW);
    } catch (e) {
      console.error("Error fetching players:", e);
    }
  }

  function escapeHtml(str) {
    return String(str ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  // ==============================
  // Table sorting (client-side)
  // Default: Total desc
  // ==============================
  let sortKey = "totalPoints"; // "transferCost" | "gwPoints" | "totalPoints" | "FTsForNextGW"
  let sortDir = "desc";        // "asc" | "desc"
  let lastRenderedRows = [];

  function normalizeNumber(v) {
    if (v === null || v === undefined || v === "") return Number.NEGATIVE_INFINITY;
    const n = Number(v);
    return Number.isFinite(n) ? n : Number.NEGATIVE_INFINITY;
  }

  function hasAnyHits(rows) {
    return rows.some(r => Number(r?.transferCost || 0) > 0);
  }

  function sortRows(rows) {
    const copy = [...rows];
    copy.sort((a, b) => {
      const av = normalizeNumber(a?.[sortKey]);
      const bv = normalizeNumber(b?.[sortKey]);
      const delta = av - bv; // ascending
      return sortDir === "asc" ? delta : -delta;
    });
    return copy;
  }

  function setSort(nextKey) {
    if (nextKey === "transferCost") {
      if (!hasAnyHits(lastRenderedRows)) {
        sortKey = "totalPoints";
        sortDir = "desc";
        return;
      }
      if (sortKey !== "transferCost") {
        sortKey = "transferCost";
        sortDir = "desc";
        return;
      }
      sortDir = sortDir === "asc" ? "desc" : "asc";
      return;
    }

    if (nextKey === sortKey) {
      sortDir = sortDir === "asc" ? "desc" : "asc";
      return;
    }

    sortKey = nextKey;
    sortDir = "desc";
  }

  function attachSortHandlers() {
    document.querySelectorAll(".transfers-table th[data-sort]").forEach(th => {
      th.addEventListener("click", () => {
        const key = th.getAttribute("data-sort");
        if (!key) return;

        setSort(key);
        filterByGW();
        saveTransfersSnapshot();
      });
    });
  }

  function transferLineHtml(playerOut, playerIn) {
    return `
      <div style="display:flex; align-items:center; gap:var(--space-2); padding:var(--space-2); margin:var(--space-1) 0; border:1px solid var(--color-border); border-radius:var(--radius-md); font-size:var(--text-sm); flex-wrap:wrap;">
        <span class="badge badge--danger">OUT</span>
        <span class="font-bold">${escapeHtml(playerOut)}</span>
        <span class="text-muted">‚Üí</span>
        <span class="badge badge--success">IN</span>
        <span class="font-bold">${escapeHtml(playerIn)}</span>
      </div>
    `;
  }

  async function showTransferHistory(managerId, managerName) {
    modalContent.innerHTML = "<p class='text-muted'>Loading transfer history...</p>";
    transferModal.classList.add("is-open");

    try {
      const transfersRes = await fetch(`/api/fpl/entry/${managerId}/transfers`);
      const transfers = await transfersRes.json();

      const historyRes = await fetch(`/api/fpl/entry/${managerId}/history`);
      const history = await historyRes.json();

      const transfersByGW = {};
      transfers.forEach(t => {
        if (!transfersByGW[t.event]) transfersByGW[t.event] = [];
        transfersByGW[t.event].push(t);
      });

      const chipsUsed = {};
      if (history.chips) {
        history.chips.forEach(chip => {
          chipsUsed[chip.event] = chip.name;
        });
      }

      let html = `
        <button id="close-modal-btn" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
        <h2 class="modal-title">${escapeHtml(managerName)}</h2>
        <p class="text-muted" style="margin-bottom:var(--space-3); font-size:13px;">
          Total transfers: <strong>${transfers.length}</strong>
        </p>
        <div class="transfer-history-list">
      `;

      const allGWs = [...new Set([
        ...Object.keys(transfersByGW).map(Number),
        ...Object.keys(chipsUsed).map(Number)
      ])].sort((a, b) => b - a);

      for (const gw of allGWs) {
        const chip = chipsUsed[gw];
        const gwTransfers = transfersByGW[gw] || [];
        const cost = history.current?.find(h => h.event === gw)?.event_transfers_cost || 0;

        html += `<div class="transfer-gw-row">`;
        html += `<div class="transfer-gw-header">`;
        html += `<span class="transfer-gw-label">GW ${gw}</span>`;

        if (cost > 0) {
          html += `<span class="transfer-hit-badge">-${cost}</span>`;
        }
        html += `</div>`;

        html += `<div class="transfer-gw-content">`;

        if (chip) {
          const chipDisplay = chip === 'wildcard' ? 'Wildcard' :
                              chip === 'freehit' ? 'Free Hit' :
                              chip === 'bboost' ? 'Bench Boost' :
                              chip === '3xc' ? 'Triple Captain' : chip;

          const isClickableChip = chip === 'wildcard' || chip === 'freehit';

          if (isClickableChip) {
            html += `
              <div class="chip-row">
                <button class="chip-text chip-text--clickable chip-btn" data-gw="${gw}" data-manager="${managerId}" data-chip="${chip}" type="button">
                  ${chipDisplay}
                </button>
              </div>
            `;
          } else {
            html += `<div class="chip-row"><span class="chip-text">${chipDisplay}</span></div>`;
          }
        }

        const shouldShowTransfers = !chip || (chip !== 'wildcard' && chip !== 'freehit');
        if (shouldShowTransfers) {
          if (gwTransfers.length > 0) {
            for (const t of gwTransfers) {
              const playerIn = allPlayersMap[t.element_in] || `Player ${t.element_in}`;
              const playerOut = allPlayersMap[t.element_out] || `Player ${t.element_out}`;
              html += `
                <div class="transfer-row">
                  <span class="transfer-out">‚ñº ${escapeHtml(playerOut)}</span>
                  <span class="transfer-arrow">‚Üí</span>
                  <span class="transfer-in">‚ñ≤ ${escapeHtml(playerIn)}</span>
                </div>
              `;
            }
          } else {
            html += `<span class="text-muted" style="font-size:12px;">No transfers</span>`;
          }
        }

        html += `</div></div>`;
      }

      if (allGWs.length === 0) {
        html += `<p class="text-muted text-center" style="padding:var(--space-4);">No transfer activity yet.</p>`;
      }

      html += `</div>`;

      modalContent.innerHTML = html;

      document.getElementById("close-modal-btn")?.addEventListener("click", () => {
        transferModal.classList.remove("is-open");
      });

      document.querySelectorAll('.chip-btn').forEach(btn => {
        btn.addEventListener('click', async (e) => {
          const button = e.target.closest('.chip-btn');
          const gw = button.dataset.gw;
          const chip = button.dataset.chip;
          await showChipTransfers(managerId, gw, chip);
        });
      });

    } catch (error) {
      console.error("Error loading transfer history:", error);
      modalContent.innerHTML = "<p class='status status--error'>Error loading transfer history.</p>";
    }
  }

  async function showChipTransfers(managerId, gw, chipName) {
    chipModalContent.innerHTML = "<p class='text-muted'>Loading chip details...</p>";
    chipModal.classList.add("is-open");

    try {
      const picksRes = await fetch(`/api/fpl/entry/${managerId}/event/${gw}/picks`);
      const picks = await picksRes.json();

      const prevGW = parseInt(gw) - 1;
      let prevSquad = [];
      if (prevGW > 0) {
        try {
          const prevPicksRes = await fetch(`/api/fpl/entry/${managerId}/event/${prevGW}/picks`);
          const prevPicks = await prevPicksRes.json();
          prevSquad = prevPicks.picks?.map(p => p.element) || [];
        } catch (e) {
          console.warn("Couldn't fetch previous squad");
        }
      }

      const currentSquad = picks.picks?.map(p => p.element) || [];

      const playersIn = currentSquad.filter(p => !prevSquad.includes(p));
      const playersOut = prevSquad.filter(p => !currentSquad.includes(p));

      const chipDisplay = chipName === 'wildcard' ? 'üÉè Wildcard' :
                          chipName === 'freehit' ? 'üéØ Free Hit' :
                          chipName === 'bboost' ? 'ü™ë Bench Boost' :
                          chipName === '3xc' ? 'üëë Triple Captain' : chipName;

      let html = `
        <h2 class="modal-title" style="padding-right:40px;">${chipDisplay}</h2>
        <p class="text-muted" style="margin-bottom:var(--space-3); font-size:13px;">Gameweek ${gw}</p>
      `;

      if (chipName === 'wildcard' || chipName === 'freehit') {
        html += `<div class="chip-transfers-grid">`;

        html += `<div class="chip-transfer-section chip-transfer-section--out">`;
        html += `<div class="chip-transfer-header">Out (${playersOut.length})</div>`;
        html += `<div class="chip-transfer-list">`;
        if (playersOut.length > 0) {
          playersOut.forEach(pid => {
            html += `<div class="chip-transfer-item">‚ñº ${escapeHtml(allPlayersMap[pid] || `Player ${pid}`)}</div>`;
          });
        } else {
          html += `<div class="chip-transfer-item text-muted">None</div>`;
        }
        html += `</div></div>`;

        html += `<div class="chip-transfer-section chip-transfer-section--in">`;
        html += `<div class="chip-transfer-header">In (${playersIn.length})</div>`;
        html += `<div class="chip-transfer-list">`;
        if (playersIn.length > 0) {
          playersIn.forEach(pid => {
            html += `<div class="chip-transfer-item">‚ñ≤ ${escapeHtml(allPlayersMap[pid] || `Player ${pid}`)}</div>`;
          });
        } else {
          html += `<div class="chip-transfer-item text-muted">None</div>`;
        }
        html += `</div></div>`;

        html += `</div>`;
      } else {
        html += `<p class="text-muted text-center" style="padding:var(--space-3);">This chip doesn't involve transfers.</p>`;
      }

      chipModalContent.innerHTML = html;

    } catch (error) {
      console.error("Error loading chip transfers:", error);
      chipModalContent.innerHTML = "<p class='status status--error'>Error loading chip details.</p>";
    }
  }

  async function fetchHistory(id, cacheBuster) {
    const historyUrl = cacheBuster
      ? `/api/fpl/entry/${id}/history?v=${cacheBuster}`
      : `/api/fpl/entry/${id}/history`;

    const summaryUrl = cacheBuster
      ? `/api/fpl/entry/${id}?v=${cacheBuster}`
      : `/api/fpl/entry/${id}`;

    const [historyRes, summaryRes] = await Promise.all([
      fetch(historyUrl),
      fetch(summaryUrl)
    ]);

    if (!historyRes.ok || !summaryRes.ok) throw new Error("Load error");

    const historyData = await historyRes.json();
    const summaryData = await summaryRes.json();

    const managerName = `${summaryData.player_first_name} ${summaryData.player_last_name}`;

    let history = historyData.current.map(gw => ({
      entryId: Number(id),
      managerName: managerName,
      gw: gw.event,
      chipPlayed: "",
      transfers: gw.event_transfers,
      transferCost: gw.event_transfers_cost ?? 0,
      benchPoints: gw.points_on_bench ?? 0,
      gwPoints: gw.points,
      totalPoints: gw.total_points
    }));

    if (Array.isArray(historyData.chips)) {
      historyData.chips.forEach(c => {
        const row = history.find(gw => gw.gw === c.event);
        if (row) {
          row.chipPlayed = (
            c.name === "wildcard" ? "WC" :
            c.name === "bboost" ? "BB" :
            c.name === "3xc" ? "TC" :
            c.name === "freehit" ? "FH" : c.name
          );
        }
      });
    }
    return history;
  }

  function makeTable(histories, filterGW = null) {
    let rows = histories.flat();

    if (filterGW !== null && filterGW !== "") {
      const gwNum = Number(filterGW);
      rows = rows.filter(r => r.gw === gwNum);
    } else {
      rows.sort((a,b) => a.managerName.localeCompare(b.managerName) || a.gw - b.gw);
    }

    let maxGwPoints = -Infinity;
    if (filterGW !== null && filterGW !== "") {
      rows.forEach(r => {
        if (r.gwPoints > maxGwPoints) {
          maxGwPoints = r.gwPoints;
        }
      });
    }

    lastRenderedRows = rows;
    rows = sortRows(rows);

    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table transfers-table">
            <thead>
              <tr>
                <th>Manager</th>
                <th class="hit-col sortable-col ${sortKey === "transferCost" ? "is-sorted" : ""}" data-sort="transferCost">Hit</th>
                <th class="gwpts-col sortable-col ${sortKey === "gwPoints" ? "is-sorted" : ""}" data-sort="gwPoints">GWPts</th>
                <th class="total-col sortable-col ${sortKey === "totalPoints" ? "is-sorted" : ""}" data-sort="totalPoints">Total</th>
                <th class="fts-col sortable-col ${sortKey === "FTsForNextGW" ? "is-sorted" : ""}" data-sort="FTsForNextGW">FTs</th>
              </tr>
            </thead>
            <tbody>
    `;

    for (const r of rows) {
      const hitClass = r.transferCost > 0 ? 'hit-highlight' : '';

      let rowClass = '';
      const fts = Number(r.FTsForNextGW);
      if (fts >= 3 && fts <= 5) {
        rowClass = 'ft-high-row';
      } else if (fts === 2) {
        rowClass = 'ft-medium-row';
      } else if (fts === 1) {
        rowClass = 'ft-low-row';
      }

      html += `
        <tr class="${rowClass}">
          <td class="strong nowrap">
            <a href="#" class="manager-link" data-id="${r.entryId}" data-name="${r.managerName}">${r.managerName}</a>
          </td>
          <td class="num ${hitClass}">${r.transferCost || 0}</td>
          <td class="num">${r.gwPoints ?? ""}</td>
          <td class="num">${r.totalPoints ?? ""}</td>
          <td class="num strong">${r.FTsForNextGW ?? ""}</td>
        </tr>
      `;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;
    return html;
  }

  async function loadManagers(ids, cacheBuster) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    const loadToken = ++currentLoadToken;
    refreshBtn.disabled = true;

    allHistories = [];
    latestGW = null;
    out.innerHTML = "";
    loadingStatus.textContent = `Fetching latest data...`;

    const historyResults = await mapWithConcurrency(
      ids,
      DEFAULT_FETCH_CONCURRENCY,
      async (id) => {
        try {
          const history = await fetchHistory(id, cacheBuster);
          calculateFTs(history);
          return history;
        } catch (e) {
          console.error(`Failed to load manager ${id}:`, e);
          return null;
        }
      },
      (completed, total) => {
        loadingStatus.textContent = `Fetching ${completed}/${total}...`;
      }
    );

    if (loadToken !== currentLoadToken) {
      console.log('Load superseded, aborting');
      return;
    }

    allHistories = historyResults.filter((history) => history !== null);
    populateManagerSelectorFromHistories()


    for (const history of allHistories) {
      const managerMaxGW = Math.max(...history.map(h => h.gw));
      if (latestGW === null || managerMaxGW > latestGW) {
        latestGW = managerMaxGW;
      }
    }

    if (allHistories.length > 0) {
      out.innerHTML = makeTable(allHistories, "");
      attachManagerLinks();
      attachSortHandlers();
    }

    loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${allHistories.length} managers</span>`;

    if (managerFilterSelect) {
      const prev = managerFilterSelect.value
      managerFilterSelect.innerHTML = `<option value="">All</option>`

      // Build unique managers list from loaded histories
      const mgrs = allHistories
        .map((h) => ({
          entryId: String(h?.[0]?.entryId ?? ""),
          managerName: String(h?.[0]?.managerName ?? ""),
        }))
        .filter((m) => m.entryId && m.managerName)

      mgrs.sort((a, b) => a.managerName.localeCompare(b.managerName))

      for (const m of mgrs) {
        const opt = document.createElement("option")
        opt.value = m.entryId
        opt.textContent = m.managerName
        managerFilterSelect.appendChild(opt)
      }

      managerFilterSelect.value = prev
    }


    if (latestGW) {
      if (!gwFilterSelect.value) {
        gwFilterSelect.value = latestGW;
      }
      filterByGW();
    }

    refreshBtn.disabled = false;

    // Persist snapshot
    saveTransfersSnapshot();
  }

  function attachManagerLinks() {
    document.querySelectorAll('.manager-link').forEach(link => {
      link.addEventListener('click', (e) => {
        e.preventDefault();
        const managerId = e.target.dataset.id;
        const managerName = e.target.dataset.name;
        showTransferHistory(managerId, managerName);
      });
    });
  }

  function filterByGW() {
    const filterGW = gwFilterSelect.value || ""
    const managerEntryId = managerFilterSelect?.value || ""

    let historiesToRender = allHistories

    // IMPORTANT: filter allHistories (array of manager histories), not the flattened rows
    if (managerEntryId) {
      historiesToRender = allHistories.filter((history) => {
        const entryId = String(history?.[0]?.entryId ?? "")
        return entryId === managerEntryId
      })
    }

    out.innerHTML = makeTable(historiesToRender, filterGW)
    attachManagerLinks()
   attachSortHandlers()
  }


  (async function init() {
    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (!authenticated) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    const snap = loadTransfersSnapshot();
    const canUseSnap =
      snap &&
      Array.isArray(snap.allHistories) &&
      snap.allHistories.length > 0 &&
      sameManagerIds(snap.managerIds, managerIds);

    if (canUseSnap) {
      allHistories = snap.allHistories;
      populateManagerSelectorFromHistories()
      latestGW = snap.latestGW ?? null;
      allPlayersMap = snap.allPlayersMap || {};

      sortKey = snap.ui?.sortKey || sortKey;
      sortDir = snap.ui?.sortDir || sortDir;

      populateGWSelector(latestGW || 1);
      gwFilterSelect.value = (snap.ui?.gwFilter ?? (latestGW || "")) + "";
      
      if (managerFilterSelect) {
        managerFilterSelect.value = snap.ui?.managerFilter ?? ""
      }


      filterByGW();
      loadingStatus.textContent = `Loaded from cache.`;

      if (!isFresh(snap.savedAt, TRANSFERS_CACHE_TTL_MS)) {
        (async () => {
          try {
            loadingStatus.textContent = `Refreshing in background...`;
            const bust = Date.now().toString();
            await fetchPlayers(bust);
            await loadManagers(managerIds, bust);
            loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Updated</span>`;
          } catch (e) {
            console.warn("Background refresh failed:", e);
            loadingStatus.textContent = `Loaded from cache. (Background refresh failed)`;
          }
        })();
      }
      return;
    }

    await fetchPlayers(); // no cache-buster

    if (managerIds.length > 0) {
      loadManagers(managerIds); // no cache-buster
    } else {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
    }
  })();

  gwFilterSelect.addEventListener('change', () => {
    filterByGW();
    saveTransfersSnapshot()
  })

  managerFilterSelect?.addEventListener("change", () => {
    filterByGW()
    saveTransfersSnapshot()
  })

  refreshBtn.addEventListener('click', async () => {
    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (!authenticated) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    const bust = Date.now().toString();
    await fetchPlayers(bust);
    await loadManagers(managerIds, bust);
  });
</script>

---
import Nav from '../components/Nav.astro';
---

<Nav />
<h1>Transfers & Free Transfers (FTs) for Next GW</h1>
<p>Display calculated FTs for next GW for any set of managers, like your Excel.</p>

<form id="manager-form">
  <label for="ids">Manager EntryIDs (one per line):</label><br>
  <textarea id="ids" rows="6" cols="30" style="font-family:monospace" placeholder="4290&#10;200&#10;1320"></textarea><br>
  <button type="submit">Load History</button>
  
  <div style="margin-top: 1em;">
    <label for="gw-filter">Filter by Gameweek (leave blank for all):</label><br>
    <input type="number" id="gw-filter" min="1" max="38" placeholder="e.g. 22" style="width: 100px; padding: 5px;">
  </div>
</form>

<div id="transfers-table" style="margin-top:1.5em"></div>

<script type="module">
// Inline FT calculation logic - MATCHES EXCEL EXACTLY
function calculateFTs(managerHistory) {
  const byGW = new Map();
  managerHistory.forEach(row => byGW.set(row.gw, row));

  // Step 1: Calculate "FTs Start of GW" for all gameweeks
  for (let i = 0; i < managerHistory.length; ++i) {
    const row = managerHistory[i];
    const E = Number(row.gw);           // Current GW
    const M = Number(row.transfers);    // Transfers made
    
    let Q = 1; // Default: 1 FT
    
    // Check if previous GW exists for this manager (mimics column S)
    const prevRow = byGW.get(E - 1);
    const S = prevRow ? 1 : 0;  // S2 equivalent: does prev GW exist?
    
    if (E === 16) {
      // GW16: Winter wildcard refresh
      Q = 5;
    } else if (E === 1) {
      // GW1: Start with 0 FTs
      Q = 0;
    } else if (S === 0) {
      // No previous GW data for this manager
      Q = 1;
    } else if (!prevRow) {
      // Double-check: no previous row found
      Q = 1;
    } else {
      // Previous GW data exists
      const prevChip = prevRow.chipPlayed || "";
      const prevFTs = Number(prevRow.FTsStartOfGW);
      const prevTransfers = Number(prevRow.transfers);
      
      if (prevChip === "WC" || prevChip === "FH") {
        // After Wildcard or Free Hit: MAX(1, prevFTs - prevTransfers)
        Q = Math.max(1, prevFTs - prevTransfers);
      } else {
        // Normal case: MIN(MAX(1, prevFTs - prevTransfers + 1), 5)
        Q = Math.min(Math.max(1, prevFTs - prevTransfers + 1), 5);
      }
    }
    
    row.FTsStartOfGW = Q;
  }

  // Step 2: Calculate "FTs for Next GW" (only for the most recent GW)
  const maxGW = Math.max(...managerHistory.map(r => r.gw));
  
  managerHistory.forEach(row => {
    if (row.gw === maxGW) {
      const E = Number(row.gw);
      const Q = Number(row.FTsStartOfGW);
      const M = Number(row.transfers);
      const F = row.chipPlayed || "";
      
      if (E === 15) {
        // GW15 â†’ GW16 gets winter wildcard refresh
        row.FTsForNextGW = 5;
      } else {
        // MIN(MAX(1, Q - M + inc), 5) where inc = 0 if WC/FH, else 1
        const inc = (F === "WC" || F === "FH") ? 0 : 1;
        row.FTsForNextGW = Math.min(Math.max(1, Q - M + inc), 5);
      }
    } else {
      row.FTsForNextGW = "";
    }
  });
}

// Local storage helpers
function saveEntryIds(ids) {
  localStorage.setItem("entryIds", JSON.stringify(ids));
}
function loadEntryIds() {
  try {
    return JSON.parse(localStorage.getItem("entryIds")) || [];
  } catch {
    return [];
  }
}

const defaultIds = ["4290","200","1320","1587","6586","260"];
const form = document.getElementById("manager-form");
const textarea = document.getElementById("ids");
const out = document.getElementById("transfers-table");
const gwFilterInput = document.getElementById("gw-filter");

// Try to load IDs from localStorage, else use default:
const idsFromStorage = loadEntryIds();
if (idsFromStorage.length > 0) {
  textarea.value = idsFromStorage.join("\n");
} else {
  textarea.value = defaultIds.join("\n");
}

let allHistories = []; // Store all data for filtering

async function fetchHistory(id) {
  const url = `/api/fpl/entry/${id}/history`;
  const res = await fetch(url);
  if (!res.ok) throw new Error("Load error");
  const data = await res.json();
  let history = data.current.map(gw => ({
    entryId: Number(id),
    gw: gw.event,
    chipPlayed: "",
    transfers: gw.event_transfers,
    transferCost: gw.event_transfers_cost ?? 0,
    benchPoints: gw.points_on_bench ?? 0,
    gwPoints: gw.points,
    totalPoints: gw.total_points
  }));
  if (Array.isArray(data.chips)) {
    data.chips.forEach(c => {
      const row = history.find(gw => gw.gw === c.event);
      if (row) {
        row.chipPlayed = (
          c.name === "wildcard" ? "WC" :
          c.name === "bboost" ? "BB" :
          c.name === "3xc" ? "TC" :
          c.name === "freehit" ? "FH" : c.name
        );
      }
    });
  }
  return history;
}

function makeTable(histories, filterGW = null) {
  let rows = histories.flat();
  rows.sort((a,b) => a.entryId-b.entryId || a.gw-b.gw);

  // Apply GW filter if specified
  if (filterGW !== null && filterGW !== "") {
    const gwNum = Number(filterGW);
    rows = rows.filter(r => r.gw === gwNum);
  }

  let html = `<table border="1" cellpadding="4" style="border-collapse:collapse">
    <tr>
      <th>EntryID</th>
      <th>GW</th>
      <th>ChipPlayed</th>
      <th>Transfers</th>
      <th>TransferCost</th>
      <th>GW Points</th>
      <th>Total Points</th>
      <th>FTs Start of GW</th>
      <th style="background:lightyellow">FTs for next GW</th>
    </tr>`;
  for (const r of rows) {
    html += `<tr>
      <td>${r.entryId}</td>
      <td>${r.gw}</td>
      <td>${r.chipPlayed || ""}</td>
      <td>${r.transfers ?? ""}</td>
      <td>${r.transferCost ?? ""}</td>
      <td>${r.gwPoints ?? ""}</td>
      <td>${r.totalPoints ?? ""}</td>
      <td>${r.FTsStartOfGW ?? ""}</td>
      <td style="background:lightyellow">${r.FTsForNextGW ?? ""}</td>
    </tr>`;
  }
  html += "</table>";
  return html;
}

async function loadManagers(ids) {
  out.textContent = "Loading...";
  try {
    allHistories = [];
    for (const id of ids) {
      let history = await fetchHistory(id);
      calculateFTs(history);
      allHistories.push(history);
    }
    const filterGW = gwFilterInput.value.trim();
    out.innerHTML = makeTable(allHistories, filterGW);
    saveEntryIds(ids); // Save to localStorage on success
  } catch (e) {
    out.innerHTML = "<span style='color:red'>Error loading history. Check EntryIDs and network connection.</span>";
  }
}

// Filter function
function filterByGW() {
  const filterGW = gwFilterInput.value.trim();
  out.innerHTML = makeTable(allHistories, filterGW);
}

// Initial load
const parsedIds = textarea.value.trim().split(/[\s,]+/).filter(x => x.match(/^\d+$/));
if (parsedIds.length) loadManagers(parsedIds);

form.onsubmit = (e) => {
  e.preventDefault();
  const ids = textarea.value.trim().split(/[\s,]+/).filter(x => x.match(/^\d+$/));
  if (ids.length === 0) {
    out.innerHTML = "<span style='color:red'>Enter at least one valid EntryID.</span>";
    return;
  }
  loadManagers(ids);
};

gwFilterInput.addEventListener('input', filterByGW);
</script>
---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="Live League Standings - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">üî¥  Live Standings  üî¥</h1>
      <p class="page-subtitle">Real-time league table with live points, projected bonus & auto subs.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">‚öô Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="compare-manager">Compare to</label>
        <select class="select-small" id="compare-manager">
          <option value="">Leader</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small">&nbsp;</label>
        <button id="refresh-btn" class="btn-row" type="button">üîÑ Refresh</button>
      </div>
    </div>

    <div id="loading-status" class="meta-row"></div>
    <div id="last-updated" class="meta-row"></div>
    <section id="live-output" aria-live="polite"></section>
  </main>

  <!-- Squad Modal -->
  <div id="squad-modal" class="modal">
    <div class="modal-panel">
      <button id="close-squad-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="squad-modal-content"></div>
    </div>
  </div>

  <!-- Player Stats Modal -->
  <div id="player-modal" class="modal modal--nested">
    <div class="modal-panel modal-panel--compact">
      <button id="close-player-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="player-modal-content"></div>
    </div>
  </div>

  <!-- GW Points Modal (nested on top of player modal) -->
  <div id="gw-points-modal" class="modal modal--nested modal--gw-points">
    <div class="modal-panel modal-panel--gw-points">
      <button class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div class="gw-points-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 32px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .buttons-row {
    display: flex;
    gap: var(--space-2);
  }

  .btn-row {
    flex: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
  }

  .btn-row:hover {
    background: var(--color-primary-hover);
  }

  .btn-row--neutral {
    background: var(--color-surface);
    color: var(--color-text);
    border: 1px solid var(--color-border);
  }

  .btn-row--neutral:hover {
    background: var(--color-surface-alt);
  }

  .btn-row--success {
    background: var(--color-success);
    color: white;
  }

  .btn-row--success:hover {
    background: var(--color-success-hover);
  }

  /* GW Points Modal Styles */
  .modal--gw-points {
    z-index: 10002; /* Higher than nested player modal */
  }

  .modal-panel--gw-points {
    max-width: 500px; /* Narrower for single column */
    max-height: 85vh;
    overflow: hidden; /* Let wrapper handle scroll */
  }

  .gw-points-title {
    font-size: 18px;
    font-weight: 700;
    color: var(--color-text);
    margin-bottom: var(--space-3);
    text-align: center;
  }

  .gw-points-table-wrapper {
    max-height: 60vh;
    overflow-y: auto;
    overflow-x: auto;
  }

  .gw-points-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    min-width: 280px; /* Ensure minimum width for mobile */
  }

  .gw-points-table thead {
    background: var(--color-surface-alt);
    position: sticky;
    top: 0;
    z-index: 1;
  }

  .gw-points-table th {
    padding: var(--space-2) var(--space-1);
    text-align: center;
    font-weight: 600;
    color: var(--color-text-secondary);
    border-bottom: 2px solid var(--color-border);
    border-right: 1px solid var(--color-border);
  }

  .gw-points-table th:last-child {
    border-right: none;
  }

  .gw-points-table td {
    padding: var(--space-2) var(--space-1);
    border-bottom: 1px solid var(--color-border);
    border-right: 1px solid var(--color-border);
    text-align: center;
  }

  .gw-points-table td:last-child {
    border-right: none;
  }

  .gw-points-table tbody tr:hover {
    background: var(--color-surface-alt);
  }

  /* Column-specific styles */
  .gw-points-table .gw-col {
    font-weight: 600;
    width: 15%;
    min-width: 40px;
  }

  .gw-points-table .opp-col {
    width: 40%;
    min-width: 90px;
  }

  .gw-points-table .mins-col {
    width: 20%;
    min-width: 50px;
  }

  .gw-points-table .pts-col {
    width: 25%;
    min-width: 60px;
    font-weight: 600;
  }

  /* Mobile optimization */
  @media (max-width: 480px) {
    .modal-panel--gw-points {
      max-width: 95vw;
    }

    .gw-points-table {
      font-size: 12px;
      min-width: 260px;
    }

    .gw-points-table th,
    .gw-points-table td {
      padding: var(--space-1) 4px;
    }

    .gw-points-title {
      font-size: 16px;
      margin-bottom: var(--space-2);
    }
  }

  .gw-points-loading,
  .gw-points-error,
  .gw-points-empty {
    text-align: center;
    padding: var(--space-6);
  }

  .gw-points-loading-text {
    color: var(--color-text-secondary);
    margin-top: var(--space-2);
  }

  .gw-points-error-text {
    color: var(--color-danger);
    margin-top: var(--space-2);
  }

  .gw-points-error-details {
    color: var(--color-text-secondary);
    font-size: 12px;
    margin-top: var(--space-1);
  }

  .gw-points-empty-text {
    color: var(--color-text-secondary);
    margin-top: var(--space-2);
  }

  :global(.player-modal-bps-table) {
    margin-top: var(--space-3);
  }

  :global(.player-modal-bps-table + .player-modal-match) {
    margin-top: var(--space-3);
  }

  :global(.bps-table-wrapper) {
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
    overflow: hidden;
  }

  :global(.bps-table) {
    width: 100%;
    border-collapse: collapse;
    font-size: 12px;
  }

  :global(.bps-table th) {
    background: var(--color-surface-alt);
    padding: 6px 8px;
    text-align: left;
    font-size: 11px;
    font-weight: 700;
    color: var(--color-text-secondary);
    border-bottom: 1px solid var(--color-border);
  }

  :global(.bps-table td) {
    padding: 6px 8px;
    border-top: 1px solid var(--color-border);
  }

  :global(.bps-cell) {
    display: flex;
    justify-content: space-between;
    gap: var(--space-2);
    align-items: center;
  }

  :global(.bps-player) {
    font-weight: 600;
    color: var(--color-text);
  }

  :global(.bps-score) {
    font-weight: 700;
    color: var(--color-text);
  }

  :global(.bps-empty),
  :global(.bps-table-empty) {
    color: var(--color-text-muted);
    text-align: center;
    padding: var(--space-3);
  }
</style>

<script>
  import { supabase } from '../lib/supabase.ts'
  import { applyAutoSubsAndMultipliers, fetchFixtures, fetchLiveGW, getPlayerLiveComputed, getTeamGwStatus, type FixtureInfo, type LiveStatLine, type TeamStatus } from '../lib/fplLive.ts'
  import { initGWPointsModal, makePlayerNameClickable } from '../lib/gwPointsModal.js';

  let managerIds: number[] = []

  // ==============================
  // SWR + localStorage snapshot (Live Standings)
  // ==============================
  const LIVE_SNAPSHOT_KEY_PREFIX = 'fpl_live_snapshot_v1:'; // per-GW key: `${prefix}${gw}`
  const LIVE_TTL_MS = Number.POSITIVE_INFINITY; // cache until manual refresh
  const LIVE_REFRESH_THROTTLE_MS = 8 * 1000; // avoid hammering refreshes

  type LiveSnapshot = {
    ts: number;
    gw: number;
    compareToId: string;
    liveSortKey: "livePointsBeforeHits" | "transferCost" | "livePoints" | "totalPoints" | "diff";
    liveSortDir: "asc" | "desc";
    managerIds: number[];
    data: any[];
    latestGW: number;
  };

  let lastBackgroundRefreshAt = 0;

  function safeJsonParse<T>(value: string | null): T | null {
    if (!value) return null;
    try { return JSON.parse(value) as T; } catch { return null; }
  }

  function liveSnapshotKeyForGw(gw: number) {
    return `${LIVE_SNAPSHOT_KEY_PREFIX}${gw}`;
  }

  function loadLiveSnapshot(gw: number): LiveSnapshot | null {
    return safeJsonParse<LiveSnapshot>(localStorage.getItem(liveSnapshotKeyForGw(gw)));
  }

  function saveLiveSnapshot(snapshot: LiveSnapshot) {
    try {
      localStorage.setItem(liveSnapshotKeyForGw(snapshot.gw), JSON.stringify(snapshot));
    } catch (e) {
      console.warn('Could not save live snapshot', e);
    }
  }

  function isSnapshotUsable(s: LiveSnapshot | null, gw: number, ids: number[]) {
    if (!s) return false;
    if (!Array.isArray(s.data)) return false;
    if (Number(s.gw) !== Number(gw)) return false;

    // Make sure it's the same manager set (order-insensitive)
    const a = [...(s.managerIds || [])].map(Number).sort((x, y) => x - y);
    const b = [...ids].map(Number).sort((x, y) => x - y);
    if (a.length !== b.length) return false;
    for (let i = 0; i < a.length; i++) if (a[i] !== b[i]) return false;

    return true;
  }

  function renderLiveFromState() {
    // Ensure dropdown options exist before we read and render with the value
    populateCompareManager();

    const compareId = compareManagerSelect.value;
    out.innerHTML = makeLiveTable(liveData, compareId);
    attachManagerButtons();
    attachLiveSortHandlers();
  }

  const managerDataCache = new Map<string, any>();
  const squadPicksCache = new Map<string, any>();

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("live-output")!;
  const gwFilterSelect = document.getElementById("gw-filter") as HTMLSelectElement;
  const compareManagerSelect = document.getElementById("compare-manager") as HTMLSelectElement;
  const loadingStatus = document.getElementById("loading-status")!;
  const lastUpdatedEl = document.getElementById("last-updated")!;
  const managerCountEl = document.getElementById("manager-count")!;
  const refreshBtn = document.getElementById("refresh-btn")!;
  const squadModal = document.getElementById("squad-modal")!;
  const squadModalContent = document.getElementById("squad-modal-content")!;
  const closeSquadModal = document.getElementById("close-squad-modal")!;
  const playerModal = document.getElementById("player-modal")!;
  const playerModalContent = document.getElementById("player-modal-content")!;
  const closePlayerModal = document.getElementById("close-player-modal")!;

  interface PlayerInfo {
    name: string;
    position: number;
    team: number;
  }

  interface TeamInfo {
    name: string;
    shortName: string;
  }

  interface LiveStats extends LiveStatLine {
    bps: number;
    goals_scored: number;
    assists: number;
    clean_sheets: number;
    goals_conceded: number;
    own_goals: number;
    penalties_saved: number;
    penalties_missed: number;
    yellow_cards: number;
    red_cards: number;
    saves: number;
    clearances_blocks_interceptions: number;
    recoveries: number;
    tackles: number;
    defensive_contribution: number;
  }

  type BpsEntry = {
    name: string;
    value: number;
  };

  const BPS_LIMIT = 6;

  let liveData: any[] = [];
  let latestGW: number = 1;
  let playerCache = new Map<number, PlayerInfo>();
  let teamCache = new Map<number, TeamInfo>();
  let livePointsCache = new Map<number, LiveStats>();
  let projectedBonusCache = new Map<string, number>();
  let teamStatusCache = new Map<string, TeamStatus>();
  let fixturesCache: FixtureInfo[] = [];

  // Keep track of which GW the in-memory live caches refer to
  let liveCachesGw: number | null = null;
  let liveCachesLoadedAt = 0;
  const LIVE_CACHES_TTL_MS = 60_000; // 60s ‚Äì adjust or remove TTL if you prefer

  async function ensureLiveCaches(gw: number, opts?: { force?: boolean }) {
    const now = Date.now();
    const stale = now - liveCachesLoadedAt > LIVE_CACHES_TTL_MS;
    const wrongGw = liveCachesGw !== gw;
    const force = !!opts?.force;

    // If caches look fine for this GW and are fresh, do nothing
    if (
      !force &&
      !wrongGw &&
      !stale &&
      livePointsCache.size > 0 &&
      fixturesCache.length > 0
    ) {
      return;
    }

    // Reset caches
    fixturesCache = [];
    livePointsCache.clear();
    projectedBonusCache.clear();
    teamStatusCache.clear();

    // Refill caches for this GW
    await Promise.all([
      fetchFixtures({
        gw,
        fixturesCache,
        projectedBonusCache,
        teamStatusCache,
        includeFinishedProvisional: true,
        cacheBuster: undefined
      }),
      fetchLiveGW({
        gw,
        livePointsCache,
        includeExtendedStats: true,
        cacheBuster: undefined
      })
    ]);

    liveCachesGw = gw;
    liveCachesLoadedAt = now;
  }

  
  // ==============================
  // Live table sorting (client-side)
  // Default: GW desc (tie-break: Total desc)
  // ==============================
  let liveSortKey: "livePointsBeforeHits" | "transferCost" | "livePoints" | "totalPoints" | "diff" = "livePointsBeforeHits";
  let liveSortDir: "asc" | "desc" = "desc";

  function normalizeNumber(v: any) {
    if (v === null || v === undefined || v === "") return Number.NEGATIVE_INFINITY;
    const n = Number(v);
    return Number.isFinite(n) ? n : Number.NEGATIVE_INFINITY;
  }

  function forceDefaultLiveSort() {
    liveSortKey = "livePointsBeforeHits";
    liveSortDir = "desc";
  }

  function sortLiveRows(rows: any[]) {
    const copy = [...rows];
    copy.sort((a, b) => {
      const av = normalizeNumber(a?.[liveSortKey]);
      const bv = normalizeNumber(b?.[liveSortKey]);
      const primaryDelta = av - bv; // asc

      // Apply primary sort
      const primaryResult = liveSortDir === "asc" ? primaryDelta : -primaryDelta;
      if (primaryResult !== 0) return primaryResult;

      // Tie-breaker: when sorting by GW, sort by Total desc
      if (liveSortKey === "livePointsBeforeHits") {
        const at = normalizeNumber(a?.totalPoints);
        const bt = normalizeNumber(b?.totalPoints);
        const totalDelta = at - bt; // asc
        return -totalDelta; // desc
      }

      return 0;
    });
    return copy;
  }

  function setLiveSort(nextKey: typeof liveSortKey) {
    if (nextKey === liveSortKey) {
      liveSortDir = liveSortDir === "asc" ? "desc" : "asc";
      return;
    }
    liveSortKey = nextKey;
    // default direction by column
    liveSortDir = "desc";
  }

  function attachLiveSortHandlers() {
    document.querySelectorAll(".live-table th[data-sort]").forEach(th => {
      th.addEventListener("click", () => {
        const key = th.getAttribute("data-sort") as typeof liveSortKey | null;
        if (!key) return;

        setLiveSort(key);

        // Re-render without refetch
        const compareId = compareManagerSelect.value;
        out.innerHTML = makeLiveTable(liveData, compareId);
        attachManagerButtons();
        attachLiveSortHandlers();
      });
    });
  }

  // Load token for cancellation
  let currentLoadToken = 0;
  const DEFAULT_FETCH_CONCURRENCY = 4;

  closeSquadModal.addEventListener("click", () => {
    squadModal.classList.remove("is-open");
  });

  closePlayerModal.addEventListener("click", () => {
    playerModal.classList.remove("is-open");
  });

  // Initialize GW Points Modal
  const gwPointsModal = initGWPointsModal('gw-points-modal');

  function populateGWSelector(currentGW: number) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = String(i);
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  function positionLabel(elementType: number): string {
    if (elementType === 1) return "GK";
    if (elementType === 2) return "DEF";
    if (elementType === 3) return "MID";
    return "FWD";
  }

  function getTeamGwStatusLocal(teamId: number, gw: number) {
    return getTeamGwStatus(teamStatusCache, teamId, gw);
  }

  function getPlayerLiveComputedLocal(playerId: number, teamId: number, gw: number) {
    return getPlayerLiveComputed({
      playerId,
      teamId,
      gw,
      livePointsCache,
      projectedBonusCache,
      teamStatusCache,
      bonusConfirmedOnProvisional: false
    });
  }

  async function mapWithConcurrency<T, R>(
    items: T[],
    limit: number,
    fn: (item: T, index: number) => Promise<R | null>,
    onProgress?: (completed: number, total: number) => void
  ): Promise<(R | null)[]> {
    const results: (R | null)[] = [];
    let currentIndex = 0;
    let completed = 0;

    async function worker() {
      while (currentIndex < items.length) {
        const index = currentIndex++;
        const item = items[index];
        try {
          results[index] = await fn(item, index);
        } catch (e) {
          console.error(`Error processing item ${index}:`, e);
          results[index] = null;
        }
        completed++;
        if (onProgress) {
          onProgress(completed, items.length);
        }
      }
    }

    const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
    await Promise.all(workers);
    return results;
  }

  async function fetchBootstrapData(cacheBuster?: string) {
    try {
      const v = cacheBuster || Date.now().toString();
      const res = await fetch(`/api/fpl/bootstrap-static?v=${v}`, { cache: "no-store" });
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      data.elements.forEach((player: any) => {
        playerCache.set(player.id, {
          name: player.web_name,
          position: player.element_type,
          team: player.team
        });
      });

      data.teams.forEach((team: any) => {
        teamCache.set(team.id, {
          name: team.name,
          shortName: team.short_name
        });
      });

      const activeEvent = data.events.filter((e: any) => new Date(e.deadline_time) < new Date()).pop();
      latestGW = activeEvent ? activeEvent.id : 1;

      populateGWSelector(latestGW);

      return data;
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
      return null;
    }
  }

  async function fetchManagerLive(entryId: number, gw: number, cacheBuster?: string) {
    try {
      const cacheKey = `${entryId}:${gw}`;
      let rawData = managerDataCache.get(cacheKey);

      const v = cacheBuster || '';


      if (!rawData) {
         const [picksRes, summaryRes, historyRes] = await Promise.all([
          fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks?v=${v}`, { cache: "no-store" }),
          fetch(`/api/fpl/entry/${entryId}?v=${v}`, { cache: "no-store" }),
          fetch(`/api/fpl/entry/${entryId}/history?v=${v}`, { cache: "no-store" })
        ]);

        if (!picksRes.ok || !summaryRes.ok || !historyRes.ok) {
          throw new Error("Failed to fetch manager data");
        }

        const picksData = await picksRes.json();
        const summaryData = await summaryRes.json();
        const historyData = await historyRes.json();
        
        rawData = { picksData, summaryData, historyData };
        managerDataCache.set(cacheKey, rawData);
      }

      const { picksData, summaryData, historyData } = rawData;

      const chipName = (historyData.chips || []).find((c: any) => c.event === gw)?.name || "";
      const chipCode =
        chipName === "bboost" ? "BB" :
        chipName === "3xc" ? "TC" :
        chipName === "wildcard" ? "WC" :
        chipName === "freehit" ? "FH" :
        "None";

      const rawPicks = Array.isArray(picksData.picks) ? picksData.picks : [];

      const picks = rawPicks.map((p: any) => {
        const player = playerCache.get(p.element) || { name: "", position: 4, team: 0 };
        const teamId = Number(player.team) || 0;

        const computed = getPlayerLiveComputedLocal(p.element, teamId, gw);

        return {
          playerId: Number(p.element),
          position: Number(p.position),
          is_captain: !!p.is_captain,
          is_vice_captain: !!p.is_vice_captain,

          web_name: player.name || "",
          teamId,
          playingPosition: positionLabel(player.position),

          minutes: computed.minutes,
          status: computed.status,
          lockedPoints: computed.locked,
          projBonus: computed.projBonus,
          liveTotal: computed.liveTotal
        };
      });

      const finalTeam = applyAutoSubsAndMultipliers(picks, chipCode);

      const livePointsBeforeHits = finalTeam.reduce((sum, p) => sum + (p.liveTotal * (p.multiplier || 0)), 0);

      const historyRows = Array.isArray(historyData.current) ? historyData.current : [];
      const transferCost =
        Number(historyRows.find((h: any) => Number(h.event) === Number(gw))?.event_transfers_cost) || 0;

      const liveNet = livePointsBeforeHits - transferCost;

      // =========================
      // TOTAL POINTS (projected)
      // =========================
      let totalPoints = 0;

      if (Number(gw) === Number(latestGW)) {
        const prevGw = Number(gw) - 1;
        const prevRow =
          prevGw >= 1
            ? historyRows.find((h: any) => Number(h.event) === prevGw)
            : null;

        const startOverall = Number(prevRow?.total_points) || 0;
        totalPoints = startOverall + liveNet;
      } else {
        const gwRow = historyRows.find((h: any) => Number(h.event) === Number(gw));
        totalPoints = Number(gwRow?.total_points) || 0;
      }

      return {
        entryId,
        managerName: `${summaryData.player_first_name || ""} ${summaryData.player_last_name || ""}`.trim(),
        teamName: summaryData.name || "",
        chipPlayed: chipCode === "None" ? "" : chipCode,
        transferCost,
        livePointsBeforeHits,
        livePoints: liveNet,
        totalPoints
      };
    } catch (e) {
      console.error(`Error fetching live data for manager ${entryId}:`, e);
      return null;

    }
  }

  function getPlayerFixtures(teamId: number): FixtureInfo[] {
  return fixturesCache
    .filter(f => f.team_h === teamId || f.team_a === teamId)
    .sort((a, b) => {
      const aTime = a.kickoff_time ? new Date(a.kickoff_time).getTime() : 0;
      const bTime = b.kickoff_time ? new Date(b.kickoff_time).getTime() : 0;
      return aTime - bTime;
    });
}

  function calculateDefcon(position: number, defensiveContribution: number): { points: number; threshold: number } {
    if (position === 1) return { points: 0, threshold: 0 };
    const threshold = position === 2 ? 10 : 12;
    const points = defensiveContribution >= threshold ? 2 : 0;
    return { points, threshold };
  }

  function buildStatsFromExplain(statsRows: any[]): LiveStats {
  const base: LiveStats = {
    points: 0,
    bonus: 0,
    minutes: 0,
    bps: 0,
    goals_scored: 0,
    assists: 0,
    clean_sheets: 0,
    goals_conceded: 0,
    own_goals: 0,
    penalties_saved: 0,
    penalties_missed: 0,
    yellow_cards: 0,
    red_cards: 0,
    saves: 0,
    clearances_blocks_interceptions: 0,
    recoveries: 0,
    tackles: 0,
    defensive_contribution: 0
  };

  if (!Array.isArray(statsRows)) return base;

  statsRows.forEach((row: any) => {
    const key = row?.identifier as keyof LiveStats;
    if (!key) return;
    if (key in base) {
      (base as any)[key] = Number(row?.value || 0);
    }
  });

  return base;
}

function buildBreakdownRows(
  stats: LiveStats,
  position: number,
  isFinished: boolean,
  projBonus: number
) {
  const isGK = position === 1;
  const isDef = position === 2;
  const defcon = calculateDefcon(position, stats.defensive_contribution);

  return [
    { label: "Minutes", value: stats.minutes, points: stats.minutes >= 60 ? 2 : (stats.minutes > 0 ? 1 : 0), show: true },
    { label: "Goals", value: stats.goals_scored, points: getGoalPoints(position, stats.goals_scored), show: stats.goals_scored > 0 },
    { label: "Assists", value: stats.assists, points: stats.assists * 3, show: stats.assists > 0 },
    { label: "Clean Sheet", value: stats.clean_sheets, points: getCleanSheetPoints(position, stats.clean_sheets), show: stats.clean_sheets > 0 && getCleanSheetPoints(position, stats.clean_sheets) > 0 },
    { label: "Goals Conceded", value: stats.goals_conceded, points: (isGK || isDef) ? -Math.floor(stats.goals_conceded / 2) : 0, show: (isGK || isDef) && stats.goals_conceded >= 2 },
    { label: "Saves", value: stats.saves, points: Math.floor(stats.saves / 3), show: isGK && stats.saves > 0 },
    { label: "Pen Saved", value: stats.penalties_saved, points: stats.penalties_saved * 5, show: stats.penalties_saved > 0 },
    { label: "Pen Missed", value: stats.penalties_missed, points: stats.penalties_missed * -2, show: stats.penalties_missed > 0 },
    { label: "Own Goals", value: stats.own_goals, points: stats.own_goals * -2, show: stats.own_goals > 0 },
    { label: "Yellow Card", value: stats.yellow_cards, points: stats.yellow_cards * -1, show: stats.yellow_cards > 0 },
    { label: "Red Card", value: stats.red_cards, points: stats.red_cards * -3, show: stats.red_cards > 0 },
    { label: "Bonus", value: stats.bonus || projBonus, points: stats.bonus || projBonus, show: (stats.bonus > 0) || (projBonus > 0 && isFinished) },
    {
      label: "DEFCON",
      value: `${stats.defensive_contribution}/${defcon.threshold}`,
      points: defcon.points,
      show: !isGK && stats.minutes > 0,
      isProgress: true
    }
  ];
}

  function buildStatsFromHistoryRow(row: any): LiveStats {
    return {
      points: Number(row?.total_points || 0),
      bonus: Number(row?.bonus || 0),
      minutes: Number(row?.minutes || 0),
      bps: Number(row?.bps || 0),
      goals_scored: Number(row?.goals_scored || 0),
      assists: Number(row?.assists || 0),
      clean_sheets: Number(row?.clean_sheets || 0),
      goals_conceded: Number(row?.goals_conceded || 0),
      own_goals: Number(row?.own_goals || 0),
      penalties_saved: Number(row?.penalties_saved || 0),
      penalties_missed: Number(row?.penalties_missed || 0),
      yellow_cards: Number(row?.yellow_cards || 0),
      red_cards: Number(row?.red_cards || 0),
      saves: Number(row?.saves || 0),
      clearances_blocks_interceptions: Number(row?.clearances_blocks_interceptions || 0),
      recoveries: Number(row?.recoveries || 0),
      tackles: Number(row?.tackles || 0),
      defensive_contribution: Number(row?.defensive_contribution || 0)
    };
  }

  function makeFixtureKey(round: number, opponentTeamId: number, wasHome: boolean) {
    return `${round}:${opponentTeamId}:${wasHome ? 'H' : 'A'}`;
  }

  function normalizeBpsRows(rows: any[], teamId: number): BpsEntry[] {
    if (!Array.isArray(rows)) return [];

    const mapped = rows
      .map((row: any) => {
        const playerId = Number(row?.element);
        const value = Number(row?.value);
        const player = playerCache.get(playerId);

        if (!Number.isFinite(playerId) || !Number.isFinite(value)) return null;
        if (player && player.team !== teamId) return null;

        return { name: player?.name || "Unknown", value };
      })
      .filter((row): row is BpsEntry => !!row);

    mapped.sort((a, b) => b.value - a.value);
    return mapped.slice(0, BPS_LIMIT);
  }

  function renderBpsCell(entry?: BpsEntry) {
    if (!entry) {
      return `<span class="bps-empty">‚Äî</span>`;
    }

    return `
      <span class="bps-player">${entry.name}</span>
      <span class="bps-score">${entry.value}</span>
    `;
  }

  function renderFixtureBpsTable(fixture: FixtureInfo | null) {
    const title = `<h3 class="player-modal-section-title">Live BPS</h3>`;

    if (!fixture) {
      return `
        <div class="player-modal-bps-table">
          ${title}
          <div class="bps-table-empty">Fixture data unavailable.</div>
        </div>
      `;
    }

    const stats = (fixture as any).stats;
    const bpsStat = Array.isArray(stats) ? stats.find((s: any) => s?.identifier === "bps") : null;

    if (!bpsStat) {
      const message = fixture.started
        ? "Live BPS updates unavailable."
        : "BPS updates available when the match starts.";

      return `
        <div class="player-modal-bps-table">
          ${title}
          <div class="bps-table-empty">${message}</div>
        </div>
      `;
    }

    const home = normalizeBpsRows(bpsStat.h, fixture.team_h);
    const away = normalizeBpsRows(bpsStat.a, fixture.team_a);

    if (home.length === 0 && away.length === 0) {
      return `
        <div class="player-modal-bps-table">
          ${title}
          <div class="bps-table-empty">No live BPS yet.</div>
        </div>
      `;
    }

    const homeTeam = teamCache.get(fixture.team_h)?.shortName || "Home";
    const awayTeam = teamCache.get(fixture.team_a)?.shortName || "Away";
    const maxRows = Math.max(home.length, away.length);

    let rows = "";
    for (let i = 0; i < maxRows; i++) {
      rows += `
        <tr>
          <td><div class="bps-cell">${renderBpsCell(home[i])}</div></td>
          <td><div class="bps-cell">${renderBpsCell(away[i])}</div></td>
        </tr>
      `;
    }

    return `
      <div class="player-modal-bps-table">
        ${title}
        <div class="bps-table-wrapper">
          <table class="bps-table">
            <thead>
              <tr>
                <th>${homeTeam}</th>
                <th>${awayTeam}</th>
              </tr>
            </thead>
            <tbody>
              ${rows}
            </tbody>
          </table>
        </div>
      </div>
    `;
  }

  async function showPlayerModal(playerId: number) {
    const gw = parseInt(gwFilterSelect.value) || latestGW;

    // Make sure the live caches are populated for this GW
    await ensureLiveCaches(gw);

    const player = playerCache.get(playerId);
    const liveStats = livePointsCache.get(playerId);

    if (!player) {
      playerModalContent.innerHTML = "<p class='status status--error'>Player not found.</p>";
      playerModal.classList.add("is-open");
      return;
    }

    const teamInfo = teamCache.get(player.team);
    const fixtures = getPlayerFixtures(player.team);
    const { started, finished, finishedProvisional } = getTeamGwStatusLocal(player.team, gw);
    const isFinished = finished || finishedProvisional;
    const computed = getPlayerLiveComputedLocal(playerId, player.team, gw);
    const explainByFixtureId = new Map<number, any[]>();
    const historyStatsByKey = new Map<string, LiveStats>();
    try {
      const summaryRes = await fetch(`/api/fpl/element-summary/${playerId}/?v=${Date.now()}`);
      if (summaryRes.ok) {
        const summary = await summaryRes.json();

        const explainRows = Array.isArray(summary.explain) ? summary.explain : [];
        explainRows.forEach((row: any) => {
          explainByFixtureId.set(Number(row.fixture), Array.isArray(row.stats) ? row.stats : []);
        });

        const historyRows = Array.isArray(summary.history) ? summary.history : [];
        historyRows.forEach((row: any) => {
          const key = makeFixtureKey(Number(row.round), Number(row.opponent_team), !!row.was_home);
          historyStatsByKey.set(key, buildStatsFromHistoryRow(row));
        });
      }
    } catch (e) {
      console.warn("Failed to load element-summary explain/history data", e);
    }

    
    const emptyStats: LiveStats = {
      points: 0, bonus: 0, minutes: 0, bps: 0,
      goals_scored: 0, assists: 0, clean_sheets: 0, goals_conceded: 0,
      own_goals: 0, penalties_saved: 0, penalties_missed: 0,
      yellow_cards: 0, red_cards: 0, saves: 0,
      clearances_blocks_interceptions: 0, recoveries: 0, tackles: 0, defensive_contribution: 0
    };

    const projBonus = projectedBonusCache.get(`${gw}:${playerId}`) || 0;
    let html = `
      <div class="player-modal-header">
        <div class="player-modal-info">
          <h2 class="player-modal-name">${player.name}</h2>
          <div class="player-modal-meta">
            <span class="player-modal-team">${teamInfo?.shortName || '???'}</span>
            <span class="player-modal-pos">${positionLabel(player.position)}</span>
          </div>
        </div>
        <div class="player-modal-points">
          <span class="player-modal-total">${computed.liveTotal}</span>
          <span class="player-modal-pts-label">pts</span>
        </div>
      </div>
    `;

    const fixtureBlocks = fixtures.length ? fixtures : [null];

    for (const fx of fixtureBlocks) {
      if (!fx) {
        continue;
      }

      const isHome = fx.team_h === player.team;
      const oppTeamId = isHome ? fx.team_a : fx.team_h;
      const oppTeam = teamCache.get(oppTeamId);
      const opponentStr = isHome ? `vs ${oppTeam?.shortName || '???'}` : `@ ${oppTeam?.shortName || '???'}`;

      const started = !!fx.started;
      const finished = !!fx.finished;
      const finishedProvisional = !!fx.finished_provisional;
      const isFinished = finished || finishedProvisional;

      let scoreStr = "";
      if (started) {
        const homeScore = fx.team_h_score ?? 0;
        const awayScore = fx.team_a_score ?? 0;
        scoreStr = isHome ? `${homeScore} - ${awayScore}` : `${awayScore} - ${homeScore}`;
      }

      const statusText = isFinished ? "Full Time" : (started ? "üî¥ Live" : "Not Started");
      const statusClass = isFinished ? "status-fin" : (started ? "status-live" : "status-ns");

      const explainStatsRows = explainByFixtureId.get(Number(fx.id)) || [];
      const fixtureKey = makeFixtureKey(Number(fx.event), Number(oppTeamId), !!fx.is_home);
      const historyStats = historyStatsByKey.get(fixtureKey);

      const fixtureStats = historyStats
        ? historyStats
        : (explainStatsRows.length ? buildStatsFromExplain(explainStatsRows) : emptyStats);

      const breakdown = buildBreakdownRows(
        fixtureStats,
        player.position,
        isFinished,
        explainStatsRows.length ? 0 : projBonus
      );

      html += `
        <div class="player-modal-match">
          <span class="player-modal-status ${statusClass}">${statusText}</span>
          ${scoreStr ? `<span class="player-modal-score">${scoreStr}</span>` : ''}
          <span class="player-modal-opp">${opponentStr}</span>
        </div>

        <div class="player-modal-breakdown">
          <h3 class="player-modal-section-title">Points Breakdown</h3>
          <div class="breakdown-list">
      `;

      for (const item of breakdown) {
        if (!item.show) continue;

        let pointsClass = item.points > 0 ? 'points-positive' : (item.points < 0 ? 'points-negative' : '');
        let pointsDisplay: string = item.points > 0 ? `+${item.points}` : String(item.points);
        let valueClass = '';

        if (item.isProgress) {
          const achieved = item.points > 0;
          pointsClass = achieved ? 'points-positive' : 'points-pending';
          valueClass = achieved ? 'value-achieved' : 'value-progress';
          if (!achieved) {
            pointsDisplay = '‚Äî';
          }
        }

        html += `
          <div class="breakdown-row ${item.isProgress ? 'breakdown-row--defcon' : ''}">
            <span class="breakdown-label">${item.label}</span>
            <span class="breakdown-value ${valueClass}">${item.value}</span>
            <span class="breakdown-points ${pointsClass}">${pointsDisplay}</span>
          </div>
        `;
      }

      if (!isFinished && !explainStatsRows.length && projBonus > 0) {
        html += `
          <div class="breakdown-row breakdown-row--projected">
            <span class="breakdown-label">Proj. Bonus</span>
            <span class="breakdown-value">‚Äî</span>
            <span class="breakdown-points points-projected">+${projBonus}</span>
          </div>
        `;
      }

      html += `
          </div>
        </div>

        ${renderFixtureBpsTable(fx)}
      `;
    }

    playerModalContent.innerHTML = html;
    const playerNameEl = playerModalContent.querySelector('.player-modal-name');
    if (playerNameEl && gwPointsModal) {
      makePlayerNameClickable(playerNameEl, playerId, player.name, gwPointsModal, teamCache);
    }
    playerModal.classList.add("is-open");
  }


  function getGoalPoints(position: number, goals: number): number {
    if (goals === 0) return 0;
    if (position === 1 || position === 2) return goals * 6;
    if (position === 3) return goals * 5;
    return goals * 4;
  }

  function getCleanSheetPoints(position: number, cleanSheets: number): number {
    if (cleanSheets === 0) return 0;
    if (position === 1 || position === 2) return cleanSheets * 4;
    if (position === 3) return cleanSheets * 1;
    return 0;
  }

  async function showSquadModal(entryId: number, managerName: string, teamName: string, chipPlayed: string, livePoints: number) {
    const gw = parseInt(gwFilterSelect.value) || latestGW;

    squadModalContent.innerHTML = `<p class="text-muted">Loading squad...</p>`;
    squadModal.classList.add("is-open");

    try {
      // Make sure the live caches are populated for this GW
      await ensureLiveCaches(gw);

      const cacheKey = `${entryId}:${gw}`;
      let picksData =
        squadPicksCache.get(cacheKey) || managerDataCache.get(cacheKey)?.picksData;

      if (!picksData) {
        const v = Date.now();
        const picksRes = await fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks?v=${v}`, { cache: "no-store" });

        if (!picksRes.ok) throw new Error("Failed to fetch picks");

        picksData = await picksRes.json();
        squadPicksCache.set(cacheKey, picksData);
      }
      const rawPicks = Array.isArray(picksData.picks) ? picksData.picks : [];

      const chipCode = chipPlayed || "None";

      const picks = rawPicks.map((p: any) => {
        const player = playerCache.get(p.element) || { name: "Unknown", position: 4, team: 0 };
        const teamId = Number(player.team) || 0;
        const teamInfo = teamCache.get(teamId) || { shortName: "???" as string };

        const computed = getPlayerLiveComputedLocal(p.element, teamId, gw);

        return {
          playerId: Number(p.element),
          position: Number(p.position),
          is_captain: !!p.is_captain,
          is_vice_captain: !!p.is_vice_captain,
          web_name: player.name || "Unknown",
          teamShort: teamInfo.shortName,
          playingPosition: positionLabel(player.position),
          minutes: computed.minutes,
          status: computed.status,
          liveTotal: computed.liveTotal
        };
      });

      const finalTeam = applyAutoSubsAndMultipliers(picks, chipCode);

      const sorted = [...finalTeam].sort((a, b) => a.position - b.position);
      const originalStarters = sorted.slice(0, 11);
      const originalBench = sorted.slice(11);

      const chipEmoji = chipPlayed === "WC" ? "üÉè" :
                        chipPlayed === "BB" ? "ü™ë" :
                        chipPlayed === "TC" ? "üëë" :
                        chipPlayed === "FH" ? "üéØ" : "";

      let html = `
        <h2 class="modal-title" style="padding-right:40px;">
          ${managerName}
          ${chipPlayed ? `<span class="badge" style="margin-left:8px;">${chipEmoji} ${chipPlayed}</span>` : ""}
        </h2>
        <p class="text-muted" style="margin-bottom:var(--space-3);">
          ${teamName} ¬∑ GW${gw} ¬∑ <span class="text-success font-bold">${finalTeam.reduce((sum, p) => sum + (p.liveTotal * (p.multiplier || 0)), 0)} pts</span>
        </p>

        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Starting XI</h3>
          <table class="squad-modal-table">
            <thead>
              <tr>
                <th>Player</th>
                <th class="col-team">Team</th>
                <th class="col-pts">Pts</th>
              </tr>
            </thead>
            <tbody>
      `;

      for (const p of originalStarters) {
        const capLabel = p.is_captain ? '<span class="cap-badge cap-c">C</span>' :
                         p.is_vice_captain ? '<span class="cap-badge cap-v">V</span>' : '';

        const isSubbedOut = p.autoSubStatus === 'OUT';
        const isNotStarted = p.status === "NS";
        const isLive = p.status === "Live";
        const isFinished = p.status === "Fin";
        const effMult = p.multiplier ?? 0;
        const displayPts = (isSubbedOut || effMult === 0) ? 0 : Math.round(p.liveTotal * effMult);
        const ptsText = effMult > 1 ? `${p.liveTotal}√ó${effMult}` : String(displayPts);

        let rowClass = "";
        let statusBadge = "";

        if (isSubbedOut) {
          rowClass = "sub-off-row";
          statusBadge = `<span class="status-badge status-dnp">DNP</span>`;
        } else if (isNotStarted) {
          rowClass = "not-started-row";
        } else if (isLive) {
          rowClass = "match-live-row";
        } else if (isFinished) {
          rowClass = "match-finished-row";
        }

        html += `
          <tr class="${rowClass}">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn ${isSubbedOut ? 'player-dnp' : ''}" data-player-id="${p.playerId}">${p.web_name}</button>
              ${capLabel}
              ${statusBadge}
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts ${isSubbedOut ? 'text-muted' : ''}">${ptsText}</td>
          </tr>
        `;
      }

      const subbedInPlayers = originalBench.filter(p => p.autoSubStatus === 'IN');
      for (const p of subbedInPlayers) {
        const mult = p.multiplier || 1;
        const displayPts = Math.round(p.liveTotal * mult);
        const ptsText = mult > 1 ? `${p.liveTotal}√ó${mult}` : String(displayPts);

        html += `
          <tr class="sub-on-row">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn" data-player-id="${p.playerId}">${p.web_name}</button>
              <span class="status-badge status-on">ON</span>
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts">${ptsText}</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>

        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Bench</h3>
          <table class="squad-modal-table bench-table">
            <tbody>
      `;

      for (const p of originalBench) {
        const isSubbedIn = p.autoSubStatus === 'IN';
        const isDnp = p.minutes === 0 && p.status === "Fin";

        if (isSubbedIn) continue;

        const rowClass = chipCode === "BB" ? "" : (isDnp ? "dnp-row" : "bench-inactive");

        let statusBadge = "";
        if (isDnp) statusBadge = `<span class="status-badge status-dnp">DNP</span>`;

        html += `
          <tr class="${rowClass}">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn" data-player-id="${p.playerId}">${p.web_name}</button>
              ${statusBadge}
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts">${
              (p.multiplier || 0) === 0
                ? `<span class="text-muted">${Math.round(p.liveTotal)}</span>`
                : ((p.multiplier || 1) > 1
                    ? `${p.liveTotal}√ó${p.multiplier}`
                    : `${Math.round(p.liveTotal * (p.multiplier || 1))}`)
            }</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>
      `;

      squadModalContent.innerHTML = html;

      squadModalContent.querySelectorAll('.player-name-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const button = e.target as HTMLElement;
          const playerId = parseInt(button.dataset.playerId || '0');
          if (playerId) showPlayerModal(playerId);
        });
      });

    } catch (error) {
      console.error("Error loading squad:", error);
      squadModalContent.innerHTML = "<p class='status status--error'>Error loading squad data.</p>";
    }
  } 


  function populateCompareManager() {
    // Preserve current selection (string)
    const selected = String(compareManagerSelect.value ?? "");

    compareManagerSelect.innerHTML = '<option value="">Leader</option>';

    const sortedManagers = [...liveData].sort((a, b) =>
      a.managerName.localeCompare(b.managerName)
    );

    for (const manager of sortedManagers) {
      const option = document.createElement('option');
      option.value = String(manager.entryId);          // force string match
      option.textContent = manager.managerName;
      compareManagerSelect.appendChild(option);
    }

    // Restore selection if it exists; otherwise fall back to Leader FORCE REDEPLOY
    compareManagerSelect.value = selected;
  }

  function makeLiveTable(managers: any[], compareToId = "") {
    const base = [...managers];

    // Determine compare target (leader or selected manager)
    const leader = [...base].sort((a, b) => b.totalPoints - a.totalPoints)[0];
    const compareManager = compareToId ? base.find(m => m.entryId.toString() === compareToId) : leader;

    // Compute numeric diff (used for display + sorting)
    base.forEach(m => {
      m.diff = m.totalPoints - (compareManager?.totalPoints || 0);
    });

    // Sort AFTER diff exists
    const sorted = sortLiveRows(base);

    let maxGwPoints = -Infinity;
    sorted.forEach(m => {
      if (m.livePoints > maxGwPoints) {
        maxGwPoints = m.livePoints;
      }
    });
    
    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table live-table">
            <thead>
              <tr>
                <th class="rank-col">#</th>
                <th>Manager</th>
                <th class="gw-col sortable-col ${liveSortKey === "livePointsBeforeHits" ? "is-sorted" : ""}" data-sort="livePointsBeforeHits">GW</th>
                <th class="hit-col sortable-col ${liveSortKey === "transferCost" ? "is-sorted" : ""}" data-sort="transferCost">Hit</th>
                <th class="nett-col sortable-col ${liveSortKey === "livePoints" ? "is-sorted" : ""}" data-sort="livePoints">Nett</th>
                <th class="total-col sortable-col ${liveSortKey === "totalPoints" ? "is-sorted" : ""}" data-sort="totalPoints">Total</th>
                <th class="diff-col sortable-col ${liveSortKey === "diff" ? "is-sorted" : ""}" data-sort="diff">Diff</th>
              </tr>
            </thead>
            <tbody>
    `;

    let rank = 1;
    for (const m of sorted) {
      const diffOverall = m.diff;
      const diffText = diffOverall > 0 ? `+${diffOverall}` : diffOverall === 0 ? "‚Äî" : `${diffOverall}`;

      const isTopScorer = m.livePoints === maxGwPoints;
      const rowClass = isTopScorer ? 'top-scorer-row' : '';
      const hitClass = m.transferCost > 0 ? 'hit-highlight' : '';

      html += `
        <tr class="${rowClass}">
          <td class="rank-col">${rank}</td>
          <td class="manager-col">
            <button type="button" class="manager-btn" 
              data-entry-id="${m.entryId}"
              data-manager-name="${m.managerName}"
              data-team-name="${m.teamName}"
              data-chip="${m.chipPlayed}"
              data-live-points="${m.livePoints}"
            >${m.managerName}</button>
            ${m.chipPlayed ? `<span class="badge" style="margin-left:4px;font-size:10px;padding:1px 4px;">${m.chipPlayed}</span>` : ""}
          </td>
          <td class="gw-col">${m.livePointsBeforeHits}</td>
          <td class="hit-col ${hitClass}">${m.transferCost}</td>
          <td class="nett-col">${m.livePoints}</td>
          <td class="total-col">${m.totalPoints.toLocaleString()}</td>
          <td class="diff-col">${diffText}</td>
        </tr>
      `;
      rank++;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;
    return html;
  }

  function attachManagerButtons() {
    document.querySelectorAll('.manager-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = (e.target as HTMLElement).closest('.manager-btn') as HTMLElement;
        const entryId = parseInt(button.dataset.entryId || '0');
        const managerName = button.dataset.managerName || '';
        const teamName = button.dataset.teamName || '';
        const chipPlayed = button.dataset.chip || '';
        const livePoints = parseInt(button.dataset.livePoints || '0');
        showSquadModal(entryId, managerName, teamName, chipPlayed, livePoints);
      });
    });
  }

  async function loadLive(ids: number[], gw: number, opts?: { force?: boolean; background?: boolean }) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    if (!gw) {
      out.innerHTML = "<p class='status status--warning'>Please select a gameweek.</p>";
      return;
    }

    const force = !!opts?.force;
    const background = !!opts?.background;

    // Throttle background refreshes (e.g., fast tab switching / multiple events)
    if (background) {
      const now = Date.now();
      if (now - lastBackgroundRefreshAt < LIVE_REFRESH_THROTTLE_MS) {
        return;
      }
      lastBackgroundRefreshAt = now;
    }

    const loadToken = ++currentLoadToken;

    // Only show "loading" UI when this is a foreground load
    if (!background) {
      refreshBtn.disabled = true;
      loadingStatus.textContent = `Fetching latest data...`;
      out.innerHTML = "";
      liveData = [];
    } else {
      loadingStatus.textContent = `Refreshing in background...`;
    }

    fixturesCache = [];
    livePointsCache.clear();
    projectedBonusCache.clear();
    teamStatusCache.clear();

    // Important: only bust caches if forced (manual refresh) or when background-refreshing stale snapshot
    const cacheBuster = force ? Date.now().toString() : undefined;

    try {
      await Promise.all([
        fetchFixtures({
          gw,
          fixturesCache,
          projectedBonusCache,
          teamStatusCache,
          includeFinishedProvisional: true,
          cacheBuster
        }),
        fetchLiveGW({
          gw,
          livePointsCache,
          includeExtendedStats: true,
          cacheBuster
        })
      ]);
    } catch (e) {
      console.error('Error fetching fixtures/live data:', e);
      if (!background) {
        loadingStatus.innerHTML = `<span class='status status--error'>Error loading fixtures/live data</span>`;
        refreshBtn.disabled = false;
      } else {
        loadingStatus.innerHTML = `<span class='status status--error'>Background refresh failed</span>`;
      }
      return;
    }

    if (loadToken !== currentLoadToken) return;

    const managerDataResults = await mapWithConcurrency(
      ids,
      DEFAULT_FETCH_CONCURRENCY,
      async (id) => await fetchManagerLive(id, gw, cacheBuster),
      (completed, total) => {
        if (!background) {
          loadingStatus.textContent = `Fetching ${completed}/${total}...`;
        }
      }
    );

    if (loadToken !== currentLoadToken) return;

    liveData = managerDataResults.filter((data): data is NonNullable<typeof data> => data !== null);

    if (liveData.length > 0) {
      renderLiveFromState();
    }

    // Save snapshot after a successful load
    saveLiveSnapshot({
      ts: Date.now(),
      gw,
      compareToId: compareManagerSelect.value,
      liveSortKey: "livePointsBeforeHits",
      liveSortDir: "desc",
      managerIds: [...ids],
      data: liveData,
      latestGW
    });

    loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${liveData.length} managers</span>`;
    lastUpdatedEl.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
    if (!background) refreshBtn.disabled = false;
  }

  async function init() {
    loadingStatus.textContent = "Loading player data...";
    await fetchBootstrapData();

    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (!authenticated) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    const gw = parseInt(gwFilterSelect.value) || latestGW;

    // 1) Try restore snapshot for instant render (per GW)
    const snap = loadLiveSnapshot(gw);
    if (isSnapshotUsable(snap, gw, managerIds)) {
      liveData = snap!.data;
      latestGW = snap!.latestGW || latestGW;

      // Restore UI state
      if (typeof snap!.compareToId === 'string') {
        compareManagerSelect.value = String(snap!.compareToId ?? "");
      }

      // Always default to GW desc when rendering from cache
      forceDefaultLiveSort();

      renderLiveFromState();

      lastUpdatedEl.textContent = `Updated: ${new Date(snap!.ts).toLocaleTimeString()}`;

      // Cached-until-refresh: never auto-refresh
      loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${liveData.length} managers (cached)</span>`;
      return;

    }

    // No snapshot (or unusable) -> normal foreground load
    loadLive(managerIds, gw, { force: false, background: false });
  }

  // ==============================
  // UI event wiring (GW / Compare / Refresh)
  // ==============================
  gwFilterSelect.addEventListener('change', async () => {
    const gw = parseInt(gwFilterSelect.value);
    if (gw && gw >= 1 && gw <= 38) {
      const snap = loadLiveSnapshot(gw);


      if (isSnapshotUsable(snap, gw, managerIds)) {
        liveData = snap!.data;
        latestGW = snap!.latestGW || latestGW;

        if (typeof snap!.compareToId === 'string') {
          compareManagerSelect.value = String(snap!.compareToId ?? "");
        }
        
        // Always default to GW desc when rendering from cache
        forceDefaultLiveSort();

        renderLiveFromState();
        lastUpdatedEl.textContent = `Updated: ${new Date(snap!.ts).toLocaleTimeString()}`;

        // Cached-until-refresh: never auto-refresh
        loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${liveData.length} managers (cached)</span>`;
        return;

      }

      loadLive(managerIds, gw, { force: false, background: false });
    }
  });

  compareManagerSelect.addEventListener('change', () => {
    renderLiveFromState();
  });

  refreshBtn.addEventListener('click', async () => {
    // Requirement: after forced refresh, default sort must be GW desc
    forceDefaultLiveSort();

    managerDataCache.clear();
    squadPicksCache.clear();
    // Clear ALL per-GW snapshots
    for (let i = localStorage.length - 1; i >= 0; i--) {
      const k = localStorage.key(i);
      if (k && k.startsWith(LIVE_SNAPSHOT_KEY_PREFIX)) {
        localStorage.removeItem(k);
      }
    }

    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    const gw = parseInt(gwFilterSelect.value) || latestGW;
    loadLive(managerIds, gw, { force: true, background: false });
  });

  init();

</script>

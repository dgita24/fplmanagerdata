---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="Live League Standings - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">üî¥ Live Standings</h1>
      <p class="page-subtitle">Real-time league table with live points, projected bonus & auto subs.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">‚öô Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="compare-manager">Compare to</label>
        <select class="select-small" id="compare-manager">
          <option value="">Leader</option>
        </select>
      </div>
    </div>

    <div class="buttons-row">
      <button id="refresh-btn" class="btn-row" type="button">üîÑ Refresh</button>
    </div>

    <div id="loading-status" class="meta-row"></div>
    <div id="last-updated" class="meta-row"></div>
    <section id="live-output" aria-live="polite"></section>
  </main>

  <!-- Squad Modal -->
  <div id="squad-modal" class="modal">
    <div class="modal-panel">
      <button id="close-squad-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="squad-modal-content"></div>
    </div>
  </div>

  <!-- Player Stats Modal -->
  <div id="player-modal" class="modal modal--nested">
    <div class="modal-panel modal-panel--compact">
      <button id="close-player-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="player-modal-content"></div>
    </div>
  </div>

  <!-- GW Points Modal (nested on top of player modal) -->
  <div id="gw-points-modal" class="modal modal--nested modal--gw-points">
    <div class="modal-panel modal-panel--gw-points">
      <button class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div class="gw-points-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 32px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .buttons-row {
    display: flex;
    gap: var(--space-2);
  }

  .btn-row {
    flex: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
  }

  .btn-row:hover {
    background: var(--color-primary-hover);
  }

  .btn-row--neutral {
    background: var(--color-surface);
    color: var(--color-text);
    border: 1px solid var(--color-border);
  }

  .btn-row--neutral:hover {
    background: var(--color-surface-alt);
  }

  .btn-row--success {
    background: var(--color-success);
    color: white;
  }

  .btn-row--success:hover {
    background: var(--color-success-hover);
  }

  /* GW Points Modal Styles */
  .modal--gw-points {
    z-index: 10002; /* Higher than nested player modal */
  }

  .modal-panel--gw-points {
    max-width: 900px;
    max-height: 85vh;
    overflow-y: auto;
  }

  .gw-points-title {
    font-size: 18px;
    font-weight: 700;
    color: var(--color-text);
    margin-bottom: var(--space-4);
    text-align: center;
  }

  .gw-points-tables {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-4);
  }

  @media (max-width: 768px) {
    .gw-points-tables {
      grid-template-columns: 1fr;
    }
  }

  .gw-points-table {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
  }

  .gw-points-table thead {
    background: var(--color-surface-alt);
  }

  .gw-points-table th {
    padding: var(--space-2);
    text-align: left;
    font-weight: 600;
    color: var(--color-text-secondary);
    border-bottom: 2px solid var(--color-border);
  }

  .gw-points-table td {
    padding: var(--space-2);
    border-bottom: 1px solid var(--color-border);
  }

  .gw-points-table tbody tr:hover {
    background: var(--color-surface-alt);
  }

  .gw-col {
    font-weight: 600;
    width: 50px;
  }

  .opp-col {
    width: auto;
  }

  .mins-col {
    width: 60px;
    text-align: center;
  }

  .pts-col {
    width: 60px;
    text-align: right;
    font-weight: 600;
  }

  .gw-points-loading,
  .gw-points-error,
  .gw-points-empty {
    text-align: center;
    padding: var(--space-6);
  }

  .gw-points-loading-text {
    color: var(--color-text-secondary);
    margin-top: var(--space-2);
  }

  .gw-points-error-text {
    color: var(--color-danger);
    margin-top: var(--space-2);
  }

  .gw-points-error-details {
    color: var(--color-text-secondary);
    font-size: 12px;
    margin-top: var(--space-1);
  }

  .gw-points-empty-text {
    color: var(--color-text-secondary);
    margin-top: var(--space-2);
  }
</style>

<script>
  import { supabase } from '../lib/supabase.ts'
  import { applyAutoSubsAndMultipliers, fetchFixtures, fetchLiveGW, getPlayerLiveComputed, getTeamGwStatus, type FixtureInfo, type LiveStatLine, type TeamStatus } from '../lib/fplLive.ts'

  let managerIds: number[] = []
  const managerDataCache = new Map<string, any>();

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("live-output")!;
  const gwFilterSelect = document.getElementById("gw-filter") as HTMLSelectElement;
  const compareManagerSelect = document.getElementById("compare-manager") as HTMLSelectElement;
  const loadingStatus = document.getElementById("loading-status")!;
  const lastUpdatedEl = document.getElementById("last-updated")!;
  const managerCountEl = document.getElementById("manager-count")!;
  const refreshBtn = document.getElementById("refresh-btn")!;
  const squadModal = document.getElementById("squad-modal")!;
  const squadModalContent = document.getElementById("squad-modal-content")!;
  const closeSquadModal = document.getElementById("close-squad-modal")!;
  const playerModal = document.getElementById("player-modal")!;
  const playerModalContent = document.getElementById("player-modal-content")!;
  const closePlayerModal = document.getElementById("close-player-modal")!;

  interface PlayerInfo {
    name: string;
    position: number;
    team: number;
  }

  interface TeamInfo {
    name: string;
    shortName: string;
  }

  interface LiveStats extends LiveStatLine {
    bps: number;
    goals_scored: number;
    assists: number;
    clean_sheets: number;
    goals_conceded: number;
    own_goals: number;
    penalties_saved: number;
    penalties_missed: number;
    yellow_cards: number;
    red_cards: number;
    saves: number;
    clearances_blocks_interceptions: number;
    recoveries: number;
    tackles: number;
    defensive_contribution: number;
  }

  let liveData: any[] = [];
  let latestGW: number = 1;
  let playerCache = new Map<number, PlayerInfo>();
  let teamCache = new Map<number, TeamInfo>();
  let livePointsCache = new Map<number, LiveStats>();
  let projectedBonusCache = new Map<string, number>();
  let teamStatusCache = new Map<string, TeamStatus>();
  let fixturesCache: FixtureInfo[] = [];
  
  // Load token for cancellation
  let currentLoadToken = 0;

  closeSquadModal.addEventListener("click", () => {
    squadModal.classList.remove("is-open");
  });

  closePlayerModal.addEventListener("click", () => {
    playerModal.classList.remove("is-open");
  });

  // Import and initialize GW Points Modal
  import { initGWPointsModal } from '../lib/gwPointsModal.js';
  const gwPointsModal = initGWPointsModal('gw-points-modal');

  function populateGWSelector(currentGW: number) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = String(i);
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  function positionLabel(elementType: number): string {
    if (elementType === 1) return "GK";
    if (elementType === 2) return "DEF";
    if (elementType === 3) return "MID";
    return "FWD";
  }

  function getTeamGwStatusLocal(teamId: number, gw: number) {
    return getTeamGwStatus(teamStatusCache, teamId, gw);
  }

  function getPlayerLiveComputedLocal(playerId: number, teamId: number, gw: number) {
    return getPlayerLiveComputed({
      playerId,
      teamId,
      gw,
      livePointsCache,
      projectedBonusCache,
      teamStatusCache,
      bonusConfirmedOnProvisional: false
    });
  }

  /**
   * Concurrent mapping with limited concurrency
   */
  async function mapWithConcurrency<T, R>(
    items: T[],
    limit: number,
    fn: (item: T, index: number) => Promise<R | null>,
    onProgress?: (completed: number, total: number) => void
  ): Promise<(R | null)[]> {
    const results: (R | null)[] = [];
    let currentIndex = 0;
    let completed = 0;

    async function worker() {
      while (currentIndex < items.length) {
        const index = currentIndex++;
        const item = items[index];
        try {
          results[index] = await fn(item, index);
        } catch (e) {
          console.error(`Error processing item ${index}:`, e);
          results[index] = null;
        }
        completed++;
        if (onProgress) {
          onProgress(completed, items.length);
        }
      }
    }

    const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
    await Promise.all(workers);
    return results;
  }

  async function fetchBootstrapData(cacheBuster?: string) {
    try {
      // Use provided cache-buster or generate new one
      const v = cacheBuster || Date.now().toString();
      const res = await fetch(`/api/fpl/bootstrap-static?v=${v}`);
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      data.elements.forEach((player: any) => {
        playerCache.set(player.id, {
          name: player.web_name,
          position: player.element_type,
          team: player.team
        });
      });

      data.teams.forEach((team: any) => {
        teamCache.set(team.id, {
          name: team.name,
          shortName: team.short_name
        });
      });

      const activeEvent = data.events.filter((e: any) => new Date(e.deadline_time) < new Date()).pop();
      latestGW = activeEvent ? activeEvent.id : 1;

      populateGWSelector(latestGW);

      return data;
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
      return null;
    }
  }

  async function fetchManagerLive(entryId: number, gw: number, cacheBuster?: string) {
    try {
      const cacheKey = `${entryId}:${gw}`;
      let rawData = managerDataCache.get(cacheKey);

      // Version timestamp to bust API cache - use provided or generate new
      const v = cacheBuster || Date.now().toString();

      if (!rawData) {
         const [picksRes, summaryRes, historyRes] = await Promise.all([
          fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks?v=${v}`),
          fetch(`/api/fpl/entry/${entryId}?v=${v}`),
          fetch(`/api/fpl/entry/${entryId}/history?v=${v}`)
        ]);

        if (!picksRes.ok || !summaryRes.ok || !historyRes.ok) {
          throw new Error("Failed to fetch manager data");
        }

        const picksData = await picksRes.json();
        const summaryData = await summaryRes.json();
        const historyData = await historyRes.json();
        
        rawData = { picksData, summaryData, historyData };
        managerDataCache.set(cacheKey, rawData);
      }

      const { picksData, summaryData, historyData } = rawData;

      const chipName = (historyData.chips || []).find((c: any) => c.event === gw)?.name || "";
      const chipCode =
        chipName === "bboost" ? "BB" :
        chipName === "3xc" ? "TC" :
        chipName === "wildcard" ? "WC" :
        chipName === "freehit" ? "FH" :
        "None";

      const rawPicks = Array.isArray(picksData.picks) ? picksData.picks : [];

      const picks = rawPicks.map((p: any) => {
        const player = playerCache.get(p.element) || { name: "", position: 4, team: 0 };
        const teamId = Number(player.team) || 0;

        const computed = getPlayerLiveComputedLocal(p.element, teamId, gw);

        return {
          playerId: Number(p.element),
          position: Number(p.position),
          is_captain: !!p.is_captain,
          is_vice_captain: !!p.is_vice_captain,

          web_name: player.name || "",
          teamId,
          playingPosition: positionLabel(player.position),

          minutes: computed.minutes,
          status: computed.status,
          lockedPoints: computed.locked,
          projBonus: computed.projBonus,
          liveTotal: computed.liveTotal
        };
      });

      const finalTeam = applyAutoSubsAndMultipliers(picks, chipCode);

      // GROSS live points (sum of players, hit NOT subtracted)
      const livePointsBeforeHits = finalTeam.reduce((sum, p) => sum + (p.liveTotal * (p.multiplier || 0)), 0);

      const historyRows = Array.isArray(historyData.current) ? historyData.current : [];
      const transferCost =
        Number(historyRows.find((h: any) => Number(h.event) === Number(gw))?.event_transfers_cost) || 0;

      // Nett = GW Points (Gross) - Hit
      const liveNet = livePointsBeforeHits - transferCost;

      // === TOTAL POINTS CALCULATION (CRITICAL FIX) ===
      // summary_overall_points: Official Total from API (Includes hit deduction already)
      // summary_event_points: Official Event Points from API (Includes hit deduction already)
      
      const officialOverall = Number(summaryData.summary_overall_points) || 0;
      const officialEvent = Number(summaryData.summary_event_points) || 0;
      
      // We calculate Live Total Points by starting with Official Total, subtracting Official Event (Net),
      // and adding our calculated Live Gross points. This removes the "double deduction" of hits.
      // Math: (Start Total) + Live Gross.
      // Since Start Total = Official Overall - Official Event (Net, which includes hits),
      // And Live Gross doesn't have hits, we end up with a Total that effectively ignores the hit visually until next GW.
      const liveOverall = officialOverall - officialEvent + livePointsBeforeHits;

      return {
        entryId,
        managerName: `${summaryData.player_first_name || ""} ${summaryData.player_last_name || ""}`.trim(),
        teamName: summaryData.name || "",
        chipPlayed: chipCode === "None" ? "" : chipCode,
        transferCost,
        livePointsBeforeHits, // Gross points for GW column
        livePoints: liveNet,  // Net points for Nett column
        totalPoints: liveOverall // Corrected Total Points
      };
    } catch (e) {
      console.error(`Error fetching live data for manager ${entryId}:`, e);
      return null;
    }
  }

  function getPlayerFixture(teamId: number): FixtureInfo | null {
    return fixturesCache.find(f => f.team_h === teamId || f.team_a === teamId) || null;
  }

  function calculateDefcon(position: number, defensiveContribution: number): { points: number; threshold: number } {
    if (position === 1) return { points: 0, threshold: 0 };
    const threshold = position === 2 ? 10 : 12;
    const points = defensiveContribution >= threshold ? 2 : 0;
    return { points, threshold };
  }

  function showPlayerModal(playerId: number) {
    const gw = parseInt(gwFilterSelect.value) || latestGW;
    const player = playerCache.get(playerId);
    const liveStats = livePointsCache.get(playerId);

    if (!player) {
      playerModalContent.innerHTML = "<p class='status status--error'>Player not found.</p>";
      playerModal.classList.add("is-open");
      return;
    }

    const teamInfo = teamCache.get(player.team);
    const fixture = getPlayerFixture(player.team);
    const { started, finished, finishedProvisional } = getTeamGwStatusLocal(player.team, gw);
    const isFinished = finished || finishedProvisional;
    const computed = getPlayerLiveComputedLocal(playerId, player.team, gw);

    let opponentStr = "";
    let scoreStr = "";
    if (fixture) {
      const isHome = fixture.team_h === player.team;
      const oppTeamId = isHome ? fixture.team_a : fixture.team_h;
      const oppTeam = teamCache.get(oppTeamId);
      opponentStr = isHome ? `vs ${oppTeam?.shortName || '???'}` : `@ ${oppTeam?.shortName || '???'}`;
      
      if (fixture.started) {
        const homeScore = fixture.team_h_score ?? 0;
        const awayScore = fixture.team_a_score ?? 0;
        scoreStr = isHome ? `${homeScore} - ${awayScore}` : `${awayScore} - ${homeScore}`;
      }
    }

    const statusText = isFinished ? "Full Time" : (started ? "üî¥ Live" : "Not Started");
    const statusClass = isFinished ? "status-fin" : (started ? "status-live" : "status-ns");

    const stats = liveStats || {
      points: 0, bonus: 0, minutes: 0, bps: 0,
      goals_scored: 0, assists: 0, clean_sheets: 0, goals_conceded: 0,
      own_goals: 0, penalties_saved: 0, penalties_missed: 0,
      yellow_cards: 0, red_cards: 0, saves: 0,
      clearances_blocks_interceptions: 0, recoveries: 0, tackles: 0, defensive_contribution: 0
    };

    const projBonus = projectedBonusCache.get(`${gw}:${playerId}`) || 0;
    const isGK = player.position === 1;
    const isDef = player.position === 2;

    const defcon = calculateDefcon(player.position, stats.defensive_contribution);

    const breakdown: { label: string; value: string | number; points: number; show: boolean; isProgress?: boolean }[] = [
      { label: "Minutes", value: stats.minutes, points: stats.minutes >= 60 ? 2 : (stats.minutes > 0 ? 1 : 0), show: true },
      { label: "Goals", value: stats.goals_scored, points: getGoalPoints(player.position, stats.goals_scored), show: stats.goals_scored > 0 },
      { label: "Assists", value: stats.assists, points: stats.assists * 3, show: stats.assists > 0 },
      { label: "Clean Sheet", value: stats.clean_sheets, points: getCleanSheetPoints(player.position, stats.clean_sheets), show: stats.clean_sheets > 0 && getCleanSheetPoints(player.position, stats.clean_sheets) > 0 },
      { label: "Goals Conceded", value: stats.goals_conceded, points: (isGK || isDef) ? -Math.floor(stats.goals_conceded / 2) : 0, show: (isGK || isDef) && stats.goals_conceded >= 2 },
      { label: "Saves", value: stats.saves, points: Math.floor(stats.saves / 3), show: isGK && stats.saves > 0 },
      { label: "Pen Saved", value: stats.penalties_saved, points: stats.penalties_saved * 5, show: stats.penalties_saved > 0 },
      { label: "Pen Missed", value: stats.penalties_missed, points: stats.penalties_missed * -2, show: stats.penalties_missed > 0 },
      { label: "Own Goals", value: stats.own_goals, points: stats.own_goals * -2, show: stats.own_goals > 0 },
      { label: "Yellow Card", value: stats.yellow_cards, points: stats.yellow_cards * -1, show: stats.yellow_cards > 0 },
      { label: "Red Card", value: stats.red_cards, points: stats.red_cards * -3, show: stats.red_cards > 0 },
      { label: "Bonus", value: stats.bonus || projBonus, points: stats.bonus || projBonus, show: (stats.bonus > 0) || (projBonus > 0 && isFinished) },
      { 
        label: "DEFCON", 
        value: `${stats.defensive_contribution}/${defcon.threshold}`, 
        points: defcon.points, 
        show: !isGK && stats.minutes > 0,
        isProgress: true
      }
    ];

    let html = `
      <div class="player-modal-header">
        <div class="player-modal-info">
          <h2 class="player-modal-name">${player.name}</h2>
          <div class="player-modal-meta">
            <span class="player-modal-team">${teamInfo?.shortName || '???'}</span>
            <span class="player-modal-pos">${positionLabel(player.position)}</span>
            ${opponentStr ? `<span class="player-modal-opp">${opponentStr}</span>` : ''}
          </div>
        </div>
        <div class="player-modal-points">
          <span class="player-modal-total">${computed.liveTotal}</span>
          <span class="player-modal-pts-label">pts</span>
        </div>
      </div>

      <div class="player-modal-match">
        <span class="player-modal-status ${statusClass}">${statusText}</span>
        ${scoreStr ? `<span class="player-modal-score">${scoreStr}</span>` : ''}
      </div>

      <div class="player-modal-breakdown">
        <h3 class="player-modal-section-title">Points Breakdown</h3>
        <div class="breakdown-list">
    `;

    for (const item of breakdown) {
      if (!item.show) continue;
      
      let pointsClass = item.points > 0 ? 'points-positive' : (item.points < 0 ? 'points-negative' : '');
      let pointsDisplay: string = item.points > 0 ? `+${item.points}` : String(item.points);
      let valueClass = '';
      
      if (item.isProgress) {
        const achieved = item.points > 0;
        pointsClass = achieved ? 'points-positive' : 'points-pending';
        valueClass = achieved ? 'value-achieved' : 'value-progress';
        if (!achieved) {
          pointsDisplay = '‚Äî';
        }
      }

      html += `
        <div class="breakdown-row ${item.isProgress ? 'breakdown-row--defcon' : ''}">
          <span class="breakdown-label">${item.label}</span>
          <span class="breakdown-value ${valueClass}">${item.value}</span>
          <span class="breakdown-points ${pointsClass}">${pointsDisplay}</span>
        </div>
      `;
    }

    if (!isFinished && projBonus > 0) {
      html += `
        <div class="breakdown-row breakdown-row--projected">
          <span class="breakdown-label">Proj. Bonus</span>
          <span class="breakdown-value">‚Äî</span>
          <span class="breakdown-points points-projected">+${projBonus}</span>
        </div>
      `;
    }

    html += `
        </div>
      </div>

      <div class="player-modal-bps">
        <span class="bps-label">BPS</span>
        <span class="bps-value">${stats.bps}</span>
      </div>
    `;

    playerModalContent.innerHTML = html;
    
    // Make player name clickable to show GW points
    const playerNameEl = playerModalContent.querySelector('.player-modal-name');
    if (playerNameEl && gwPointsModal) {
      import { makePlayerNameClickable } from '../lib/gwPointsModal.js';
      makePlayerNameClickable(playerNameEl, playerId, player.name, gwPointsModal, teamCache);
    }
    playerModal.classList.add("is-open");
  }

  function getGoalPoints(position: number, goals: number): number {
    if (goals === 0) return 0;
    if (position === 1 || position === 2) return goals * 6;
    if (position === 3) return goals * 5;
    return goals * 4;
  }

  function getCleanSheetPoints(position: number, cleanSheets: number): number {
    if (cleanSheets === 0) return 0;
    if (position === 1 || position === 2) return cleanSheets * 4;
    if (position === 3) return cleanSheets * 1;
    return 0;
  }

  
  async function showSquadModal(entryId: number, managerName: string, teamName: string, chipPlayed: string, livePoints: number) {
    const gw = parseInt(gwFilterSelect.value) || latestGW;

    squadModalContent.innerHTML = `<p class="text-muted">Loading squad...</p>`;
    squadModal.classList.add("is-open");

    try {
      const v = Date.now();
      const picksRes = await fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks?v=${v}`);
      if (!picksRes.ok) throw new Error("Failed to fetch picks");

      const picksData = await picksRes.json();
      const rawPicks = Array.isArray(picksData.picks) ? picksData.picks : [];

      const chipCode = chipPlayed || "None";

      const picks = rawPicks.map((p: any) => {
        const player = playerCache.get(p.element) || { name: "Unknown", position: 4, team: 0 };
        const teamId = Number(player.team) || 0;
        const teamInfo = teamCache.get(teamId) || { shortName: "???" };

        const computed = getPlayerLiveComputedLocal(p.element, teamId, gw);

        return {
          playerId: Number(p.element),
          position: Number(p.position),
          is_captain: !!p.is_captain,
          is_vice_captain: !!p.is_vice_captain,
          web_name: player.name || "Unknown",
          teamShort: teamInfo.shortName,
          playingPosition: positionLabel(player.position),
          minutes: computed.minutes,
          status: computed.status,
          liveTotal: computed.liveTotal
        };
      });

      const finalTeam = applyAutoSubsAndMultipliers(picks, chipCode);
    
      // Keep original positions for display
      const sorted = [...finalTeam].sort((a, b) => a.position - b.position);
      const originalStarters = sorted.slice(0, 11);
      const originalBench = sorted.slice(11);

      const chipEmoji = chipPlayed === "WC" ? "üÉè" : 
                        chipPlayed === "BB" ? "ü™ë" : 
                        chipPlayed === "TC" ? "üëë" : 
                        chipPlayed === "FH" ? "üéØ" : "";

      let html = `
        <h2 class="modal-title" style="padding-right:40px;">
          ${managerName}
          ${chipPlayed ? `<span class="badge" style="margin-left:8px;">${chipEmoji} ${chipPlayed}</span>` : ""}
        </h2>
        <p class="text-muted" style="margin-bottom:var(--space-3);">
          ${teamName} ¬∑ GW${gw} ¬∑ <span class="text-success font-bold">${finalTeam.reduce((sum, p) => sum + (p.liveTotal * (p.multiplier || 0)), 0)} pts</span>
        </p>

        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Starting XI</h3>
          <table class="squad-modal-table">
            <thead>
              <tr>
                <th>Player</th>
                <th class="col-team">Team</th>
                <th class="col-pts">Pts</th>
              </tr>
            </thead>
            <tbody>
      `;

      for (const p of originalStarters) {
        const capLabel = p.is_captain ? '<span class="cap-badge cap-c">C</span>' : 
                         p.is_vice_captain ? '<span class="cap-badge cap-v">V</span>' : '';
      
        const mult = p.multiplier || 0;
        const isSubbedOut = p.autoSubStatus === 'OUT';
        const isNotStarted = p.status === "NS";
        const isLive = p.status === "Live";
        const isFinished = p.status === "Fin";
        const effMult = p.multiplier ?? 0;
        const displayPts = (isSubbedOut || effMult === 0) ? 0 : Math.round(p.liveTotal * effMult);
        const ptsText = effMult > 1 ? `${p.liveTotal}√ó${effMult}` : String(displayPts);

        let rowClass = "";
        let statusBadge = "";
      
        if (isSubbedOut) {
          rowClass = "sub-off-row";
          statusBadge = `<span class="status-badge status-dnp">DNP</span>`;
        } else if (isNotStarted) {
          rowClass = "not-started-row";
        } else if (isLive) {
          rowClass = "match-live-row";
        } else if (isFinished) {
          rowClass = "match-finished-row";
        }   
   
        html += `
          <tr class="${rowClass}">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn ${isSubbedOut ? 'player-dnp' : ''}" data-player-id="${p.playerId}">${p.web_name}</button>
              ${capLabel}
              ${statusBadge}
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts ${isSubbedOut ? 'text-muted' : ''}">${ptsText}</td>
          </tr>
        `;
      }

      // Show auto-subs who came on (from bench)
      const subbedInPlayers = originalBench.filter(p => p.autoSubStatus === 'IN');
      for (const p of subbedInPlayers) {
        const mult = p.multiplier || 1;
        const displayPts = Math.round(p.liveTotal * mult);
        const ptsText = mult > 1 ? `${p.liveTotal}√ó${mult}` : String(displayPts);

        html += `
          <tr class="sub-on-row">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn" data-player-id="${p.playerId}">${p.web_name}</button>
              <span class="status-badge status-on">ON</span>
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts">${ptsText}</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>

        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Bench</h3>
          <table class="squad-modal-table bench-table">
            <tbody>
    `  ;

      for (const p of originalBench) {
        const isSubbedIn = p.autoSubStatus === 'IN';
        const isDnp = p.minutes === 0 && p.status === "Fin";
      
        if (isSubbedIn) continue;
      
        const rowClass = chipCode === "BB" ? "" : (isDnp ? "dnp-row" : "bench-inactive");

        let statusBadge = "";
        if (isDnp) statusBadge = `<span class="status-badge status-dnp">DNP</span>`;

        html += `
          <tr class="${rowClass}">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn" data-player-id="${p.playerId}">${p.web_name}</button>
              ${statusBadge}
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts">${
              (p.multiplier || 0) === 0
                ? `<span class="text-muted">0</span>`
                : ((p.multiplier || 1) > 1
                    ? `${p.liveTotal}√ó${p.multiplier}`
                    : `${Math.round(p.liveTotal * (p.multiplier || 1))}`)
            }</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>
      `;

      squadModalContent.innerHTML = html;

      squadModalContent.querySelectorAll('.player-name-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const button = e.target as HTMLElement;
          const playerId = parseInt(button.dataset.playerId || '0');
          if (playerId) showPlayerModal(playerId);
        });
      });

    } catch (error) {
      console.error("Error loading squad:", error);
      squadModalContent.innerHTML = "<p class='status status--error'>Error loading squad data.</p>";
    }
  }

  function populateCompareManager() {
    compareManagerSelect.innerHTML = '<option value="">Leader</option>';

    const sortedManagers = [...liveData].sort((a, b) =>
      a.managerName.localeCompare(b.managerName)
    );

    for (const manager of sortedManagers) {
      const option = document.createElement('option');
      option.value = manager.entryId;
      option.textContent = manager.managerName;
      compareManagerSelect.appendChild(option);
    }
  }

  function makeLiveTable(managers: any[], compareToId = "") {
    const sorted = [...managers].sort((a, b) => b.totalPoints - a.totalPoints);

    const leader = sorted[0];
    const compareManager = compareToId ? sorted.find(m => m.entryId.toString() === compareToId) : leader;

    let maxGwPoints = -Infinity;
    sorted.forEach(m => {
      if (m.livePoints > maxGwPoints) {
        maxGwPoints = m.livePoints;
      }
    });

    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table live-table">
            <thead>
              <tr>
                <th class="rank-col">#</th>
                <th>Manager</th>
                <th class="gw-col">GW</th>
                <th class="hit-col">Hit</th>
                <th class="nett-col">Nett</th>
                <th class="total-col">Total</th>
                <th class="diff-col">Diff</th>
              </tr>
            </thead>
            <tbody>
    `;

    let rank = 1;
    for (const m of sorted) {
      const diffOverall = m.totalPoints - (compareManager?.totalPoints || 0);
      const diffText = diffOverall > 0 ? `+${diffOverall}` : diffOverall === 0 ? "‚Äî" : `${diffOverall}`;

      const isTopScorer = m.livePoints === maxGwPoints;
      const rowClass = isTopScorer ? 'top-scorer-row' : '';
      const hitClass = m.transferCost > 0 ? 'hit-highlight' : '';

      html += `
        <tr class="${rowClass}">
          <td class="rank-col">${rank}</td>
          <td class="manager-col">
            <button type="button" class="manager-btn" 
              data-entry-id="${m.entryId}"
              data-manager-name="${m.managerName}"
              data-team-name="${m.teamName}"
              data-chip="${m.chipPlayed}"
              data-live-points="${m.livePoints}"
            >${m.managerName}</button>
            ${m.chipPlayed ? `<span class="badge" style="margin-left:4px;font-size:10px;padding:1px 4px;">${m.chipPlayed}</span>` : ""}
          </td>
          <td class="gw-col">${m.livePointsBeforeHits}</td>
          <td class="hit-col ${hitClass}">${m.transferCost}</td>
          <td class="nett-col">${m.livePoints}</td>
          <td class="total-col">${m.totalPoints.toLocaleString()}</td>
          <td class="diff-col">${diffText}</td>
        </tr>
      `;
      rank++;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;
    return html;
  }

  function attachManagerButtons() {
    document.querySelectorAll('.manager-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = (e.target as HTMLElement).closest('.manager-btn') as HTMLElement;
        const entryId = parseInt(button.dataset.entryId || '0');
        const managerName = button.dataset.managerName || '';
        const teamName = button.dataset.teamName || '';
        const chipPlayed = button.dataset.chip || '';
        const livePoints = parseInt(button.dataset.livePoints || '0');
        showSquadModal(entryId, managerName, teamName, chipPlayed, livePoints);
      });
    });
  }

  async function loadLive(ids: number[], gw: number) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    if (!gw) {
      out.innerHTML = "<p class='status status--warning'>Please select a gameweek.</p>";
      return;
    }

    // Generate load token for cancellation
    const loadToken = ++currentLoadToken;
    
    // Disable refresh button during loading
    refreshBtn.disabled = true;
    
    liveData = [];
    out.innerHTML = "";
    loadingStatus.textContent = `Fetching latest data...`;

    // 1. CLEAR CACHES to ensure fresh data
    fixturesCache = [];
    livePointsCache.clear();
    projectedBonusCache.clear();
    teamStatusCache.clear();

    // 2. Generate single cache-buster token for this load
    const cacheBuster = Date.now().toString();
    
    // 3. Fetch Fixtures & Live Data in parallel with cache-buster
    try {
      await Promise.all([
        fetchFixtures({ 
          gw, 
          fixturesCache, 
          projectedBonusCache, 
          teamStatusCache, 
          includeFinishedProvisional: true,
          cacheBuster 
        }),
        fetchLiveGW({ 
          gw, 
          livePointsCache, 
          includeExtendedStats: true,
          cacheBuster 
        })
      ]);
    } catch (e) {
      console.error('Error fetching fixtures/live data:', e);
      loadingStatus.innerHTML = `<span class='status status--error'>Error loading fixtures/live data</span>`;
      refreshBtn.disabled = false;
      return;
    }

    // Check if this load has been superseded
    if (loadToken !== currentLoadToken) {
      console.log('Load superseded, aborting');
      return;
    }

    // 4. Fetch manager data concurrently with limit of 8
    const managerDataResults = await mapWithConcurrency(
      ids,
      8,
      async (id) => {
        return await fetchManagerLive(id, gw, cacheBuster);
      },
      (completed, total) => {
        loadingStatus.textContent = `Fetching ${completed}/${total}...`;
      }
    );

    // Check again if this load has been superseded
    if (loadToken !== currentLoadToken) {
      console.log('Load superseded after fetching managers, aborting');
      return;
    }

    // 5. Filter out nulls and update liveData
    liveData = managerDataResults.filter((data): data is NonNullable<typeof data> => data !== null);

    // 6. Render table once at the end
    if (liveData.length > 0) {
      const compareId = compareManagerSelect.value;
      out.innerHTML = makeLiveTable(liveData, compareId);
      attachManagerButtons();
      populateCompareManager();
    }

    loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${liveData.length} managers</span>`;
    lastUpdatedEl.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
    
    // Re-enable refresh button
    refreshBtn.disabled = false;
  }

  async function init() {
    loadingStatus.textContent = "Loading player data...";
    await fetchBootstrapData();

    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (!authenticated) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    if (managerIds.length > 0) {
      loadLive(managerIds, latestGW);
    } else {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
    }
  }

  gwFilterSelect.addEventListener('change', async () => {
    const gw = parseInt(gwFilterSelect.value);
    if (gw && gw >= 1 && gw <= 38) {
      loadLive(managerIds, gw);
    }
  });

  compareManagerSelect.addEventListener('change', () => {
    const compareId = compareManagerSelect.value;
    out.innerHTML = makeLiveTable(liveData, compareId);
    attachManagerButtons();
  });

  refreshBtn.addEventListener('click', async () => {
    // Clear manager data cache on manual refresh
    managerDataCache.clear();
    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;
    const gw = parseInt(gwFilterSelect.value) || latestGW;
    loadLive(managerIds, gw);
  });

  init();
</script>
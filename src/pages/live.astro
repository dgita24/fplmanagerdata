---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="Live League Standings - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">üî¥ Live Standings</h1>
      <p class="page-subtitle">Real-time league table with live points, projected bonus & auto subs.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">‚öô Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="compare-manager">Compare to</label>
        <select class="select-small" id="compare-manager">
          <option value="">Leader</option>
        </select>
      </div>
    </div>

    <div class="buttons-row">
      <button id="refresh-btn" class="btn-row" type="button">üîÑ Refresh</button>
      <button id="auto-refresh-btn" class="btn-row btn-row--neutral" type="button">‚è± Auto: OFF</button>
    </div>

    <div id="loading-status" class="meta-row"></div>
    <div id="last-updated" class="meta-row"></div>
    <section id="live-output" aria-live="polite"></section>
  </main>

  <!-- Squad Modal -->
  <div id="squad-modal" class="modal">
    <div class="modal-panel">
      <button id="close-squad-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="squad-modal-content"></div>
    </div>
  </div>

  <!-- Player Stats Modal -->
  <div id="player-modal" class="modal modal--nested">
    <div class="modal-panel modal-panel--compact">
      <button id="close-player-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="player-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 32px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .buttons-row {
    display: flex;
    gap: var(--space-2);
  }

  .btn-row {
    flex: 1;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
  }

  .btn-row:hover {
    background: var(--color-primary-hover);
  }

  .btn-row--neutral {
    background: var(--color-surface);
    color: var(--color-text);
    border: 1px solid var(--color-border);
  }

  .btn-row--neutral:hover {
    background: var(--color-surface-alt);
  }

  .btn-row--success {
    background: var(--color-success);
    color: white;
  }

  .btn-row--success:hover {
    background: var(--color-success-hover);
  }
</style>

<script>
  import { supabase } from '../lib/supabase.ts'

  let managerIds: number[] = []

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("live-output")!;
  const gwFilterSelect = document.getElementById("gw-filter") as HTMLSelectElement;
  const compareManagerSelect = document.getElementById("compare-manager") as HTMLSelectElement;
  const loadingStatus = document.getElementById("loading-status")!;
  const lastUpdatedEl = document.getElementById("last-updated")!;
  const managerCountEl = document.getElementById("manager-count")!;
  const refreshBtn = document.getElementById("refresh-btn")!;
  const autoRefreshBtn = document.getElementById("auto-refresh-btn")!;
  const squadModal = document.getElementById("squad-modal")!;
  const squadModalContent = document.getElementById("squad-modal-content")!;
  const closeSquadModal = document.getElementById("close-squad-modal")!;
  const playerModal = document.getElementById("player-modal")!;
  const playerModalContent = document.getElementById("player-modal-content")!;
  const closePlayerModal = document.getElementById("close-player-modal")!;

  interface PlayerInfo {
    name: string;
    position: number;
    team: number;
  }

  interface TeamInfo {
    name: string;
    shortName: string;
  }

  interface LiveStats {
    points: number;
    bonus: number;
    minutes: number;
    bps: number;
    goals_scored: number;
    assists: number;
    clean_sheets: number;
    goals_conceded: number;
    own_goals: number;
    penalties_saved: number;
    penalties_missed: number;
    yellow_cards: number;
    red_cards: number;
    saves: number;
    clearances_blocks_interceptions: number;
    recoveries: number;
    tackles: number;
    defensive_contribution: number;
  }

  interface FixtureInfo {
    id: number;
    team_h: number;
    team_a: number;
    team_h_score: number | null;
    team_a_score: number | null;
    started: boolean;
    finished: boolean;
    finished_provisional: boolean;
  }

  let liveData: any[] = [];
  let latestGW: number = 1;
  let playerCache = new Map<number, PlayerInfo>();
  let teamCache = new Map<number, TeamInfo>();
  let livePointsCache = new Map<number, LiveStats>();
  let projectedBonusCache = new Map<string, number>();
  let teamStatusCache = new Map<string, { started: boolean; finished: boolean; finishedProvisional: boolean }>();
  let fixturesCache: FixtureInfo[] = [];

  let autoRefreshInterval: ReturnType<typeof setInterval> | null = null;
  let autoRefreshEnabled = false;

  closeSquadModal.addEventListener("click", () => {
    squadModal.classList.remove("is-open");
  });

  closePlayerModal.addEventListener("click", () => {
    playerModal.classList.remove("is-open");
  });

  function populateGWSelector(currentGW: number) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = String(i);
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  function positionLabel(elementType: number): string {
    if (elementType === 1) return "GK";
    if (elementType === 2) return "DEF";
    if (elementType === 3) return "MID";
    return "FWD";
  }

  function getTeamGwStatus(teamId: number, gw: number) {
    return teamStatusCache.get(`${gw}:${teamId}`) || { started: false, finished: false, finishedProvisional: false };
  }

  function bonusFromBpsRows(bpsRows: any[]): Map<number, number> {
    const rows = (bpsRows || [])
      .filter(r => r && Number.isFinite(r.value) && Number.isFinite(r.element))
      .sort((a, b) => b.value - a.value);

    const out = new Map<number, number>();
    if (rows.length === 0) return out;

    const topVal = rows[0].value;
    const top = rows.filter(r => r.value === topVal);

    if (top.length >= 2) {
      for (const r of top) out.set(r.element, 3);
      if (top.length >= 3) return out;
      const next = rows.find(r => r.value < topVal);
      if (next) {
        const nextVal = next.value;
        for (const r of rows.filter(r => r.value === nextVal)) out.set(r.element, 1);
      }
      return out;
    }

    out.set(rows[0].element, 3);
    const secondRow = rows.find(r => r.value < topVal);
    if (!secondRow) return out;

    const secondVal = secondRow.value;
    const second = rows.filter(r => r.value === secondVal);

    if (second.length >= 2) {
      for (const r of second) out.set(r.element, 2);
      return out;
    }

    out.set(second[0].element, 2);
    const thirdRow = rows.find(r => r.value < secondVal);
    if (!thirdRow) return out;

    const thirdVal = thirdRow.value;
    for (const r of rows.filter(r => r.value === thirdVal)) out.set(r.element, 1);

    return out;
  }

  function getPlayerLiveComputed(playerId: number, teamId: number, gw: number) {
    const live = livePointsCache.get(playerId) || { 
      points: 0, bonus: 0, minutes: 0, bps: 0,
      goals_scored: 0, assists: 0, clean_sheets: 0, goals_conceded: 0,
      own_goals: 0, penalties_saved: 0, penalties_missed: 0,
      yellow_cards: 0, red_cards: 0, saves: 0,
      clearances_blocks_interceptions: 0, recoveries: 0, tackles: 0, defensive_contribution: 0
    };
    const { started, finished, finishedProvisional } = getTeamGwStatus(teamId, gw);
  
    // For auto-subs, treat provisional as finished (player won't play more)
    const isFinishedForSubs = finished || finishedProvisional;
  
    // For bonus points, only use confirmed bonus when FULLY finished (not provisional)
    // Because FPL doesn't add bonus to total_points until fully confirmed
    const bonusConfirmed = finished;

    const officialTotal = Number(live.points) || 0;
    const confirmedBonus = Number(live.bonus) || 0;
    const minutes = Number(live.minutes) || 0;

    let liveTotal: number;
    let projBonus: number;

    if (bonusConfirmed) {
      // Fully finished - official total includes bonus
      liveTotal = officialTotal;
      projBonus = 0;
    } else if (finishedProvisional) {
      // Provisional - bonus not yet in official total, use projected
      const basePoints = officialTotal - confirmedBonus; // Remove any partial bonus
      projBonus = Number(projectedBonusCache.get(`${gw}:${playerId}`)) || 0;
      liveTotal = basePoints + projBonus;
    } else if (started) {
      // Live match - use projected bonus
      const basePoints = officialTotal - confirmedBonus;
      projBonus = Number(projectedBonusCache.get(`${gw}:${playerId}`)) || 0;
      liveTotal = basePoints + projBonus;
    } else {
      // Not started
      liveTotal = 0;
      projBonus = 0;
    }

    const status = isFinishedForSubs ? "Fin" : (started ? "Live" : "NS");
    return { locked: liveTotal - projBonus, projBonus, liveTotal, status, minutes, confirmedBonus };
  }

  function applyAutoSubsAndMultipliers(teamPicks: any[], chipCode: string) {
    const isBB = chipCode === "BB";
    const isTC = chipCode === "TC";
    const capFactor = isTC ? 3 : 2;

    const sorted = [...teamPicks].sort((a, b) => a.position - b.position);
    const starters = sorted.slice(0, 11);
    const bench = sorted.slice(11);

    if (isBB) {
      const captain = sorted.find(p => p.is_captain);
      const capId = captain ? captain.playerId : null;

      return sorted.map(p => ({
        ...p,
        multiplier: capId && p.playerId === capId ? capFactor : 1,
        autoSubStatus: null // No auto-subs with Bench Boost
      }));
    }

    // Track which starters didn't play and which bench players subbed in
    const dnpStarters: number[] = []; // playerIds of starters who didn't play
    const subbedIn: number[] = []; // playerIds of bench players who subbed in

    // Separate GK and outfield starters
    const gkStarter = starters.find(p => p.playingPosition === "GK");
    const outfieldStarters = starters.filter(p => p.playingPosition !== "GK");

    // Separate GK and outfield bench
    const gkBench = bench.filter(p => p.playingPosition === "GK");
    const outfieldBench = bench.filter(p => p.playingPosition !== "GK");

    // Check if GK played
    let activeGK = gkStarter;
    const gkDnp = gkStarter && gkStarter.minutes === 0 && gkStarter.status === "Fin";
  
    if (gkDnp && gkStarter) {
      dnpStarters.push(gkStarter.playerId);
      // Try to sub in bench GK
      const benchGK = gkBench.find(p => !(p.minutes === 0 && p.status === "Fin"));
      if (benchGK) {
        activeGK = benchGK;
        subbedIn.push(benchGK.playerId);
      } else {
        activeGK = null; // No valid GK sub
      }
    }

    // Process outfield starters - identify who didn't play
    let activeOutfield = outfieldStarters.filter(p => !(p.minutes === 0 && p.status === "Fin"));
    const outfieldDnp = outfieldStarters.filter(p => p.minutes === 0 && p.status === "Fin");
  
    for (const dnp of outfieldDnp) {
      dnpStarters.push(dnp.playerId);
    }

    // Process outfield bench in order to fill spots
    for (const cand of outfieldBench) {
      // Do we need more outfield players? (10 outfield needed)
      if (activeOutfield.length >= 10) break;

      // Check candidate's match status
      const matchFinished = cand.status === "Fin";

      // If match hasn't finished, STOP - they block subsequent subs
      if (!matchFinished) break;

      // Did they play?
      if (cand.minutes === 0) continue; // DNP, skip to next

      // Check formation validity
      const testOutfield = [...activeOutfield, cand];
      const defCount = testOutfield.filter(p => p.playingPosition === "DEF").length;
      const midCount = testOutfield.filter(p => p.playingPosition === "MID").length;
      const fwdCount = testOutfield.filter(p => p.playingPosition === "FWD").length;

      const spotsLeft = 10 - testOutfield.length;

      if (spotsLeft === 0) {
        // Would complete the outfield - verify valid formation
        const isValid = defCount >= 3 && midCount >= 2 && fwdCount >= 1;
        if (isValid) {
          activeOutfield = testOutfield;
          subbedIn.push(cand.playerId);
        }
      } else {
        // Still need more players - check if we can complete formation
        const needDef = Math.max(0, 3 - defCount);
        const needMid = Math.max(0, 2 - midCount);
        const needFwd = Math.max(0, 1 - fwdCount);

        // Find remaining usable outfield bench
        const remainingIdx = outfieldBench.indexOf(cand);
        let usableBench: any[] = [];
        for (let j = remainingIdx + 1; j < outfieldBench.length; j++) {
          const p = outfieldBench[j];
          if (p.status !== "Fin") break;
          if (p.minutes > 0) usableBench.push(p);
        }

        const availDef = usableBench.filter(p => p.playingPosition === "DEF").length;
        const availMid = usableBench.filter(p => p.playingPosition === "MID").length;
        const availFwd = usableBench.filter(p => p.playingPosition === "FWD").length;

        const canComplete = availDef >= needDef && 
                           availMid >= needMid && 
                           availFwd >= needFwd &&
                           usableBench.length >= spotsLeft;

        if (canComplete) {
          activeOutfield = testOutfield;
          subbedIn.push(cand.playerId);
        }
      }
    }

    // Build final active team
    const active: any[] = [];
    if (activeGK) active.push(activeGK);
    active.push(...activeOutfield);

    // Determine captain
    const origCap = sorted.find(p => p.is_captain)?.playerId ?? null;
    const origVC = sorted.find(p => p.is_vice_captain)?.playerId ?? null;

    const capInActive = origCap !== null && active.some(p => p.playerId === origCap);
    const vcInActive = origVC !== null && active.some(p => p.playerId === origVC);

    const capPlayed = capInActive && active.some(p => 
      p.playerId === origCap && (p.minutes > 0 || p.status !== "Fin")
    );
    const vcPlayed = vcInActive && active.some(p => 
      p.playerId === origVC && (p.minutes > 0 || p.status !== "Fin")
    );

    const captainId = capPlayed ? origCap : (vcPlayed ? origVC : null);

    // Return ALL players with their status
    return sorted.map(p => {
      const isActive = active.some(a => a.playerId === p.playerId);
      const isDnpStarter = dnpStarters.includes(p.playerId);
      const isSubbedIn = subbedIn.includes(p.playerId);
    
      let multiplier = 0;
      if (isActive) {
        multiplier = (captainId && p.playerId === captainId) ? capFactor : 1;
      }

      return {
        ...p,
        multiplier,
        autoSubStatus: isDnpStarter ? 'OUT' : (isSubbedIn ? 'IN' : null)
      };
    });
  }
  

  async function fetchBootstrapData() {
    try {
      const res = await fetch('/api/fpl/bootstrap-static');
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      data.elements.forEach((player: any) => {
        playerCache.set(player.id, {
          name: player.web_name,
          position: player.element_type,
          team: player.team
        });
      });

      data.teams.forEach((team: any) => {
        teamCache.set(team.id, {
          name: team.name,
          shortName: team.short_name
        });
      });

      const currentEvent = data.events.find((e: any) => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;

      populateGWSelector(latestGW);

      return data;
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
      return null;
    }
  }

  async function fetchFixtures(gw: number) {
    try {
      const res = await fetch(`/api/fpl/fixtures?event=${gw}`);
      if (!res.ok) throw new Error("Failed to fetch fixtures");
      const fixtures: FixtureInfo[] = await res.json();

      fixturesCache = fixtures;
      teamStatusCache.clear();
      projectedBonusCache.clear();

      const perTeam = new Map<number, { startedAny: boolean; finishedAll: boolean; finishedProvAll: boolean }>();
      function upsertTeam(teamId: number, started: boolean, finished: boolean, finishedProvisional: boolean) {
        const cur = perTeam.get(teamId) || { startedAny: false, finishedAll: true, finishedProvAll: true };
        cur.startedAny = cur.startedAny || !!started || !!finished || !!finishedProvisional;
        cur.finishedAll = cur.finishedAll && !!finished;
        cur.finishedProvAll = cur.finishedProvAll && (!!finished || !!finishedProvisional);
        perTeam.set(teamId, cur);
      }

      for (const fx of fixtures) {
        upsertTeam(fx.team_h, fx.started, fx.finished, fx.finished_provisional);
        upsertTeam(fx.team_a, fx.started, fx.finished, fx.finished_provisional);

        // Only calculate projected bonus for truly live matches (not finished or provisional)
        if (!fx.started || fx.finished) continue;

        const stats = (fx as any).stats;
        if (!Array.isArray(stats)) continue;
        
        const bpsStat = stats.find((s: any) => s && s.identifier === "bps");
        if (!bpsStat) continue;

        const h = Array.isArray(bpsStat.h) ? bpsStat.h : [];
        const a = Array.isArray(bpsStat.a) ? bpsStat.a : [];
        const all = [...h, ...a]
          .map(r => ({
            element: Number(r.element),
            value: Number(r.value)
          }))
          .filter(r => Number.isFinite(r.element) && Number.isFinite(r.value));

        const bonusMap = bonusFromBpsRows(all);

        for (const [playerId, bonus] of bonusMap.entries()) {
          const key = `${gw}:${playerId}`;
          projectedBonusCache.set(key, (projectedBonusCache.get(key) || 0) + bonus);
        }
      }

      for (const [teamId, st] of perTeam.entries()) {
        teamStatusCache.set(`${gw}:${teamId}`, { 
          started: st.startedAny, 
          finished: st.finishedAll,
          finishedProvisional: st.finishedProvAll
        });
      }

      return fixtures;
    } catch (e) {
      console.error("Error fetching fixtures:", e);
      return [];
    }
  }

  async function fetchLiveGW(gw: number) {
    try {
      const res = await fetch(`/api/fpl/event/${gw}/live`);
      if (!res.ok) throw new Error("Failed to fetch live data");
      const data = await res.json();

      livePointsCache.clear();

      const elements = Array.isArray(data.elements) ? data.elements : [];
      for (const p of elements) {
        const stats = p.stats || {};
        livePointsCache.set(p.id, {
          points: Number(stats.total_points) || 0,
          bonus: Number(stats.bonus) || 0,
          minutes: Number(stats.minutes) || 0,
          bps: Number(stats.bps) || 0,
          goals_scored: Number(stats.goals_scored) || 0,
          assists: Number(stats.assists) || 0,
          clean_sheets: Number(stats.clean_sheets) || 0,
          goals_conceded: Number(stats.goals_conceded) || 0,
          own_goals: Number(stats.own_goals) || 0,
          penalties_saved: Number(stats.penalties_saved) || 0,
          penalties_missed: Number(stats.penalties_missed) || 0,
          yellow_cards: Number(stats.yellow_cards) || 0,
          red_cards: Number(stats.red_cards) || 0,
          saves: Number(stats.saves) || 0,
          clearances_blocks_interceptions: Number(stats.clearances_blocks_interceptions) || 0,
          recoveries: Number(stats.recoveries) || 0,
          tackles: Number(stats.tackles) || 0,
          defensive_contribution: Number(stats.defensive_contribution) || 0
        });
      }

      return data;
    } catch (e) {
      console.error("Error fetching live data:", e);
      return null;
    }
  }

  async function fetchManagerLive(entryId: number, gw: number) {
    try {
      const [picksRes, summaryRes, historyRes] = await Promise.all([
        fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks`),
        fetch(`/api/fpl/entry/${entryId}`),
        fetch(`/api/fpl/entry/${entryId}/history`)
      ]);

      if (!picksRes.ok || !summaryRes.ok || !historyRes.ok) {
        throw new Error("Failed to fetch manager data");
      }

      const picksData = await picksRes.json();
      const summaryData = await summaryRes.json();
      const historyData = await historyRes.json();

      const chipName = (historyData.chips || []).find((c: any) => c.event === gw)?.name || "";
      const chipCode =
        chipName === "bboost" ? "BB" :
        chipName === "3xc" ? "TC" :
        chipName === "wildcard" ? "WC" :
        chipName === "freehit" ? "FH" :
        "None";

      const rawPicks = Array.isArray(picksData.picks) ? picksData.picks : [];

      const picks = rawPicks.map((p: any) => {
        const player = playerCache.get(p.element) || { name: "", position: 4, team: 0 };
        const teamId = Number(player.team) || 0;

        const computed = getPlayerLiveComputed(p.element, teamId, gw);

        return {
          playerId: Number(p.element),
          position: Number(p.position),
          is_captain: !!p.is_captain,
          is_vice_captain: !!p.is_vice_captain,

          web_name: player.name || "",
          teamId,
          playingPosition: positionLabel(player.position),

          minutes: computed.minutes,
          status: computed.status,
          lockedPoints: computed.locked,
          projBonus: computed.projBonus,
          liveTotal: computed.liveTotal
        };
      });

      const finalTeam = applyAutoSubsAndMultipliers(picks, chipCode);

      const livePointsBeforeHits = finalTeam.reduce((sum, p) => sum + (p.liveTotal * (p.multiplier || 0)), 0);

      const historyRows = Array.isArray(historyData.current) ? historyData.current : [];

      const transferCost =
        Number(historyRows.find((h: any) => Number(h.event) === Number(gw))?.event_transfers_cost) || 0;

      const liveNet = livePointsBeforeHits - transferCost;

      let startOverall = 0;
      if (Number(gw) > 1) {
        const prev = historyRows.find((h: any) => Number(h.event) === (Number(gw) - 1));
        startOverall = Number(prev?.total_points) || 0;
      }

      const liveOverall = startOverall + liveNet;

      return {
        entryId,
        managerName: `${summaryData.player_first_name || ""} ${summaryData.player_last_name || ""}`.trim(),
        teamName: summaryData.name || "",
        chipPlayed: chipCode === "None" ? "" : chipCode,
        transferCost,
        livePointsBeforeHits,
        livePoints: liveNet,
        totalPoints: liveOverall
      };
    } catch (e) {
      console.error(`Error fetching live data for manager ${entryId}:`, e);
      return null;
    }
  }

  function getPlayerFixture(teamId: number): FixtureInfo | null {
    return fixturesCache.find(f => f.team_h === teamId || f.team_a === teamId) || null;
  }

  function calculateDefcon(position: number, defensiveContribution: number): { points: number; threshold: number } {
    if (position === 1) return { points: 0, threshold: 0 };
    const threshold = position === 2 ? 10 : 12;
    const points = defensiveContribution >= threshold ? 2 : 0;
    return { points, threshold };
  }

  function showPlayerModal(playerId: number) {
    const gw = parseInt(gwFilterSelect.value) || latestGW;
    const player = playerCache.get(playerId);
    const liveStats = livePointsCache.get(playerId);

    if (!player) {
      playerModalContent.innerHTML = "<p class='status status--error'>Player not found.</p>";
      playerModal.classList.add("is-open");
      return;
    }

    const teamInfo = teamCache.get(player.team);
    const fixture = getPlayerFixture(player.team);
    const { started, finished, finishedProvisional } = getTeamGwStatus(player.team, gw);
    const isFinished = finished || finishedProvisional;
    const computed = getPlayerLiveComputed(playerId, player.team, gw);

    let opponentStr = "";
    let scoreStr = "";
    if (fixture) {
      const isHome = fixture.team_h === player.team;
      const oppTeamId = isHome ? fixture.team_a : fixture.team_h;
      const oppTeam = teamCache.get(oppTeamId);
      opponentStr = isHome ? `vs ${oppTeam?.shortName || '???'}` : `@ ${oppTeam?.shortName || '???'}`;
      
      if (fixture.started) {
        const homeScore = fixture.team_h_score ?? 0;
        const awayScore = fixture.team_a_score ?? 0;
        scoreStr = isHome ? `${homeScore} - ${awayScore}` : `${awayScore} - ${homeScore}`;
      }
    }

    const statusText = isFinished ? "Full Time" : (started ? "üî¥ Live" : "Not Started");
    const statusClass = isFinished ? "status-fin" : (started ? "status-live" : "status-ns");

    const stats = liveStats || {
      points: 0, bonus: 0, minutes: 0, bps: 0,
      goals_scored: 0, assists: 0, clean_sheets: 0, goals_conceded: 0,
      own_goals: 0, penalties_saved: 0, penalties_missed: 0,
      yellow_cards: 0, red_cards: 0, saves: 0,
      clearances_blocks_interceptions: 0, recoveries: 0, tackles: 0, defensive_contribution: 0
    };

    const projBonus = projectedBonusCache.get(`${gw}:${playerId}`) || 0;
    const isGK = player.position === 1;
    const isDef = player.position === 2;

    const defcon = calculateDefcon(player.position, stats.defensive_contribution);

    const breakdown: { label: string; value: string | number; points: number; show: boolean; isProgress?: boolean }[] = [
      { label: "Minutes", value: stats.minutes, points: stats.minutes >= 60 ? 2 : (stats.minutes > 0 ? 1 : 0), show: true },
      { label: "Goals", value: stats.goals_scored, points: getGoalPoints(player.position, stats.goals_scored), show: stats.goals_scored > 0 },
      { label: "Assists", value: stats.assists, points: stats.assists * 3, show: stats.assists > 0 },
      { label: "Clean Sheet", value: stats.clean_sheets, points: getCleanSheetPoints(player.position, stats.clean_sheets), show: (isGK || isDef) && stats.clean_sheets > 0 },
      { label: "Goals Conceded", value: stats.goals_conceded, points: (isGK || isDef) ? -Math.floor(stats.goals_conceded / 2) : 0, show: (isGK || isDef) && stats.goals_conceded >= 2 },
      { label: "Saves", value: stats.saves, points: Math.floor(stats.saves / 3), show: isGK && stats.saves > 0 },
      { label: "Pen Saved", value: stats.penalties_saved, points: stats.penalties_saved * 5, show: stats.penalties_saved > 0 },
      { label: "Pen Missed", value: stats.penalties_missed, points: stats.penalties_missed * -2, show: stats.penalties_missed > 0 },
      { label: "Own Goals", value: stats.own_goals, points: stats.own_goals * -2, show: stats.own_goals > 0 },
      { label: "Yellow Card", value: stats.yellow_cards, points: stats.yellow_cards * -1, show: stats.yellow_cards > 0 },
      { label: "Red Card", value: stats.red_cards, points: stats.red_cards * -3, show: stats.red_cards > 0 },
      { label: "Bonus", value: stats.bonus || projBonus, points: stats.bonus || projBonus, show: (stats.bonus > 0) || (projBonus > 0 && isFinished) },
      { 
        label: "DEFCON", 
        value: `${stats.defensive_contribution}/${defcon.threshold}`, 
        points: defcon.points, 
        show: !isGK && stats.minutes > 0,
        isProgress: true
      }
    ];

    let html = `
      <div class="player-modal-header">
        <div class="player-modal-info">
          <h2 class="player-modal-name">${player.name}</h2>
          <div class="player-modal-meta">
            <span class="player-modal-team">${teamInfo?.shortName || '???'}</span>
            <span class="player-modal-pos">${positionLabel(player.position)}</span>
            ${opponentStr ? `<span class="player-modal-opp">${opponentStr}</span>` : ''}
          </div>
        </div>
        <div class="player-modal-points">
          <span class="player-modal-total">${computed.liveTotal}</span>
          <span class="player-modal-pts-label">pts</span>
        </div>
      </div>

      <div class="player-modal-match">
        <span class="player-modal-status ${statusClass}">${statusText}</span>
        ${scoreStr ? `<span class="player-modal-score">${scoreStr}</span>` : ''}
      </div>

      <div class="player-modal-breakdown">
        <h3 class="player-modal-section-title">Points Breakdown</h3>
        <div class="breakdown-list">
    `;

    for (const item of breakdown) {
      if (!item.show) continue;
      
      let pointsClass = item.points > 0 ? 'points-positive' : (item.points < 0 ? 'points-negative' : '');
      let pointsDisplay: string = item.points > 0 ? `+${item.points}` : String(item.points);
      let valueClass = '';
      
      if (item.isProgress) {
        const achieved = item.points > 0;
        pointsClass = achieved ? 'points-positive' : 'points-pending';
        valueClass = achieved ? 'value-achieved' : 'value-progress';
        if (!achieved) {
          pointsDisplay = '‚Äî';
        }
      }

      html += `
        <div class="breakdown-row ${item.isProgress ? 'breakdown-row--defcon' : ''}">
          <span class="breakdown-label">${item.label}</span>
          <span class="breakdown-value ${valueClass}">${item.value}</span>
          <span class="breakdown-points ${pointsClass}">${pointsDisplay}</span>
        </div>
      `;
    }

    if (!isFinished && projBonus > 0) {
      html += `
        <div class="breakdown-row breakdown-row--projected">
          <span class="breakdown-label">Proj. Bonus</span>
          <span class="breakdown-value">‚Äî</span>
          <span class="breakdown-points points-projected">+${projBonus}</span>
        </div>
      `;
    }

    html += `
        </div>
      </div>

      <div class="player-modal-bps">
        <span class="bps-label">BPS</span>
        <span class="bps-value">${stats.bps}</span>
      </div>
    `;

    playerModalContent.innerHTML = html;
    playerModal.classList.add("is-open");
  }

  function getGoalPoints(position: number, goals: number): number {
    if (goals === 0) return 0;
    if (position === 1 || position === 2) return goals * 6;
    if (position === 3) return goals * 5;
    return goals * 4;
  }

  function getCleanSheetPoints(position: number, cleanSheets: number): number {
    if (cleanSheets === 0) return 0;
    if (position === 1 || position === 2) return cleanSheets * 4;
    if (position === 3) return cleanSheets * 1;
    return 0;
  }

  
  async function showSquadModal(entryId: number, managerName: string, teamName: string, chipPlayed: string, livePoints: number) {
    const gw = parseInt(gwFilterSelect.value) || latestGW;

    squadModalContent.innerHTML = `<p class="text-muted">Loading squad...</p>`;
    squadModal.classList.add("is-open");

    try {
      const picksRes = await fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks`);
      if (!picksRes.ok) throw new Error("Failed to fetch picks");

      const picksData = await picksRes.json();
      const rawPicks = Array.isArray(picksData.picks) ? picksData.picks : [];

      const chipCode = chipPlayed || "None";

      const picks = rawPicks.map((p: any) => {
        const player = playerCache.get(p.element) || { name: "Unknown", position: 4, team: 0 };
        const teamId = Number(player.team) || 0;
        const teamInfo = teamCache.get(teamId) || { shortName: "???" };

        const computed = getPlayerLiveComputed(p.element, teamId, gw);

        return {
          playerId: Number(p.element),
          position: Number(p.position),
          is_captain: !!p.is_captain,
          is_vice_captain: !!p.is_vice_captain,
          web_name: player.name || "Unknown",
          teamShort: teamInfo.shortName,
          playingPosition: positionLabel(player.position),
          minutes: computed.minutes,
          status: computed.status,
          liveTotal: computed.liveTotal
        };
      });

      const finalTeam = applyAutoSubsAndMultipliers(picks, chipCode);
    
      // Keep original positions for display
      const sorted = [...finalTeam].sort((a, b) => a.position - b.position);
      const originalStarters = sorted.slice(0, 11);
      const originalBench = sorted.slice(11);

      const chipEmoji = chipPlayed === "WC" ? "üÉè" : 
                        chipPlayed === "BB" ? "ü™ë" : 
                        chipPlayed === "TC" ? "üëë" : 
                        chipPlayed === "FH" ? "üéØ" : "";

      let html = `
        <h2 class="modal-title" style="padding-right:40px;">
          ${managerName}
          ${chipPlayed ? `<span class="badge" style="margin-left:8px;">${chipEmoji} ${chipPlayed}</span>` : ""}
        </h2>
        <p class="text-muted" style="margin-bottom:var(--space-3);">
          ${teamName} ¬∑ GW${gw} ¬∑ <span class="text-success font-bold">${livePoints} pts</span>
        </p>

        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Starting XI</h3>
          <table class="squad-modal-table">
            <thead>
              <tr>
                <th>Player</th>
                <th class="col-team">Team</th>
                <th class="col-pts">Pts</th>
              </tr>
            </thead>
            <tbody>
      `;

      for (const p of originalStarters) {
        const capLabel = p.is_captain ? '<span class="cap-badge cap-c">C</span>' : 
                         p.is_vice_captain ? '<span class="cap-badge cap-v">V</span>' : '';
      
        const mult = p.multiplier || 0;
        const isSubbedOut = p.autoSubStatus === 'OUT';
        const isNotStarted = p.status === "NS";  // NEW: detect not started
        const isLive = p.status === "Live";
        const isFinished = p.status === "Fin";
        const displayPts = isSubbedOut ? 0 : Math.round(p.liveTotal * (mult || 1));
        const ptsText = mult > 1 ? `${p.liveTotal}√ó${mult}` : String(displayPts);

        let rowClass = "";
        let statusBadge = "";
      
        if (isSubbedOut) {
          rowClass = "sub-off-row";
          statusBadge = `<span class="status-badge status-dnp">DNP</span>`;
        } else if (isNotStarted) {
          rowClass = "not-started-row";  // Blue
        } else if (isLive) {
          rowClass = "match-live-row";       // Yellow
        } else if (isFinished) {
          rowClass = "match-finished-row";   // Green
        }   
   
        html += `
          <tr class="${rowClass}">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn ${isSubbedOut ? 'player-dnp' : ''}" data-player-id="${p.playerId}">${p.web_name}</button>
              ${capLabel}
              ${statusBadge}
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts ${isSubbedOut ? 'text-muted' : ''}">${ptsText}</td>
          </tr>
        `;
      }

      // Show auto-subs who came on (from bench)
      const subbedInPlayers = originalBench.filter(p => p.autoSubStatus === 'IN');
      for (const p of subbedInPlayers) {
        const mult = p.multiplier || 1;
        const displayPts = Math.round(p.liveTotal * mult);
        const ptsText = mult > 1 ? `${p.liveTotal}√ó${mult}` : String(displayPts);

        html += `
          <tr class="sub-on-row">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn" data-player-id="${p.playerId}">${p.web_name}</button>
              <span class="status-badge status-on">ON</span>
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts">${ptsText}</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>

        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Bench</h3>
          <table class="squad-modal-table bench-table">
            <tbody>
    `  ;

      for (const p of originalBench) {
        const isSubbedIn = p.autoSubStatus === 'IN';
        const isDnp = p.minutes === 0 && p.status === "Fin";
      
        // Skip players who subbed in (they're shown above)
        if (isSubbedIn) continue;
      
        const rowClass = chipCode === "BB" ? "" : (isDnp ? "dnp-row" : "bench-inactive");

        let statusBadge = "";
        if (isDnp) statusBadge = `<span class="status-badge status-dnp">DNP</span>`;

        html += `
          <tr class="${rowClass}">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <button type="button" class="player-name-btn" data-player-id="${p.playerId}">${p.web_name}</button>
              ${statusBadge}
            </td>
            <td class="col-team">${p.teamShort}</td>
            <td class="col-pts">${chipCode === "BB" ? p.liveTotal : `<span class="text-muted">${p.liveTotal}</span>`}</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>
      `;

      squadModalContent.innerHTML = html;

      squadModalContent.querySelectorAll('.player-name-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const button = e.target as HTMLElement;
          const playerId = parseInt(button.dataset.playerId || '0');
          if (playerId) showPlayerModal(playerId);
        });
      });

    } catch (error) {
      console.error("Error loading squad:", error);
      squadModalContent.innerHTML = "<p class='status status--error'>Error loading squad data.</p>";
    }
  }

  function populateCompareManager() {
    compareManagerSelect.innerHTML = '<option value="">Leader</option>';

    const sortedManagers = [...liveData].sort((a, b) =>
      a.managerName.localeCompare(b.managerName)
    );

    for (const manager of sortedManagers) {
      const option = document.createElement('option');
      option.value = manager.entryId;
      option.textContent = manager.managerName;
      compareManagerSelect.appendChild(option);
    }
  }

  function makeLiveTable(managers: any[], compareToId = "") {
    const sorted = [...managers].sort((a, b) => b.totalPoints - a.totalPoints);

    const leader = sorted[0];
    const compareManager = compareToId ? sorted.find(m => m.entryId.toString() === compareToId) : leader;

    let maxGwPoints = -Infinity;
    sorted.forEach(m => {
      if (m.livePoints > maxGwPoints) {
        maxGwPoints = m.livePoints;
      }
    });

    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table live-table">
            <thead>
              <tr>
                <th class="rank-col">#</th>
                <th>Manager</th>
                <th class="gw-col">GW</th>
                <th class="hit-col">Hit</th>
                <th class="nett-col">Nett</th>
                <th class="total-col">Total</th>
                <th class="diff-col">Diff</th>
              </tr>
            </thead>
            <tbody>
    `;

    let rank = 1;
    for (const m of sorted) {
      const diffOverall = m.totalPoints - (compareManager?.totalPoints || 0);
      const diffText = diffOverall > 0 ? `+${diffOverall}` : diffOverall === 0 ? "‚Äî" : `${diffOverall}`;

      const isTopScorer = m.livePoints === maxGwPoints;
      const rowClass = isTopScorer ? 'top-scorer-row' : '';
      const hitClass = m.transferCost > 0 ? 'hit-highlight' : '';

      html += `
        <tr class="${rowClass}">
          <td class="rank-col">${rank}</td>
          <td class="manager-col">
            <button type="button" class="manager-btn" 
              data-entry-id="${m.entryId}"
              data-manager-name="${m.managerName}"
              data-team-name="${m.teamName}"
              data-chip="${m.chipPlayed}"
              data-live-points="${m.livePoints}"
            >${m.managerName}</button>
            ${m.chipPlayed ? `<span class="badge" style="margin-left:4px;font-size:10px;padding:1px 4px;">${m.chipPlayed}</span>` : ""}
          </td>
          <td class="gw-col">${m.livePointsBeforeHits}</td>
          <td class="hit-col ${hitClass}">${m.transferCost}</td>
          <td class="nett-col">${m.livePoints}</td>
          <td class="total-col">${m.totalPoints.toLocaleString()}</td>
          <td class="diff-col">${diffText}</td>
        </tr>
      `;
      rank++;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;
    return html;
  }

  function attachManagerButtons() {
    document.querySelectorAll('.manager-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = (e.target as HTMLElement).closest('.manager-btn') as HTMLElement;
        const entryId = parseInt(button.dataset.entryId || '0');
        const managerName = button.dataset.managerName || '';
        const teamName = button.dataset.teamName || '';
        const chipPlayed = button.dataset.chip || '';
        const livePoints = parseInt(button.dataset.livePoints || '0');
        showSquadModal(entryId, managerName, teamName, chipPlayed, livePoints);
      });
    });
  }

  async function loadLive(ids: number[], gw: number) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    if (!gw) {
      out.innerHTML = "<p class='status status--warning'>Please select a gameweek.</p>";
      return;
    }

    liveData = [];
    out.innerHTML = "";
    loadingStatus.textContent = `Loading GW${gw}...`;

    await Promise.all([
      fetchFixtures(gw),
      fetchLiveGW(gw)
    ]);

    let loaded = 0;
    for (const id of ids) {
      try {
        const data = await fetchManagerLive(id, gw);
        if (data) {
          liveData.push(data);
          loaded++;

          loadingStatus.textContent = `Loading ${loaded} of ${ids.length}...`;

          const compareId = compareManagerSelect.value;
          out.innerHTML = makeLiveTable(liveData, compareId);
          attachManagerButtons();
        }
      } catch (e) {
        console.error(`Failed to load manager ${id}:`, e);
        loaded++;
      }
    }

    populateCompareManager();

    loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${loaded} managers</span>`;
    lastUpdatedEl.textContent = `Updated: ${new Date().toLocaleTimeString()}`;
  }

  async function init() {
    loadingStatus.textContent = "Loading player data...";
    await fetchBootstrapData();

    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (!authenticated) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    if (managerIds.length > 0) {
      loadLive(managerIds, latestGW);
    } else {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
    }
  }

  gwFilterSelect.addEventListener('change', async () => {
    const gw = parseInt(gwFilterSelect.value);
    if (gw && gw >= 1 && gw <= 38) {
      loadLive(managerIds, gw);
    }
  });

  compareManagerSelect.addEventListener('change', () => {
    const compareId = compareManagerSelect.value;
    out.innerHTML = makeLiveTable(liveData, compareId);
    attachManagerButtons();
  });

  refreshBtn.addEventListener('click', async () => {
    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;
    const gw = parseInt(gwFilterSelect.value) || latestGW;
    loadLive(managerIds, gw);
  });

  autoRefreshBtn.addEventListener('click', () => {
    autoRefreshEnabled = !autoRefreshEnabled;

    if (autoRefreshEnabled) {
      autoRefreshBtn.textContent = "‚è± Auto: ON";
      autoRefreshBtn.className = "btn-row btn-row--success";

      autoRefreshInterval = setInterval(async () => {
        const gw = parseInt(gwFilterSelect.value) || latestGW;
        loadLive(managerIds, gw);
      }, 120000);
    } else {
      autoRefreshBtn.textContent = "‚è± Auto: OFF";
      autoRefreshBtn.className = "btn-row btn-row--neutral";

      if (autoRefreshInterval) {
        clearInterval(autoRefreshInterval);
        autoRefreshInterval = null;
      }
    }
  });

  init();
</script>
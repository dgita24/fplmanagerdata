---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="League Statistics - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">League Statistics</h1>
      <p class="page-subtitle">Manager performance, rankings, and detailed stats.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">‚öô Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small">&nbsp;</label>
        <button id="refresh-btn" class="btn-row" type="button">üîÑ Refresh</button>
      </div>
    </div>

    <div id="loading-status" class="meta-row"></div>
    <section id="stats-output" aria-live="polite"></section>
  </main>

  <!-- Manager Stats Modal -->
  <div id="stats-modal" class="modal">
    <div class="modal-panel" style="max-width:550px;">
      <button id="close-stats-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="stats-modal-content"></div>
    </div>
  </div>

  <!-- Squad Modal (reused from Live page) -->
  <div id="squad-modal" class="modal modal--nested">
    <div class="modal-panel">
      <button id="close-squad-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="squad-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 36px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .btn-row {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
  }

  .btn-row:hover {
    background: var(--color-primary-hover);
  }
</style>

<script>
  import { supabase } from '../lib/supabase.ts'
  import { type FixtureInfo, type LiveStatLine, type TeamStatus } from '../lib/fplLive.ts'

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  let latestGW = 1;
  let currentGWFinished = false;
  let managerIds: number[] = [];
  let allManagerData: ManagerData[] = [];
  let playerCache = new Map<number, { name: string; position: number; team: number }>();
  let teamCache = new Map<number, { name: string; shortName: string }>();
  let livePointsCache = new Map<number, LiveStatLine>();
  let projectedBonusCache = new Map<string, number>();
  let teamStatusCache = new Map<string, TeamStatus>();
  let fixturesCache: FixtureInfo[] = [];

  interface ManagerData {
    entryId: number;
    managerName: string;
    teamName: string;
    totalPoints: number;
    overallRank: number;
    gwPoints: number;
    gwRank: number;
    teamValue: number;
    bank: number;
    historyData: any;
    summaryData: any;
  }

  const out = document.getElementById("stats-output")!;
  const loadingStatus = document.getElementById("loading-status")!;
  const managerCountEl = document.getElementById("manager-count")!;
  const refreshBtn = document.getElementById("refresh-btn")!;
  const gwFilterSelect = document.getElementById("gw-filter") as HTMLSelectElement;
  const statsModal = document.getElementById("stats-modal")!;
  const statsModalContent = document.getElementById("stats-modal-content")!;
  const closeStatsModal = document.getElementById("close-stats-modal")!;
  const squadModal = document.getElementById("squad-modal")!;
  const squadModalContent = document.getElementById("squad-modal-content")!;
  const closeSquadModal = document.getElementById("close-squad-modal")!;

  closeStatsModal.addEventListener("click", () => {
    statsModal.classList.remove("is-open");
  });

  closeSquadModal.addEventListener("click", () => {
    squadModal.classList.remove("is-open");
  });

  function populateGWSelector(currentGW: number) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = String(i);
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  function positionLabel(elementType: number): string {
    if (elementType === 1) return "GK";
    if (elementType === 2) return "DEF";
    if (elementType === 3) return "MID";
    return "FWD";
  }

  async function fetchBootstrapData() {
    try {
      const res = await fetch('/api/fpl/bootstrap-static');
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      // Cache player names and team info
      data.elements.forEach((p: any) => {
        playerCache.set(p.id, {
          name: p.web_name,
          position: p.element_type,
          team: p.team
        });
      });

      data.teams.forEach((t: any) => {
        teamCache.set(t.id, {
          name: t.name,
          shortName: t.short_name
        });
      });

      const currentEvent = (data.events || []).find((e: any) => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;
      currentGWFinished = currentEvent ? currentEvent.finished : false;

      populateGWSelector(latestGW);
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
      latestGW = 1;
    }
  }

  async function fetchManagerLiveGwPoints(entryId: number, gw: number): Promise<number> {
    try {
      const picksRes = await fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks`);
      if (!picksRes.ok) {
        throw new Error("Failed to fetch picks data");
      }

      const picksData = await picksRes.json();
      
      // The picks endpoint includes entry_history which has the official GW points
      // This is exactly what the FPL site displays
      const entryHistory = picksData.entry_history;
      if (entryHistory) {
        const points = Number(entryHistory.points) || 0;
        const transferCost = Number(entryHistory.event_transfers_cost) || 0;
        return points - transferCost;
      }

      return 0;
    } catch (e) {
      console.error(`Error fetching live data for manager ${entryId}:`, e);
      return 0;
    }
  }

  async function fetchManagerData(id: number, gw: number): Promise<ManagerData | null> {
    const summaryUrl = `/api/fpl/entry/${id}`;
    const historyUrl = `/api/fpl/entry/${id}/history`;

    try {
      const [summaryRes, historyRes] = await Promise.all([
        fetch(summaryUrl),
        fetch(historyUrl)
      ]);

      if (!summaryRes.ok || !historyRes.ok) throw new Error("Load error");

      const summaryData = await summaryRes.json();
      const historyData = await historyRes.json();

      const current = Array.isArray(historyData?.current) ? historyData.current : [];
      const gwRow = current.find((r: any) => Number(r.event) === Number(gw));

      let gwPoints = gwRow ? Number(gwRow.points) || 0 : 0;
      // For the current GW, always use the picks endpoint for the most up-to-date points
      // The history endpoint can have stale/cached data
      if (gw === latestGW) {
        gwPoints = await fetchManagerLiveGwPoints(id, gw);
      }

      return {
        entryId: Number(id),
        managerName: `${summaryData.player_first_name} ${summaryData.player_last_name}`.trim(),
        teamName: summaryData.name || "",
        totalPoints: Number(summaryData.summary_overall_points) || 0,
        overallRank: Number(summaryData.summary_overall_rank) || 0,
        gwPoints,
        gwRank: gwRow ? Number(gwRow.rank) || 0 : 0,
        teamValue: Number(summaryData.last_deadline_value) || 0,
        bank: Number(summaryData.last_deadline_bank) || 0,
        historyData,
        summaryData
      };
    } catch (e) {
      console.error(`Error fetching manager ${id}:`, e);
      return null;
    }
  }

  function formatRank(rank: number): string {
    if (!rank || rank === 0) return "‚Äî";
    return rank.toLocaleString();
  }

  function formatValue(value: number): string {
    return `¬£${(value / 10).toFixed(1)}m`;
  }

  function makeStatsTable(managersData: ManagerData[], gw: number): string {
    let maxGwPoints = -Infinity;
    managersData.forEach(m => {
      if (m.gwPoints > maxGwPoints) maxGwPoints = m.gwPoints;
    });

    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table stats-table">
            <thead>
              <tr>
                <th class="rank-col">#</th>
                <th>Manager</th>
                <th class="pts-col">GW</th>
                <th class="total-col">Total</th>
                <th class="or-col">OR</th>
              </tr>
            </thead>
            <tbody>
    `;

    let rank = 1;
    for (const m of managersData) {
      const isTopScorer = m.gwPoints === maxGwPoints && maxGwPoints > 0;
      const rowClass = isTopScorer ? 'top-scorer-row' : '';

      html += `
        <tr class="${rowClass}">
          <td class="rank-col">${rank}</td>
          <td class="manager-cell">
            <button type="button" class="manager-btn" data-entry-id="${m.entryId}">
              ${m.managerName}
            </button>
            <div class="team-name">${m.teamName}</div>
          </td>
          <td class="pts-col">${m.gwPoints}</td>
          <td class="total-col">${m.totalPoints.toLocaleString()}</td>
          <td class="or-col">${formatRank(m.overallRank)}</td>
        </tr>
      `;
      rank++;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

    return html;
  }

  
  function calculateSeasonStats(historyData: any, selectedGW: number) {
    const current = Array.isArray(historyData?.current) ? historyData.current : [];
    const chips = Array.isArray(historyData?.chips) ? historyData.chips : [];

    if (current.length === 0) {
      return {
        bestGw: { points: 0, gw: 0 },
        worstGw: { points: 0, gw: 0 },
        bestGwRank: { rank: 0, gw: 0 },
        worstGwRank: { rank: 0, gw: 0 },
        bestOverallRank: { rank: 0, gw: 0 },
        worstOverallRank: { rank: 0, gw: 0 },
        totalTransfers: 0,
        hitCount: 0,
        totalHitsCost: 0,
        chipsUsed: []
      };
    }

    // Determine max GW to consider for worst score
    // If current GW is not finished, exclude it from worst calculations
    const maxGwForWorst = currentGWFinished ? selectedGW : selectedGW - 1;

    let bestGw = { points: -Infinity, gw: 0 };
    let worstGw = { points: Infinity, gw: 0 };
    let bestGwRank = { rank: Infinity, gw: 0 };
    let worstGwRank = { rank: -Infinity, gw: 0 };
    let bestOverallRank = { rank: Infinity, gw: 0 };
    let worstOverallRank = { rank: -Infinity, gw: 0 };
    let totalTransfers = 0;
    let hitCount = 0;
    let totalHitsCost = 0;

    for (const row of current) {
      const pts = Number(row.points) || 0;
      const rank = Number(row.rank) || 0;
      const overallRank = Number(row.overall_rank) || 0;
      const gw = Number(row.event) || 0;
      const hitCost = Number(row.event_transfers_cost) || 0;

      // Best GW - consider all GWs
      if (pts > bestGw.points) {
        bestGw = { points: pts, gw };
      }

      // Worst GW - only consider completed GWs
      if (gw <= maxGwForWorst && pts < worstGw.points) {
        worstGw = { points: pts, gw };
      }

      // Best GW rank - consider all GWs
      if (rank > 0 && rank < bestGwRank.rank) {
        bestGwRank = { rank, gw };
      }

      // Worst GW rank - only consider completed GWs
      if (gw <= maxGwForWorst && rank > worstGwRank.rank) {
        worstGwRank = { rank, gw };
      }

      // Best Overall Rank - consider all GWs (lower is better)
      if (overallRank > 0 && overallRank < bestOverallRank.rank) {
        bestOverallRank = { rank: overallRank, gw };
      }

      // Worst Overall Rank - only consider completed GWs (higher is worse)
      if (gw <= maxGwForWorst && overallRank > worstOverallRank.rank) {
        worstOverallRank = { rank: overallRank, gw };
      }

      totalTransfers += Number(row.event_transfers) || 0;
    
      if (hitCost > 0) {
        hitCount++;
        totalHitsCost += hitCost;
      }
    }

    const chipsUsed = chips.map((c: any) => {
      const chipName = c.name === "wildcard" ? "WC" :
                       c.name === "bboost" ? "BB" :
                       c.name === "3xc" ? "TC" :
                       c.name === "freehit" ? "FH" : c.name;
      return { name: chipName, gw: c.event };
    });

    return {
      bestGw: bestGw.points === -Infinity ? { points: 0, gw: 0 } : bestGw,
      worstGw: worstGw.points === Infinity ? { points: 0, gw: 0 } : worstGw,
      bestGwRank: bestGwRank.rank === Infinity ? { rank: 0, gw: 0 } : bestGwRank,
      worstGwRank: worstGwRank.rank === -Infinity ? { rank: 0, gw: 0 } : worstGwRank,
      bestOverallRank: bestOverallRank.rank === Infinity ? { rank: 0, gw: 0 } : bestOverallRank,
      worstOverallRank: worstOverallRank.rank === -Infinity ? { rank: 0, gw: 0 } : worstOverallRank,
      totalTransfers,
      hitCount,
      totalHitsCost,
      chipsUsed
    };
  }

  async function fetchCaptainData(entryId: number, maxGw: number): Promise<Map<number, number>> {
    const captainCounts = new Map<number, number>();

    const promises = [];
    for (let gw = 1; gw <= maxGw; gw++) {
      promises.push(
        fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks`)
          .then(res => res.ok ? res.json() : null)
          .catch(() => null)
      );
    }

    const results = await Promise.all(promises);

    for (const data of results) {
      if (!data || !data.picks) continue;
      const captain = data.picks.find((p: any) => p.is_captain);
      if (captain) {
        const playerId = captain.element;
        captainCounts.set(playerId, (captainCounts.get(playerId) || 0) + 1);
      }
    }

    return captainCounts;
  }

  function formatCaptainList(captainCounts: Map<number, number>): string {
    if (captainCounts.size === 0) {
      return '<p class="text-muted">No captain data available</p>';
    }

    // Group by count
    const countGroups = new Map<number, string[]>();
    for (const [playerId, count] of captainCounts.entries()) {
      const name = playerCache.get(playerId)?.name || `Player ${playerId}`;
      if (!countGroups.has(count)) {
        countGroups.set(count, []);
      }
      countGroups.get(count)!.push(name);
    }

    // Sort counts descending
    const sortedCounts = Array.from(countGroups.keys()).sort((a, b) => b - a);

    let html = '<div class="captain-list">';
    let rank = 1;
    let displayedPlayers = 0;

    for (const count of sortedCounts) {
      const players = countGroups.get(count)!;
      const isTied = players.length > 1;
      const rankDisplay = isTied ? `${rank}=` : `${rank}`;

      // Show all players with same count in one row if tied
      if (isTied) {
        html += `
          <div class="captain-item captain-item--tied">
            <span class="captain-rank captain-rank--tied">${rankDisplay}</span>
            <span class="captain-name">${players.join(', ')}</span>
            <span class="captain-count">√ó${count}</span>
          </div>
        `;
      } else {
        html += `
          <div class="captain-item">
            <span class="captain-rank">${rank}</span>
            <span class="captain-name">${players[0]}</span>
            <span class="captain-count">√ó${count}</span>
          </div>
        `;
      }

      displayedPlayers += players.length;
      rank += players.length;

      // Stop after showing top 3 positions (but include all ties)
      if (rank > 3 && displayedPlayers >= 3) break;
    }

    html += '</div>';
    return html;
  }

  async function showSquadModal(entryId: number, managerName: string, teamName: string) {
    const gw = parseInt(gwFilterSelect.value) || latestGW;

    squadModalContent.innerHTML = `<p class="text-muted">Loading squad...</p>`;
    squadModal.classList.add("is-open");

    try {
      const [picksRes, historyRes] = await Promise.all([
        fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks`),
        fetch(`/api/fpl/entry/${entryId}/history`)
      ]);

      if (!picksRes.ok) throw new Error("Failed to fetch picks");

      const picksData = await picksRes.json();
      const historyData = await historyRes.json();
      const rawPicks = Array.isArray(picksData.picks) ? picksData.picks : [];

      // Get chip played
      const chips = historyData.chips || [];
      const chipThisGW = chips.find((c: any) => c.event === gw);
      const chipPlayed = chipThisGW ?
        (chipThisGW.name === "wildcard" ? "WC" :
        chipThisGW.name === "bboost" ? "BB" :
        chipThisGW.name === "3xc" ? "TC" :
        chipThisGW.name === "freehit" ? "FH" : "") : "";

      // Get GW points
      const currentHistory = historyData.current || [];
      const gwRow = currentHistory.find((r: any) => Number(r.event) === Number(gw));
      const livePoints = gwRow ? Number(gwRow.points) - (Number(gwRow.event_transfers_cost) || 0) : 0;

      const picks = rawPicks.map((p: any) => {
        const player = playerCache.get(p.element);
        const teamId = player?.team || 0;
        const teamInfo = teamCache.get(teamId);

        return {
          playerId: Number(p.element),
          position: Number(p.position),
          is_captain: !!p.is_captain,
          is_vice_captain: !!p.is_vice_captain,
          web_name: player?.name || "Unknown",
          teamShort: teamInfo?.shortName || "???",
          playingPosition: positionLabel(player?.position || 4),
          multiplier: p.multiplier || 1
        };
      });

      const sorted = [...picks].sort((a, b) => a.position - b.position);
      const starters = sorted.slice(0, 11);
      const bench = sorted.slice(11);

      const chipEmoji = chipPlayed === "WC" ? "üÉè" : 
                        chipPlayed === "BB" ? "ü™ë" : 
                        chipPlayed === "TC" ? "üëë" : 
                        chipPlayed === "FH" ? "üéØ" : "";

      let html = `
        <h2 class="modal-title" style="padding-right:40px;">
          ${managerName}
          ${chipPlayed ? `<span class="badge" style="margin-left:8px;">${chipEmoji} ${chipPlayed}</span>` : ""}
        </h2>
        <p class="text-muted" style="margin-bottom:var(--space-3);">
          ${teamName} ¬∑ GW${gw} ¬∑ <span class="text-success font-bold">${livePoints} pts</span>
        </p>

        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Starting XI</h3>
          <table class="squad-modal-table">
            <thead>
              <tr>
                <th>Player</th>
                <th class="col-team">Team</th>
              </tr>
            </thead>
            <tbody>
      `;

      for (const p of starters) {
        const capLabel = p.is_captain ? '<span class="cap-badge cap-c">C</span>' : 
                         p.is_vice_captain ? '<span class="cap-badge cap-v">V</span>' : '';

        html += `
          <tr>
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <span class="player-name">${p.web_name}</span>
              ${capLabel}
            </td>
            <td class="col-team">${p.teamShort}</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>

        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Bench</h3>
          <table class="squad-modal-table bench-table">
            <tbody>
      `;

      for (const p of bench) {
        html += `
          <tr class="bench-inactive">
            <td class="player-cell">
              <span class="player-pos">${p.playingPosition}</span>
              <span class="player-name">${p.web_name}</span>
            </td>
            <td class="col-team">${p.teamShort}</td>
          </tr>
        `;
      }

      html += `
            </tbody>
          </table>
        </div>
      `;

      squadModalContent.innerHTML = html;

    } catch (error) {
      console.error("Error loading squad:", error);
      squadModalContent.innerHTML = "<p class='status status--error'>Error loading squad data.</p>";
    }
  }

  async function showManagerModal(entryId: number) {
    const manager = allManagerData.find(m => m.entryId === entryId);
    if (!manager) return;

    const gw = parseInt(gwFilterSelect.value) || latestGW;

    // Show loading state
    statsModalContent.innerHTML = `
      <h2 class="modal-title">
        <button type="button" class="manager-name-btn" data-entry-id="${manager.entryId}">${manager.managerName}</button>
      </h2>
      <p class="text-muted">${manager.teamName}</p>
      <div class="stats-loading">
        <p class="text-muted">Loading detailed stats...</p>
      </div>
    `;
    statsModal.classList.add("is-open");

    // Calculate season stats
    const stats = calculateSeasonStats(manager.historyData, gw);

    // Get current GW data
    const current = manager.historyData?.current || [];
    const gwRow = current.find((r: any) => Number(r.event) === Number(gw));
    const gwRank = gwRow ? Number(gwRow.rank) || 0 : 0;

    // Fetch captain data
    const captainCounts = await fetchCaptainData(entryId, gw);
    const captainHtml = formatCaptainList(captainCounts);

    // Build modal content
    let html = `
      <h2 class="modal-title" style="margin-bottom: var(--space-1);">
        <button type="button" class="manager-name-btn" data-entry-id="${manager.entryId}" data-manager-name="${manager.managerName}" data-team-name="${manager.teamName}">${manager.managerName}</button>
      </h2>
      <p class="text-muted" style="margin-bottom: var(--space-3); font-size: 12px;">${manager.teamName}</p>

      <!-- Season Overview -->
      <div class="stats-section">
        <h3 class="stats-section-title">üìä Season Overview</h3>
        <div class="stats-grid stats-grid--compact">
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${manager.totalPoints.toLocaleString()}</span>
            <span class="stat-label">Total Pts</span>
          </div>
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${formatRank(manager.overallRank)}</span>
            <span class="stat-label">OR</span>
          </div>
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${formatValue(manager.teamValue)}</span>
            <span class="stat-label">Value</span>
          </div>
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${formatValue(manager.bank)}</span>
            <span class="stat-label">Bank</span>
          </div>
        </div>
      </div>

      <!-- Current GW -->
      <div class="stats-section">
        <h3 class="stats-section-title">üìÖ Gameweek ${gw}</h3>
        <div class="stats-grid stats-grid--compact stats-grid--half">
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${manager.gwPoints}</span>
            <span class="stat-label">GW Pts</span>
          </div>
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${formatRank(gwRank)}</span>
            <span class="stat-label">GW Rank</span>
          </div>
        </div>
      </div>

      <!-- Highs & Lows -->
      <div class="stats-section">
        <h3 class="stats-section-title">üìà Highs & Lows</h3>
        <div class="stats-grid stats-grid--compact">
          <div class="stat-item stat-item--compact stat-item--success">
            <span class="stat-value">${stats.bestGw.points}</span>
            <span class="stat-label">Best (GW${stats.bestGw.gw})</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--danger">
            <span class="stat-value">${stats.worstGw.gw > 0 ? stats.worstGw.points : '‚Äî'}</span>
            <span class="stat-label">${stats.worstGw.gw > 0 ? `Worst (GW${stats.worstGw.gw})` : 'Worst'}</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--success">
            <span class="stat-value">${formatRank(stats.bestGwRank.rank)}</span>
            <span class="stat-label">Best GW Rank (GW${stats.bestGwRank.gw})</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--danger">
            <span class="stat-value">${stats.worstGwRank.gw > 0 ? formatRank(stats.worstGwRank.rank) : '‚Äî'}</span>
            <span class="stat-label">${stats.worstGwRank.gw > 0 ? `Worst GW Rank (GW${stats.worstGwRank.gw})` : 'Worst GW Rank'}</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--success">
            <span class="stat-value">${formatRank(stats.bestOverallRank.rank)}</span>
            <span class="stat-label">Highest OR (GW${stats.bestOverallRank.gw})</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--danger">
            <span class="stat-value">${stats.worstOverallRank.gw > 0 ? formatRank(stats.worstOverallRank.rank) : '‚Äî'}</span>
            <span class="stat-label">${stats.worstOverallRank.gw > 0 ? `Lowest OR (GW${stats.worstOverallRank.gw})` : 'Lowest OR'}</span>
          </div>
        </div>
      </div>

      <!-- Transfer Activity -->
      <div class="stats-section">
        <h3 class="stats-section-title">üí∏ Transfer Activity</h3>
        <div class="stats-grid stats-grid--compact stats-grid--half">
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${stats.totalTransfers}</span>
            <span class="stat-label">Transfers</span>
          </div>
          <div class="stat-item stat-item--compact ${stats.hitCount > 0 ? 'stat-item--danger' : ''}">
            <span class="stat-value">${stats.hitCount > 0 ? `${stats.hitCount} (-${stats.totalHitsCost})` : '0'}</span>
            <span class="stat-label">Hits</span>
          </div>
        </div>
      </div>

      <!-- Chips -->
      <div class="stats-section">
        <h3 class="stats-section-title">üéÆ Chips Used</h3>
        <div class="chips-row">
          ${stats.chipsUsed.length > 0 
            ? stats.chipsUsed.map((c: any) => `<span class="chip-badge">${c.name} <span class="chip-gw">GW${c.gw}</span></span>`).join('')
            : '<span class="text-muted" style="font-size:12px;">No chips used yet</span>'
          }
        </div>
      </div>

      <!-- Captaincy -->
      <div class="stats-section">
        <h3 class="stats-section-title">üëë Most Captained</h3>
        ${captainHtml}
      </div>
    `;

    statsModalContent.innerHTML = html;

    // Attach click handler for manager name
    const managerNameBtn = statsModalContent.querySelector('.manager-name-btn');
    if (managerNameBtn) {
      managerNameBtn.addEventListener('click', () => {
        showSquadModal(manager.entryId, manager.managerName, manager.teamName);
      });
    }
  }

  function attachManagerButtons() {
    document.querySelectorAll('.manager-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = e.target as HTMLElement;
        const entryId = parseInt(button.dataset.entryId || '0');
        if (entryId) showManagerModal(entryId);
      });
    });
  }

  async function loadStats(ids: number[], gw: number) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    allManagerData = [];
    out.innerHTML = "";
    loadingStatus.textContent = `Loading 0 of ${ids.length}...`;

    let loaded = 0;
    for (const id of ids) {
      try {
        const data = await fetchManagerData(id, gw);
        if (data) {
          allManagerData.push(data);
          loaded++;

          loadingStatus.textContent = `Loading ${loaded} of ${ids.length}...`;

          allManagerData.sort((a, b) => b.totalPoints - a.totalPoints);
          out.innerHTML = makeStatsTable(allManagerData, gw);
          attachManagerButtons();
        }
      } catch (e) {
        console.error(`Failed to load manager ${id}:`, e);
        loaded++;
      }
    }

    loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${loaded} managers</span>`;
  }

  async function updateDisplay() {
    managerCountEl.textContent = `${managerIds.length} managers`;
    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    const gw = parseInt(gwFilterSelect.value) || latestGW;
    await loadStats(managerIds, gw);
  }

  (async function init() {
    await fetchBootstrapData();

    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;

    await updateDisplay();
  })();

  gwFilterSelect.addEventListener('change', async () => {
    const gw = parseInt(gwFilterSelect.value);
    if (gw && gw >= 1 && gw <= 38) {
      await loadStats(managerIds, gw);
    }
  });

  refreshBtn.addEventListener('click', async () => {
    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;
    await updateDisplay();
  });
</script>
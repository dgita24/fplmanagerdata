---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="League Statistics - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">League Statistics</h1>
      <p class="page-subtitle">Official FPL standings and performance stats.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">âš™ Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small">&nbsp;</label>
        <button id="refresh-btn" class="btn-row" type="button">ðŸ”„ Refresh</button>
      </div>
    </div>

    <div id="loading-status" class="meta-row"></div>
    <section id="stats-output" aria-live="polite"></section>
  </main>

  <!-- Manager Stats Modal -->
  <div id="stats-modal" class="modal">
    <div class="modal-panel" style="max-width:550px;">
      <button id="close-stats-modal" class="btn btn--danger btn--small modal-close" type="button">âœ•</button>
      <div id="stats-modal-content"></div>
    </div>
  </div>

  <!-- Squad Modal -->
  <div id="squad-modal" class="modal modal--nested">
    <div class="modal-panel">
      <button id="close-squad-modal" class="btn btn--danger btn--small modal-close" type="button">âœ•</button>
      <div id="squad-modal-content"></div>
    </div>
  </div>

  <!-- OR History Modal -->
  <div id="or-history-modal" class="modal modal--nested">
    <div class="modal-panel modal-panel--or-history">
      <button id="close-or-history-modal" class="btn btn--danger btn--small modal-close" type="button">âœ•</button>
      <div id="or-history-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 36px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .btn-row {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
  }

  .btn-row:hover {
    background: var(--color-primary-hover);
  }

  /* Clickable OR stat tile */
  .stat-item--or {
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .stat-item.stat-item--or:hover {
    background: var(--color-primary-hover);
    transform: translateY(-2px);
  }

  .stat-value--clickable {
    color: var(--color-primary);
  }

  .stat-item--or:hover .stat-value--clickable {
    color: white;
  }

  /* OR History Modal Styles */
  .modal-panel--or-history {
    max-width: 520px;
  }

  .or-history-list {
    display: flex;
    flex-direction: column;
    gap: var(--space-2);
    max-height: 60vh;
    overflow-y: auto;
  }

  .or-history-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-2);
    padding: var(--space-2);
    background: var(--color-surface-alt);
    border-radius: var(--radius-md);
    font-size: 14px;
  }

  .or-history-row:hover {
    background: var(--color-surface);
  }

  .or-history-label {
    font-weight: 600;
    color: var(--color-text-secondary);
  }

  .or-history-value {
    font-weight: 700;
    color: var(--color-text);
    text-align: right;
  }

  .or-modal-title {
    margin-bottom: var(--space-1);
  }

  .or-modal-subtitle {
    margin-bottom: var(--space-3);
    font-size: 12px;
  }
</style>

<script>
  import { supabase } from '../lib/supabase.ts'
  // We only need fetchLiveGW/fetchFixtures for the Modal details now, not the main table
  import { fetchFixtures, fetchLiveGW, getPlayerLiveComputed, type FixtureInfo, type LiveStatLine, type TeamStatus } from '../lib/fplLive.ts'

  const managerStatsCache = new Map<string, any>();

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  let latestGW = 1;
  let currentGWFinished = false;
  let managerIds: number[] = [];
  let allManagerData: ManagerData[] = [];
  let playerCache = new Map<number, { name: string; position: number; team: number }>();
  let teamCache = new Map<number, { name: string; shortName: string }>();
  let livePointsCache = new Map<number, LiveStatLine>();
  let projectedBonusCache = new Map<string, number>();
  let teamStatusCache = new Map<string, TeamStatus>();
  let fixturesCache: FixtureInfo[] = [];
  
  // Load token for cancellation
  let currentLoadToken = 0;

  interface HistoryRow {
    event: number;
    overall_rank: number;
    points?: number;
    rank?: number;
    event_transfers?: number;
    event_transfers_cost?: number;
  }

  interface HistoryData {
    current?: HistoryRow[];
  }

  interface ManagerData {
    entryId: number;
    managerName: string;
    teamName: string;
    totalPoints: number;
    overallRank: number;
    gwPoints: number;
    gwRank: number;
    teamValue: number;
    bank: number;
    historyData: HistoryData;
    summaryData: any;
  }

  const out = document.getElementById("stats-output")!;
  const loadingStatus = document.getElementById("loading-status")!;
  const managerCountEl = document.getElementById("manager-count")!;
  const refreshBtn = document.getElementById("refresh-btn")!;
  const gwFilterSelect = document.getElementById("gw-filter") as HTMLSelectElement;
  const statsModal = document.getElementById("stats-modal")!;
  const statsModalContent = document.getElementById("stats-modal-content")!;
  const closeStatsModal = document.getElementById("close-stats-modal")!;
  const squadModal = document.getElementById("squad-modal")!;
  const squadModalContent = document.getElementById("squad-modal-content")!;
  const closeSquadModal = document.getElementById("close-squad-modal")!;
  const orHistoryModal = document.getElementById("or-history-modal")!;
  const orHistoryModalContent = document.getElementById("or-history-modal-content")!;
  const closeOrHistoryModal = document.getElementById("close-or-history-modal")!;

  closeStatsModal.addEventListener("click", () => {
    statsModal.classList.remove("is-open");
  });

  closeSquadModal.addEventListener("click", () => {
    squadModal.classList.remove("is-open");
  });

  closeOrHistoryModal.addEventListener("click", () => {
    orHistoryModal.classList.remove("is-open");
  });

  function populateGWSelector(currentGW: number) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = String(i);
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  function positionLabel(elementType: number): string {
    if (elementType === 1) return "GK";
    if (elementType === 2) return "DEF";
    if (elementType === 3) return "MID";
    return "FWD";
  }

  /**
   * Concurrent mapping with limited concurrency
   */
  async function mapWithConcurrency<T, R>(
    items: T[],
    limit: number,
    fn: (item: T, index: number) => Promise<R | null>,
    onProgress?: (completed: number, total: number) => void
  ): Promise<(R | null)[]> {
    const results: (R | null)[] = [];
    let currentIndex = 0;
    let completed = 0;

    async function worker() {
      while (currentIndex < items.length) {
        const index = currentIndex++;
        const item = items[index];
        try {
          results[index] = await fn(item, index);
        } catch (e) {
          console.error(`Error processing item ${index}:`, e);
          results[index] = null;
        }
        completed++;
        if (onProgress) {
          onProgress(completed, items.length);
        }
      }
    }

    const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
    await Promise.all(workers);
    return results;
  }

  async function fetchBootstrapData(cacheBuster?: string) {
    try {
      const v = cacheBuster || Date.now().toString();
      const res = await fetch(`/api/fpl/bootstrap-static?v=${v}`);
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      data.elements.forEach((p: any) => {
        playerCache.set(p.id, {
          name: p.web_name,
          position: p.element_type,
          team: p.team
        });
      });

      data.teams.forEach((t: any) => {
        teamCache.set(t.id, {
          name: t.name,
          shortName: t.short_name
        });
      });

      const currentEvent = (data.events || []).find((e: any) => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;
      currentGWFinished = currentEvent ? currentEvent.finished : false;

      populateGWSelector(latestGW);
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
      latestGW = 1;
    }
  }

  async function fetchManagerData(id: number, gw: number, cacheBuster?: string): Promise<ManagerData | null> {
    try {
      // 1. Fetch Basic Summary and History
      let summaryData = managerStatsCache.get(`${id}:summary`);
      let historyData = managerStatsCache.get(`${id}:history`);

      const v = cacheBuster || Date.now().toString();

      if (!summaryData || !historyData) {
        const [summaryRes, historyRes] = await Promise.all([
          !summaryData ? fetch(`/api/fpl/entry/${id}?v=${v}`) : Promise.resolve(null),
          !historyData ? fetch(`/api/fpl/entry/${id}/history?v=${v}`) : Promise.resolve(null)
        ]);

        if ((summaryRes && !summaryRes.ok) || (historyRes && !historyRes.ok)) throw new Error("Load error");

        if (summaryRes) {
          summaryData = await summaryRes.json();
          managerStatsCache.set(`${id}:summary`, summaryData);
        }
        if (historyRes) {
          historyData = await historyRes.json();
          managerStatsCache.set(`${id}:history`, historyData);
        }
      }

      // 2. Determine Points Logic based on Official FPL Site methodology
      // If we are looking at the CURRENT gameweek, we trust summary_overall_points
      // If we are looking at a PAST gameweek, we look at the history array.
      
      const current = Array.isArray(historyData?.current) ? historyData.current : [];
      
      let gwPoints = 0;
      let gwRank = 0;
      let totalPoints = 0;
      let overallRank = 0;
      let teamValue = 0;
      let bank = 0;

      if (gw === latestGW) {
        // === CURRENT GAMEWEEK ===
        // Always use the summary object. This reflects what is on the FPL site "right now".
        // It accounts for hits naturally as FPL updates.
        
        gwPoints = Number(summaryData.summary_event_points) || 0;
        gwRank = Number(summaryData.summary_event_rank) || 0;
        totalPoints = Number(summaryData.summary_overall_points) || 0;
        overallRank = Number(summaryData.summary_overall_rank) || 0;
        teamValue = Number(summaryData.last_deadline_value) || 0;
        bank = Number(summaryData.last_deadline_bank) || 0;

      } else {
        // === PAST GAMEWEEK ===
        // Find the specific row in history
        const gwRow = current.find((r: any) => Number(r.event) === Number(gw));
        
        if (gwRow) {
            gwPoints = Number(gwRow.points) || 0; // Note: In history, this is usually points *after* hits
            gwRank = Number(gwRow.rank) || 0;
            totalPoints = Number(gwRow.total_points) || 0;
            overallRank = Number(gwRow.overall_rank) || 0;
            teamValue = Number(gwRow.value) || 0;
            bank = Number(gwRow.bank) || 0;
        }
      }

      return {
        entryId: Number(id),
        managerName: `${summaryData.player_first_name} ${summaryData.player_last_name}`.trim(),
        teamName: summaryData.name || "",
        totalPoints,
        overallRank,
        gwPoints,
        gwRank,
        teamValue,
        bank,
        historyData,
        summaryData
      };
    } catch (e) {
      console.error(`Error fetching manager ${id}:`, e);
      return null;
    }
  }

  function formatRank(rank: number): string {
    if (!rank || rank === 0) return "â€”";
    return rank.toLocaleString();
  }

  function formatValue(value: number): string {
    return `Â£${(value / 10).toFixed(1)}m`;
  }

  function makeStatsTable(managersData: ManagerData[], gw: number): string {
    // Sort by Total Points (descending) as default for Stats page
    managersData.sort((a, b) => b.totalPoints - a.totalPoints);

    // Find max for highlighting
    let maxGwPoints = -Infinity;
    managersData.forEach(m => {
      if (m.gwPoints > maxGwPoints) maxGwPoints = m.gwPoints;
    });

    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table stats-table">
            <thead>
              <tr>
                <th class="rank-col">#</th>
                <th>Manager</th>
                <th class="pts-col">GW</th>
                <th class="total-col">Total</th>
                <th class="or-col">OR</th>
              </tr>
            </thead>
            <tbody>
    `;

    let rank = 1;
    for (const m of managersData) {
      const isTopScorer = m.gwPoints === maxGwPoints && maxGwPoints > 0;
      const rowClass = isTopScorer ? 'top-scorer-row' : '';

      html += `
        <tr class="${rowClass}">
          <td class="rank-col">${rank}</td>
          <td class="manager-cell">
            <button type="button" class="manager-btn" data-entry-id="${m.entryId}">
              ${m.managerName}
            </button>
            <div class="team-name">${m.teamName}</div>
          </td>
          <td class="pts-col">${m.gwPoints}</td>
          <td class="total-col">${m.totalPoints.toLocaleString()}</td>
          <td class="or-col">${formatRank(m.overallRank)}</td>
        </tr>
      `;
      rank++;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

    return html;
  }

  
  function calculateSeasonStats(historyData: any, selectedGW: number) {
    const current = Array.isArray(historyData?.current) ? historyData.current : [];
    const chips = Array.isArray(historyData?.chips) ? historyData.chips : [];

    if (current.length === 0) {
      return {
        bestGw: { points: 0, gw: 0 },
        worstGw: { points: 0, gw: 0 },
        bestGwRank: { rank: 0, gw: 0 },
        worstGwRank: { rank: 0, gw: 0 },
        bestOverallRank: { rank: 0, gw: 0 },
        worstOverallRank: { rank: 0, gw: 0 },
        totalTransfers: 0,
        hitCount: 0,
        totalHitsCost: 0,
        chipsUsed: []
      };
    }

    const maxGwForWorst = selectedGW; // Allow worst to be current GW

    let bestGw = { points: -Infinity, gw: 0 };
    let worstGw = { points: Infinity, gw: 0 };
    let bestGwRank = { rank: Infinity, gw: 0 };
    let worstGwRank = { rank: -Infinity, gw: 0 };
    let bestOverallRank = { rank: Infinity, gw: 0 };
    let worstOverallRank = { rank: -Infinity, gw: 0 };
    let totalTransfers = 0;
    let hitCount = 0;
    let totalHitsCost = 0;

    for (const row of current) {
      const pts = Number(row.points) || 0;
      const rank = Number(row.rank) || 0;
      const overallRank = Number(row.overall_rank) || 0;
      const gw = Number(row.event) || 0;
      const hitCost = Number(row.event_transfers_cost) || 0;

      // Stats aggregation
      if (pts > bestGw.points) { bestGw = { points: pts, gw }; }
      if (gw <= maxGwForWorst && pts < worstGw.points) { worstGw = { points: pts, gw }; }
      if (rank > 0 && rank < bestGwRank.rank) { bestGwRank = { rank, gw }; }
      if (gw <= maxGwForWorst && rank > 0 && rank > worstGwRank.rank) { worstGwRank = { rank, gw }; }
      if (overallRank > 0 && overallRank < bestOverallRank.rank) { bestOverallRank = { rank: overallRank, gw }; }
      if (gw <= maxGwForWorst && overallRank > 0 && overallRank > worstOverallRank.rank) { worstOverallRank = { rank: overallRank, gw }; }

      totalTransfers += Number(row.event_transfers) || 0;
    
      if (hitCost > 0) {
        hitCount++;
        totalHitsCost += hitCost;
      }
    }

    const chipsUsed = chips.map((c: any) => {
      const chipName = c.name === "wildcard" ? "WC" :
                       c.name === "bboost" ? "BB" :
                       c.name === "3xc" ? "TC" :
                       c.name === "freehit" ? "FH" : c.name;
      return { name: chipName, gw: c.event };
    });

    return {
      bestGw: bestGw.points === -Infinity ? { points: 0, gw: 0 } : bestGw,
      worstGw: worstGw.points === Infinity ? { points: 0, gw: 0 } : worstGw,
      bestGwRank: bestGwRank.rank === Infinity ? { rank: 0, gw: 0 } : bestGwRank,
      worstGwRank: worstGwRank.rank === -Infinity ? { rank: 0, gw: 0 } : worstGwRank,
      bestOverallRank: bestOverallRank.rank === Infinity ? { rank: 0, gw: 0 } : bestOverallRank,
      worstOverallRank: worstOverallRank.rank === -Infinity ? { rank: 0, gw: 0 } : worstOverallRank,
      totalTransfers,
      hitCount,
      totalHitsCost,
      chipsUsed
    };
  }

  async function fetchCaptainData(entryId: number, maxGw: number): Promise<Map<number, number>> {
    const captainCounts = new Map<number, number>();
    const promises = [];
    
    // Limit requests to avoid rate limits if history is long
    for (let gw = 1; gw <= maxGw; gw++) {
      const cacheKey = `${entryId}:${gw}:picks`;
      const cached = managerStatsCache.get(cacheKey);
      
      const v = Date.now();

      if (cached) {
        promises.push(Promise.resolve(cached));
      } else {
        promises.push(
          fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks?v=${v}`)
            .then(async res => {
              if (res.ok) {
                const data = await res.json();
                managerStatsCache.set(cacheKey, data);
                return data;
              }
              return null;
            })
            .catch(() => null)
        );
      }
    }

    const results = await Promise.all(promises);

    for (const data of results) {
      if (!data || !data.picks) continue;
      const captain = data.picks.find((p: any) => p.is_captain);
      if (captain) {
        const playerId = captain.element;
        captainCounts.set(playerId, (captainCounts.get(playerId) || 0) + 1);
      }
    }

    return captainCounts;
  }

  function formatCaptainList(captainCounts: Map<number, number>): string {
    if (captainCounts.size === 0) return '<p class="text-muted">No captain data available</p>';

    const countGroups = new Map<number, string[]>();
    for (const [playerId, count] of captainCounts.entries()) {
      const name = playerCache.get(playerId)?.name || `Player ${playerId}`;
      if (!countGroups.has(count)) countGroups.set(count, []);
      countGroups.get(count)!.push(name);
    }

    const sortedCounts = Array.from(countGroups.keys()).sort((a, b) => b - a);

    let html = '<div class="captain-list">';
    let rank = 1;
    let displayedPlayers = 0;

    for (const count of sortedCounts) {
      const players = countGroups.get(count)!;
      const isTied = players.length > 1;
      const rankDisplay = isTied ? `${rank}=` : `${rank}`;

      if (isTied) {
        html += `
          <div class="captain-item captain-item--tied">
            <span class="captain-rank captain-rank--tied">${rankDisplay}</span>
            <span class="captain-name">${players.join(', ')}</span>
            <span class="captain-count">Ã—${count}</span>
          </div>
        `;
      } else {
        html += `
          <div class="captain-item">
            <span class="captain-rank">${rank}</span>
            <span class="captain-name">${players[0]}</span>
            <span class="captain-count">Ã—${count}</span>
          </div>
        `;
      }

      displayedPlayers += players.length;
      rank += players.length;
      if (rank > 3 && displayedPlayers >= 3) break;
    }

    html += '</div>';
    return html;
  }

  // Keep Squad Modal for drill-down viewing (still helpful to see team)
  async function showSquadModal(entryId: number, managerName: string, teamName: string) {
    const gw = parseInt(gwFilterSelect.value) || latestGW;
    squadModalContent.innerHTML = `<p class="text-muted">Loading squad...</p>`;
    squadModal.classList.add("is-open");

    try {
      let picksData = managerStatsCache.get(`${entryId}:${gw}:picks`);
      const v = Date.now();

      if (!picksData) {
        const res = await fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks?v=${v}`);
        if (res.ok) {
            picksData = await res.json();
            managerStatsCache.set(`${entryId}:${gw}:picks`, picksData);
        }
      }

      const rawPicks = picksData && picksData.picks ? picksData.picks : [];
      
      const picks = rawPicks.map((p: any) => {
        const player = playerCache.get(p.element);
        const teamId = player?.team || 0;
        const teamInfo = teamCache.get(teamId);
        return {
          web_name: player?.name || "Unknown",
          teamShort: teamInfo?.shortName || "???",
          position: p.position,
          playingPosition: positionLabel(player?.position || 4),
          is_captain: p.is_captain,
          is_vice_captain: p.is_vice_captain
        };
      });

      const starters = picks.filter((p:any) => p.position <= 11);
      const bench = picks.filter((p:any) => p.position > 11);

      let html = `
        <h2 class="modal-title" style="padding-right:40px;">${managerName}</h2>
        <p class="text-muted" style="margin-bottom:var(--space-3);">${teamName} Â· GW${gw}</p>
        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Starting XI</h3>
          <table class="squad-modal-table">
            <thead><tr><th>Player</th><th class="col-team">Team</th></tr></thead>
            <tbody>
      `;
      for (const p of starters) {
        const cap = p.is_captain ? '<span class="cap-badge cap-c">C</span>' : p.is_vice_captain ? '<span class="cap-badge cap-v">V</span>' : '';
        html += `<tr><td class="player-cell"><span class="player-pos">${p.playingPosition}</span><span class="player-name">${p.web_name}</span>${cap}</td><td class="col-team">${p.teamShort}</td></tr>`;
      }
      html += `</tbody></table></div>`;
      
      html += `
        <div class="squad-modal-section">
          <h3 class="squad-modal-heading">Bench</h3>
          <table class="squad-modal-table bench-table"><tbody>
      `;
      for (const p of bench) {
        html += `<tr class="bench-inactive"><td class="player-cell"><span class="player-pos">${p.playingPosition}</span><span class="player-name">${p.web_name}</span></td><td class="col-team">${p.teamShort}</td></tr>`;
      }
      html += `</tbody></table></div>`;

      squadModalContent.innerHTML = html;
    } catch (error) {
      squadModalContent.innerHTML = "<p class='status status--error'>Error loading squad.</p>";
    }
  }

  async function showManagerModal(entryId: number) {
    const manager = allManagerData.find(m => m.entryId === entryId);
    if (!manager) return;

    const gw = parseInt(gwFilterSelect.value) || latestGW;

    // Show loading
    statsModalContent.innerHTML = `
      <h2 class="modal-title">${manager.managerName}</h2>
      <div class="stats-loading"><p class="text-muted">Loading detailed stats...</p></div>
    `;
    statsModal.classList.add("is-open");

    const stats = calculateSeasonStats(manager.historyData, gw);
    const captainCounts = await fetchCaptainData(entryId, gw);
    const captainHtml = formatCaptainList(captainCounts);

    let html = `
      <h2 class="modal-title" style="margin-bottom: var(--space-1);">
        <button type="button" class="manager-name-btn" data-entry-id="${manager.entryId}">${manager.managerName}</button>
      </h2>
      <p class="text-muted" style="margin-bottom: var(--space-3); font-size: 12px;">${manager.teamName}</p>

      <!-- Season Overview -->
      <div class="stats-section">
        <h3 class="stats-section-title">ðŸ“Š Season Overview</h3>
        <div class="stats-grid stats-grid--compact">
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${manager.totalPoints.toLocaleString()}</span>
            <span class="stat-label">Total Pts</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--or" data-entry-id="${manager.entryId}">
            <span class="stat-value stat-value--clickable">${formatRank(manager.overallRank)}</span>
            <span class="stat-label">OR</span>
          </div>
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${formatValue(manager.teamValue)}</span>
            <span class="stat-label">Value</span>
          </div>
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${formatValue(manager.bank)}</span>
            <span class="stat-label">Bank</span>
          </div>
        </div>
      </div>

      <!-- Current GW -->
      <div class="stats-section">
        <h3 class="stats-section-title">ðŸ“… Gameweek ${gw}</h3>
        <div class="stats-grid stats-grid--compact stats-grid--half">
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${manager.gwPoints}</span>
            <span class="stat-label">GW Pts</span>
          </div>
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${formatRank(manager.gwRank)}</span>
            <span class="stat-label">GW Rank</span>
          </div>
        </div>
      </div>

      <!-- Highs & Lows -->
      <div class="stats-section">
        <h3 class="stats-section-title">ðŸ“ˆ Highs & Lows</h3>
        <div class="stats-grid stats-grid--compact">
          <div class="stat-item stat-item--compact stat-item--success">
            <span class="stat-value">${stats.bestGw.points}</span>
            <span class="stat-label">Best (GW${stats.bestGw.gw})</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--danger">
            <span class="stat-value">${stats.worstGw.gw > 0 ? stats.worstGw.points : 'â€”'}</span>
            <span class="stat-label">${stats.worstGw.gw > 0 ? `Worst (GW${stats.worstGw.gw})` : 'Worst'}</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--success">
            <span class="stat-value">${formatRank(stats.bestGwRank.rank)}</span>
            <span class="stat-label">Best Rank (GW${stats.bestGwRank.gw})</span>
          </div>
          <div class="stat-item stat-item--compact stat-item--danger">
            <span class="stat-value">${stats.worstGwRank.gw > 0 ? formatRank(stats.worstGwRank.rank) : 'â€”'}</span>
            <span class="stat-label">Worst Rank</span>
          </div>
        </div>
      </div>

      <!-- Transfer Activity -->
      <div class="stats-section">
        <h3 class="stats-section-title">ðŸ’¸ Transfer Activity</h3>
        <div class="stats-grid stats-grid--compact stats-grid--half">
          <div class="stat-item stat-item--compact">
            <span class="stat-value">${stats.totalTransfers}</span>
            <span class="stat-label">Transfers</span>
          </div>
          <div class="stat-item stat-item--compact ${stats.hitCount > 0 ? 'stat-item--danger' : ''}">
            <span class="stat-value">${stats.hitCount > 0 ? `${stats.hitCount} (-${stats.totalHitsCost})` : '0'}</span>
            <span class="stat-label">Hits Taken</span>
          </div>
        </div>
      </div>

      <!-- Chips -->
      <div class="stats-section">
        <h3 class="stats-section-title">ðŸŽ® Chips Used</h3>
        <div class="chips-row">
          ${stats.chipsUsed.length > 0 
            ? stats.chipsUsed.map((c: any) => `<span class="chip-badge">${c.name} <span class="chip-gw">GW${c.gw}</span></span>`).join('')
            : '<span class="text-muted" style="font-size:12px;">No chips used yet</span>'
          }
        </div>
      </div>

      <!-- Captaincy -->
      <div class="stats-section">
        <h3 class="stats-section-title">ðŸ‘‘ Most Captained</h3>
        ${captainHtml}
      </div>
    `;

    statsModalContent.innerHTML = html;
    
    // Re-attach squad click inside modal
    const squadBtn = statsModalContent.querySelector('.manager-name-btn');
    if(squadBtn) {
        squadBtn.addEventListener('click', () => showSquadModal(manager.entryId, manager.managerName, manager.teamName));
    }

    // Attach OR history click
    const orStatBtn = statsModalContent.querySelector('.stat-item--or');
    if(orStatBtn) {
        orStatBtn.addEventListener('click', () => populateORHistoryModal(manager.entryId));
    }
  }

  function populateORHistoryModal(entryId: number) {
    const manager = allManagerData.find(m => m.entryId === entryId);
    if (!manager || !manager.historyData) {
      orHistoryModalContent.innerHTML = '<p class="status status--error">No history data available.</p>';
      orHistoryModal.classList.add('is-open');
      return;
    }

    const current = manager.historyData.current ?? [];
    
    // Filter and sort by gameweek (event), filter out invalid/0 values
    const validHistory = current
      .filter((row: HistoryRow) => row.event && row.overall_rank > 0)
      .sort((a: HistoryRow, b: HistoryRow) => a.event - b.event);

    if (validHistory.length === 0) {
      orHistoryModalContent.innerHTML = '<p class="status status--error">No rank history available.</p>';
      orHistoryModal.classList.add('is-open');
      return;
    }

    let html = `
      <h2 class="modal-title or-modal-title">Overall Rank History</h2>
      <p class="text-muted or-modal-subtitle">${manager.managerName} - ${manager.teamName}</p>
      <div class="or-history-list">
    `;

    for (const row of validHistory) {
      html += `
        <div class="or-history-row">
          <span class="or-history-label">GW ${row.event}</span>
          <span class="or-history-value">${formatRank(row.overall_rank)}</span>
        </div>
      `;
    }

    html += '</div>';

    orHistoryModalContent.innerHTML = html;
    orHistoryModal.classList.add('is-open');
  }

  function attachManagerButtons() {
    document.querySelectorAll('.manager-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = e.target as HTMLElement;
        const entryId = parseInt(button.dataset.entryId || '0');
        if (entryId) showManagerModal(entryId);
      });
    });
  }

  async function loadStats(ids: number[], gw: number) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found.</p>";
      return;
    }

    // Generate load token for cancellation
    const loadToken = ++currentLoadToken;
    
    // Disable refresh button during loading
    refreshBtn.disabled = true;

    allManagerData = [];
    out.innerHTML = "";
    loadingStatus.textContent = `Fetching latest data...`;

    // Generate single cache-buster token for this load
    const cacheBuster = Date.now().toString();

    // Fetch manager data concurrently with limit of 8
    const managerDataResults = await mapWithConcurrency(
      ids,
      8,
      async (id) => {
        return await fetchManagerData(id, gw, cacheBuster);
      },
      (completed, total) => {
        loadingStatus.textContent = `Fetching ${completed}/${total}...`;
      }
    );

    // Check if this load has been superseded
    if (loadToken !== currentLoadToken) {
      console.log('Load superseded, aborting');
      return;
    }

    // Filter out nulls and update allManagerData
    allManagerData = managerDataResults.filter((data): data is ManagerData => data !== null);

    // Render table once at the end
    if (allManagerData.length > 0) {
      allManagerData.sort((a, b) => b.totalPoints - a.totalPoints);
      out.innerHTML = makeStatsTable(allManagerData, gw);
      attachManagerButtons();
    }

    loadingStatus.innerHTML = `<span class='text-success font-bold'>âœ… Loaded ${allManagerData.length} managers</span>`;
    
    // Re-enable refresh button
    refreshBtn.disabled = false;
  }

  async function updateDisplay() {
    managerCountEl.textContent = `${managerIds.length} managers`;
    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured.</p>";
      return;
    }
    const gw = parseInt(gwFilterSelect.value) || latestGW;
    await loadStats(managerIds, gw);
  }

  (async function init() {
    await fetchBootstrapData();
    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;
    await updateDisplay();
  })();

  gwFilterSelect.addEventListener('change', async () => {
    const gw = parseInt(gwFilterSelect.value);
    if (gw) await loadStats(managerIds, gw);
  });

  refreshBtn.addEventListener('click', async () => {
    managerStatsCache.clear();
    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;
    await updateDisplay();
  });
</script>
---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="Manager Squads - FPL Manager Data">
  <Nav />

  <main class="page squads-page-v1">
    <header class="page-header">
      <h1 class="page-title">âš½ Manager Squads âš½</h1>
      <p class="page-subtitle">View each manager's squad for any gameweek.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">âš™ Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="manager-filter">Manager</label>
        <select class="select-small" id="manager-filter">
          <option value="">All</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="view-filter">View</label>
        <select class="select-small" id="view-filter">
          <option value="all">All Players</option>
          <option value="captain">Captains</option>
          <option value="vice">Vice Captains</option>
        </select>
      </div>
    </div>

    <div class="status-row">
      <div id="loading-status" class="status-text"></div>
      <button id="refresh-btn" class="btn-refresh" type="button">ðŸ”„ Refresh</button>
    </div>

    <section id="squads-output" aria-live="polite"></section>
  </main>

  <!-- Player Stats Modal -->
  <div id="player-modal" class="modal modal--nested">
    <div class="modal-panel modal-panel--compact">
      <button id="close-player-modal" class="btn btn--danger btn--small modal-close" type="button">âœ•</button>
      <div id="player-modal-content"></div>
    </div>
  </div>

  <!-- GW Points Modal (nested on top of player modal) -->
  <div id="gw-points-modal" class="modal modal--nested modal--gw-points">
    <div class="modal-panel modal-panel--gw-points">
      <button class="btn btn--danger btn--small modal-close" type="button">âœ•</button>
      <div class="gw-points-modal-content"></div>
    </div>
  </div>

  <!-- Manager History Modal -->
  <div id="manager-history-modal" class="modal modal--nested">
    <div class="modal-panel">
      <button id="close-history-modal" class="btn btn--danger btn--small modal-close" type="button">âœ•</button>
      <div id="history-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 11px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 32px;
    padding: 4px 6px;
    font-family: inherit;
    font-size: 12px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .status-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-2);
  }

  .status-text {
    font-size: var(--text-sm);
    color: var(--color-text-secondary);
  }

  .btn-refresh {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 32px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
    white-space: nowrap;
  }

  .btn-refresh:hover {
    background: var(--color-primary-hover);
  }

  :global(.squad-card) {
    margin-bottom: var(--space-4);
  }

  :global(.squad-header) {
    display: flex; /* Align items in a row */
    justify-content: center;
    align-items: center;
    gap: 8px;
    padding: var(--space-2) var(--space-3);
    background: var(--color-surface-alt);
    border-bottom: 1px solid var(--color-border);
    font-size: var(--text-sm);
  }

  :global(.team-name-span) {
    color: var(--color-text-secondary);
    font-size: 13px;
  }

  :global(.bench-row) {
    background: var(--color-surface-alt);
  }

  :global(.sub-on-row) {
    background: rgb(22 163 74 / 0.1);
  }

  :global(.sub-off-row) {
    background: rgb(220 38 38 / 0.1);
  }

  :global(.dnp-row) {
    background: rgb(220 38 38 / 0.05);
    opacity: 0.7;
  }

  :global(.squad-chip-indicator) {
    text-align: center;
    padding: var(--space-1) var(--space-3);
    font-size: var(--text-sm);
    font-weight: 600;
    color: var(--color-warning);
    border-bottom: 1px solid var(--color-border);
  }

  :global(.player-name-btn) {
    background: none;
    border: none;
    color: var(--color-primary);
    cursor: pointer;
    font-family: inherit;
    font-size: inherit;
    padding: 0;
    text-align: left;
    text-decoration: underline;
    text-decoration-color: transparent;
    transition: text-decoration-color 0.2s;
  }

  :global(.player-name-btn:hover) {
    text-decoration-color: var(--color-primary);
  }

  /* NEW: Specific colors for Captain/Vice */
  /* FIXED: Matched these class names to the script */
  :global(.cap-text-c) {
    color: #22c55e; /* Bold Green */
    font-weight: 800;
  }
  
  :global(.cap-text-vc) {
    color: #f97316; /* Bold Orange */
    font-weight: 800;
  }

  /* UPDATED: Manager Link */
  :global(.manager-link-btn) {
    background: none;
    border: none;
    cursor: pointer;
    font-family: inherit;
    font-size: 16px;
    padding: 0;
    text-decoration: underline;
    text-decoration-color: transparent;
    transition: color 0.2s;
    color: var(--color-warning);
    font-weight: 700;
  }
  
  :global(.manager-link-btn:hover) {
    color: var(--color-warning);
    text-decoration-color: var(--color-warning);
  }

  :global(.squads-page-v1 .squad-table th) {
  font-weight: 700 !important;
  font-size: 13px !important;
  }

  /* Table Columns */
  :global(.pos-col) {
    font-size: var(--text-xs);
    font-weight: 400;
    /* REMOVED: text-transform: uppercase; (This was forcing POS) */
    color: var(--color-text-secondary);
    text-align: center;
    width: 45px; /* Fixed width for mobile */
    white-space: nowrap !important; /* Prevents wrapping */
  }

  /* FIX: Ensure Pos column is centered */
  :global(.squads-page-v1 .squad-table th.pos-col),
  :global(.squads-page-v1 .squad-table td.pos-col) {
    text-align: center !important;
  }

  /* FIX: Ensure Cap column is centered */
  :global(.squads-page-v1 .squad-table th.cap-col),
  :global(.squads-page-v1 .squad-table td.cap-col) {
    text-align: center !important;
  }

  @media (min-width: 640px) {
    :global(.squads-page-v1 table.squad-table) {
      table-layout: fixed !important;
      width: 100% !important;
    }

    :global(.squads-page-v1 .squad-table .pos-num) { width: 60px !important; }
    :global(.squads-page-v1 .squad-table .pos-col) { width: 70px !important; }
    
    /* REDUCED WIDTHS as requested */
    :global(.squads-page-v1 .squad-table .team-col) { width: 70px !important; } /* Reduced from 90 */
    :global(.squads-page-v1 .squad-table .pts-col) { width: 60px !important; }  /* Reduced from 70 */
    :global(.squads-page-v1 .squad-table .cap-col) { width: 50px !important; }

    :global(.squads-page-v1 .squad-table td) {
      overflow-wrap: anywhere;
    }
  }

  @media (max-width: 639px) {
    :global(.squads-page-v1 .squad-table th.cap-col) {
      font-size: 11px !important;
    }

    :global(.squads-page-v1 .squad-table td.player-name) {
      white-space: normal !important;
      word-wrap: break-word !important;
      overflow-wrap: break-word !important;
    }
  }

  /* GW Points Modal Styles */
  .modal--gw-points {
    z-index: 10002; /* Higher than nested player modal */
  }

  .modal-panel--gw-points {
    max-width: 500px; /* Narrower for single column */
    max-height: 85vh;
    overflow: hidden; /* Let wrapper handle scroll */
  }

  :global(.gw-points-title) {
    font-size: 18px;
    font-weight: 700;
    color: var(--color-text);
    margin-bottom: var(--space-3);
    text-align: center;
  }

  :global(.gw-points-table-wrapper) {
    max-height: 60vh;
    overflow-y: auto;
    overflow-x: auto;
  }

  :global(.gw-points-table) {
    width: 100%;
    border-collapse: collapse;
    font-size: 13px;
    min-width: 280px; /* Ensure minimum width for mobile */
  }

  :global(.gw-points-table thead) {
    background: var(--color-surface-alt);
    position: sticky;
    top: 0;
    z-index: 1;
  }

  :global(.gw-points-table th) {
    padding: var(--space-2) var(--space-1);
    text-align: center;
    font-weight: 600;
    color: var(--color-text-secondary);
    border-bottom: 2px solid var(--color-border);
    border-right: 1px solid var(--color-border);
  }

  :global(.gw-points-table th:last-child) {
    border-right: none;
  }

  :global(.gw-points-table td) {
    padding: var(--space-2) var(--space-1);
    border-bottom: 1px solid var(--color-border);
    border-right: 1px solid var(--color-border);
    text-align: center;
  }

  :global(.gw-points-table td:last-child) {
    border-right: none;
  }

  :global(.gw-points-table tbody tr:hover) {
    background: var(--color-surface-alt);
  }

  /* Column-specific styles */
  :global(.gw-points-table .gw-col) {
    font-weight: 600;
    width: 15%;
    min-width: 40px;
  }

  :global(.gw-points-table .opp-col) {
    width: 40%;
    min-width: 90px;
  }

  :global(.gw-points-table .mins-col) {
    width: 20%;
    min-width: 50px;
  }

  :global(.gw-points-table .pts-col) {
    width: 25%;
    min-width: 60px;
    font-weight: 600;
  }

  /* Mobile optimization */
  @media (max-width: 480px) {
    .modal-panel--gw-points {
      max-width: 95vw;
    }

    :global(.gw-points-table) {
      font-size: 12px;
      min-width: 260px;
    }

    :global(.gw-points-table th),
    :global(.gw-points-table td) {
      padding: var(--space-1) 4px;
    }

    :global(.gw-points-title) {
      font-size: 16px;
      margin-bottom: var(--space-2);
    }
  }

  :global(.gw-points-loading),
  :global(.gw-points-error),
  :global(.gw-points-empty) {
    text-align: center;
    padding: var(--space-6);
  }

  :global(.gw-points-loading-text) {
    color: var(--color-text-secondary);
    margin-top: var(--space-2);
  }

  :global(.gw-points-error-text) {
    color: var(--color-danger);
    margin-top: var(--space-2);
  }

  :global(.gw-points-error-details) {
    color: var(--color-text-secondary);
    font-size: 12px;
    margin-top: var(--space-1);
  }

  :global(.gw-points-empty-text) {
    color: var(--color-text-secondary);
    margin-top: var(--space-2);
  }
</style>

<script>
  import { supabase } from '../lib/supabase.ts'
  import { fetchFixtures, fetchLiveGW, getPlayerLiveComputed, getTeamGwStatus, type FixtureInfo, type LiveStatLine, type TeamStatus } from '../lib/fplLive'
  import { initGWPointsModal, makePlayerNameClickable } from '../lib/gwPointsModal.js';

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("squads-output");
  const gwFilterSelect = document.getElementById("gw-filter");
  const managerFilter = document.getElementById("manager-filter");
  const viewFilter = document.getElementById("view-filter");
  const loadingStatus = document.getElementById("loading-status");
  const managerCountEl = document.getElementById("manager-count");
  const refreshBtn = document.getElementById("refresh-btn");

  let managerIds = [];
  let allSquadsData = [];
  let latestGW = 1;
  
  // ==============================
  // Persistent page cache (Squads) - cached until Refresh
  // ==============================
  const SQUADS_SNAPSHOT_KEY = "fpl_squads_snapshot_v1";

  type SquadsSnapshot = {
    savedAt: number;
    managerIds: number[];
    gw: number;
    latestGW: number;
    allSquadsData: any[];
    ui: {
      gwFilter: string;
      managerFilter: string;
      viewFilter: string;
    };
  };
 
  function safeJsonParse(value: string | null) {
    if (!value) return null;
    try { return JSON.parse(value); } catch { return null; }
  }

  function normalizeIds(ids: any): number[] {
    return (Array.isArray(ids) ? ids : []).map((x) => Number(x)).filter((n) => Number.isFinite(n));
  }

  // Order-insensitive compare (cache survives reordering of IDs)
  function sameManagerIds(a: any, b: any) {
    const aa = normalizeIds(a).sort((x, y) => x - y);
    const bb = normalizeIds(b).sort((x, y) => x - y);
    if (aa.length !== bb.length) return false;
    for (let i = 0; i < aa.length; i++) if (aa[i] !== bb[i]) return false;
    return true;
  }

  function loadSquadsSnapshot(): SquadsSnapshot | null {
    return safeJsonParse(localStorage.getItem(SQUADS_SNAPSHOT_KEY));
  }

  function saveSquadsSnapshot(gw: number) {
    const snap: SquadsSnapshot = {
      savedAt: Date.now(),
      managerIds: [...managerIds],
      gw,
      latestGW,
      allSquadsData,
      ui: {
        gwFilter: (gwFilterSelect as HTMLSelectElement).value || "",
        managerFilter: (managerFilter as HTMLSelectElement).value || "",
        viewFilter: (viewFilter as HTMLSelectElement).value || "all",
      },
    };

    try {
      localStorage.setItem(SQUADS_SNAPSHOT_KEY, JSON.stringify(snap));
    } catch (e) {
      console.warn("Could not save squads snapshot", e);
    }
  }

  function renderSquadsFromState() {
    populateManagerFilter();
    renderOutput();
  }


  // Load token for cancellation
  let currentLoadToken = 0;

  let playerCache = new Map();
  let teamCache = new Map();
  let livePointsCache = new Map<number, LiveStatLine>();
  let teamStatusCache = new Map<string, TeamStatus>();
  let projectedBonusCache = new Map<string, number>();
  let fixturesCache: FixtureInfo[] = [];

  // NEW CACHES FOR OPTIMIZATION
  const playerHistoryCache = new Map(); // Global cache for element-summary (playerId -> historyArray)
  const managerPicksCache = new Map(); // Cache for manager picks (managerId:gw -> picksData)

  /**
   * Concurrent mapping with limited concurrency
   */
  async function mapWithConcurrency<T, R>(
    items: T[],
    limit: number,
    fn: (item: T, index: number) => Promise<R | null>,
    onProgress?: (completed: number, total: number) => void
  ): Promise<(R | null)[]> {
    const results: (R | null)[] = [];
    let currentIndex = 0;
    let completed = 0;

    async function worker() {
      while (currentIndex < items.length) {
        const index = currentIndex++;
        const item = items[index];
        try {
          results[index] = await fn(item, index);
        } catch (e) {
          console.error(`Error processing item ${index}:`, e);
          results[index] = null;
        }
        completed++;
        if (onProgress) {
          onProgress(completed, items.length);
        }
      }
    }

    const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
    await Promise.all(workers);
    return results;
  }

  function populateGWSelector(currentGW) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = i;
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  function getTeamGwStatusLocal(teamId, gw) {
    return getTeamGwStatus(teamStatusCache, teamId, gw);
  }

  function getPlayerLiveComputedLocal(playerId, teamId, gw) {
    return getPlayerLiveComputed({
      playerId,
      teamId,
      gw,
      livePointsCache,
      projectedBonusCache,
      teamStatusCache,
      bonusConfirmedOnProvisional: false
    });
  }

  function applyCaptaincyToSquadDisplay(teamPicks, chipCode) {
    const capFactor = (chipCode === "TC") ? 3 : 2;

    const cap = teamPicks.find(p => p.isCaptain);
    const vc = teamPicks.find(p => p.isViceCaptain);

    const capId = cap ? cap.playerId : null;
    const vcId = vc ? vc.playerId : null;

    const capDnp = cap ? !!cap.dnp : true;
    const vcDnp = vc ? !!vc.dnp : true;

    const actingCaptainId =
      (!capDnp && capId !== null) ? capId :
      (!vcDnp && vcId !== null) ? vcId :
      null;

    return teamPicks.map(p => {
      const mult = (actingCaptainId !== null && p.playerId === actingCaptainId) ? capFactor : 1;
      return { ...p, gwPointsCap: (Number(p.gwPoints) || 0) * mult };
    });
  }

  function applyAutoSubsKeepAll(teamPicks, chipCode) {
    const isBB = chipCode === "BB";

    const sorted = [...teamPicks].sort((a, b) => a.position - b.position);
    const starters = sorted.slice(0, 11);
    const bench = sorted.slice(11);

    if (isBB) {
      return sorted.map(p => ({ ...p, subOn: false, subOff: false }));
    }

    let active = starters.filter(p => !p.dnp);
    const benchRemaining = [];

    for (const cand of bench) {
      if (active.length >= 11) {
        benchRemaining.push(cand);
        continue;
      }

      if (cand.dnp) {
        benchRemaining.push(cand);
        continue;
      }

      const gkCount = active.filter(p => p.playerPosition === "GK").length;
      const defCount = active.filter(p => p.playerPosition === "DEF").length;

      const pos = cand.playerPosition;
      const validGK = (pos === "GK" && gkCount === 0);
      const validDefSave = (pos === "DEF" && defCount < 3);
      const validGeneral = (pos !== "GK" && gkCount > 0 && defCount >= 3);

      if (validGK || validDefSave || validGeneral) {
        active = [...active, cand];
      } else {
        benchRemaining.push(cand);
      }
    }

    const activeIds = new Set(active.map(p => p.playerId));

    return sorted.map(p => {
      const wasStarter = p.position <= 11;
      const inXI = activeIds.has(p.playerId);
      return {
        ...p,
        subOn: (!wasStarter && inXI),
        subOff: (wasStarter && !inXI)
      };
    });
  }

  async function fetchBootstrapData(cacheBuster?: string) {
    try {
      const url = cacheBuster
        ? `/api/fpl/bootstrap-static?v=${cacheBuster}`
        : `/api/fpl/bootstrap-static`;

      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      playerCache.clear();
      teamCache.clear();

      data.elements.forEach(player => {
        playerCache.set(player.id, {
          name: player.web_name,
          position: player.element_type === 1 ? "GK" :
                    player.element_type === 2 ? "DEF" :
                    player.element_type === 3 ? "MID" : "FWD",
          teamId: player.team,
          // Season stats:
          totalPoints: player.total_points,
          selectedByPercent: player.selected_by_percent,
          goalsScored: player.goals_scored,
          assists: player.assists,
          cleanSheets: player.clean_sheets,
          penaltiesSaved: player.penalties_saved,
          yellowCards: player.yellow_cards,
          redCards: player.red_cards,
          bonus: player.bonus
        });
      });

      data.teams.forEach(team => {
        teamCache.set(team.id, team.short_name);
      });

      const currentEvent = data.events?.find(e => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;

      populateGWSelector(latestGW);

      return data;
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
      latestGW = 1;
      return null;
    }
  }


  async function fetchSquadForGW(entryId, gw, cacheBuster?: string) {
    try {
      // OPTIMIZATION: Check cache for squad picks
      const cacheKey = `${entryId}:${gw}`;
      let data = managerPicksCache.get(cacheKey);

      if (!data) {
        const url = cacheBuster
          ? `/api/fpl/entry/${entryId}/event/${gw}/picks?v=${cacheBuster}`
          : `/api/fpl/entry/${entryId}/event/${gw}/picks`;

        const res = await fetch(url);
        if (!res.ok) throw new Error("Failed to fetch picks");
        data = await res.json();
        managerPicksCache.set(cacheKey, data);
      }

      const picks = data.picks || [];

      return picks.map(pick => {
        const info = playerCache.get(pick.element) || { name: "Unknown", position: "?", teamId: 0 };
        const teamName = teamCache.get(info.teamId) || "???";

        const computed = getPlayerLiveComputedLocal(pick.element, info.teamId, gw);

        return {
          position: Number(pick.position),
          playerId: Number(pick.element),
          playerName: info.name,
          playerPosition: info.position,
          teamId: info.teamId,
          teamName,

          isCaptain: !!pick.is_captain,
          isViceCaptain: !!pick.is_vice_captain,

          minutes: computed.minutes,
          status: computed.status,
          dnp: (computed.minutes === 0 && computed.status === "Fin"),

          gwPoints: Math.trunc(Number(computed.liveTotal) || 0),

          subOn: false,
          subOff: false
        };
      });
    } catch (e) {
      console.error(`Error fetching squad for ${entryId} GW${gw}:`, e);
      return [];
    }
  }


  async function fetchManagerData(entryId, gw, cacheBuster?: string) {
    try {
      const summaryUrl = cacheBuster
        ? `/api/fpl/entry/${entryId}?v=${cacheBuster}`
        : `/api/fpl/entry/${entryId}`;

      const historyUrl = cacheBuster
        ? `/api/fpl/entry/${entryId}/history?v=${cacheBuster}`
        : `/api/fpl/entry/${entryId}/history`;

      const [summaryRes, historyRes] = await Promise.all([
        fetch(summaryUrl),
        fetch(historyUrl)
      ]);

      if (!summaryRes.ok || !historyRes.ok) throw new Error("Failed to fetch manager data");

      const summaryData = await summaryRes.json();
      const historyData = await historyRes.json();

      const managerName = `${summaryData.player_first_name} ${summaryData.player_last_name}`;
      const teamName = summaryData.name;

      const chips = historyData.chips || [];
      const chipThisGW = chips.find(c => c.event === gw);
      const chipPlayed = chipThisGW ?
        (chipThisGW.name === "wildcard" ? "WC" :
        chipThisGW.name === "bboost" ? "BB" :
        chipThisGW.name === "3xc" ? "TC" :
        chipThisGW.name === "freehit" ? "FH" : chipThisGW.name) : "";

      const squadRaw = await fetchSquadForGW(entryId, gw, cacheBuster);
      const squadWithIndicators = applyAutoSubsKeepAll(squadRaw, chipPlayed || "None");
      const squad = applyCaptaincyToSquadDisplay(squadWithIndicators, chipPlayed || "None");

      return {
        entryId,
        managerName,
        teamName,
        chipPlayed,
        squad
      };
    } catch (e) {
      console.error(`Error fetching manager ${entryId}:`, e);
      return null;
    }
  }

  function populateManagerFilter() {
    managerFilter.innerHTML = '<option value="">All</option>';

    const sortedManagers = [...allSquadsData].sort((a, b) =>
      a.managerName.localeCompare(b.managerName)
    );

    for (const manager of sortedManagers) {
      const option = document.createElement('option');
      option.value = manager.entryId;
      option.textContent = manager.managerName;
      managerFilter.appendChild(option);
    }
  }

  function getChipFullName(chipCode) {
    switch (chipCode) {
      case "WC": return "Wildcard";
      case "FH": return "Free Hit";
      case "BB": return "Bench Boost";
      case "TC": return "Triple Captain";
      default: return chipCode;
    }
  }

  function makeCaptainTable(squadsData, managerFilterValue = "", viewType = "captain") {
    let filteredManagers = squadsData;

    if (managerFilterValue) {
      filteredManagers = squadsData.filter(m => m.entryId.toString() === managerFilterValue);
    }

    const isCaptainView = viewType === "captain";

    // Collect captain/vc data
    const rows = [];
    for (const manager of filteredManagers) {
      const target = manager.squad.find(p => isCaptainView ? p.isCaptain : p.isViceCaptain);
      if (target) {
        rows.push({
          managerName: manager.managerName,
          chipPlayed: manager.chipPlayed,
          playerId: target.playerId,
          playerName: target.playerName,
          teamName: target.teamName,
          points: target.gwPointsCap ?? target.gwPoints,
          rawPoints: target.gwPoints,
          isCaptain: target.isCaptain,
          isViceCaptain: target.isViceCaptain
        });
      }
    }

    // Sort by points descending
    rows.sort((a, b) => b.points - a.points);

    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table captain-table">
            <thead>
              <tr>
                <th>Manager</th>
                <th>Player</th>
                <th class="team-col">Team</th>
                <th class="pts-col">Pts</th>
              </tr>
            </thead>
            <tbody>
    `;

    for (const row of rows) {
      const chipBadge = row.chipPlayed ? `<span class="badge" style="margin-left:4px;font-size:9px;padding:1px 4px;">${row.chipPlayed}</span>` : '';

      html += `
        <tr>
          <td class="manager-cell">${row.managerName}${chipBadge}</td>
          <td class="player-cell">
            <button type="button" class="player-name-btn" data-player-id="${row.playerId}">${row.playerName}</button>
          </td>
          <td class="team-col">${row.teamName}</td>
          <td class="pts-col">${row.points}</td>
        </tr>
      `;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

    return html;
  }

  function makeSquadsDisplay(squadsData, managerFilterValue = "") {
    let filteredManagers = squadsData;

    if (managerFilterValue) {
      filteredManagers = squadsData.filter(m => m.entryId.toString() === managerFilterValue);
    }

    let html = "";

    for (const manager of filteredManagers) {
      const squad = [...(manager.squad || [])].sort((a, b) => a.position - b.position);

      html += `
        <div class="card squad-card">
          <!-- UPDATED HEADER: Centered with Dash -->
          <div class="squad-header">
            <button class="manager-link-btn" data-manager-id="${manager.entryId}">${manager.managerName}</button>
            <span class="team-name-span">â€” ${manager.teamName}</span>
          </div>
          ${manager.chipPlayed ? `<div class="squad-chip-indicator">${getChipFullName(manager.chipPlayed)} played</div>` : ''}
          <div class="table-scroll">
            <table class="data-table squad-table">
              <thead>
                <tr>
                  <th class="num pos-num">#</th>
                  <th class="pos-col">Pos</th> <!-- Explicit "Pos" text -->
                  <th>Player</th>
                  <th class="num cap-col">C/VC</th>
                  <th class="num team-col">Team</th>
                  <th class="num pts-col">Pts</th>                 
                </tr>
              </thead>
              <tbody>
      `;

      for (const player of squad) {
        const isBench = player.position > 11;
        
        let rowClass = "";
        if (player.subOn) rowClass = "sub-on-row";
        else if (player.subOff) rowClass = "sub-off-row";
        else if (player.dnp) rowClass = "dnp-row";
        else if (isBench) rowClass = "bench-row";

        let captainLabel = "";
        let captainClass = "";
        
        if (player.isCaptain) {
            captainLabel = "C";
            captainClass = "cap-text-c";
        } else if (player.isViceCaptain) {
            captainLabel = "VC";
            captainClass = "cap-text-vc";
        }

        let statusBadge = "";
        if (player.subOn) statusBadge = `<span class="badge badge--success" style="font-size:9px;padding:1px 4px;margin-left:4px;">ON</span>`;
        else if (player.subOff) statusBadge = `<span class="badge badge--danger" style="font-size:9px;padding:1px 4px;margin-left:4px;">OFF</span>`;
        else if (player.dnp) statusBadge = `<span class="badge" style="font-size:9px;padding:1px 4px;margin-left:4px;">DNP</span>`;

        html += `
          <tr class="${rowClass}">
            <td class="num pos-num">${player.position}</td>
            <td class="pos-col">${player.playerPosition}</td>
            <td class="player-name">
              <button type="button" class="player-name-btn" data-player-id="${player.playerId}">${player.playerName}</button>
              ${statusBadge}
            </td>
            <td class="num cap-col ${captainClass}">${captainLabel}</td>
            <td class="num team-col">${player.teamName}</td>
            <td class="num pts-col">${player.gwPointsCap ?? player.gwPoints}</td>
          </tr>
        `;
      }

      html += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    }

    if (!html) {
      html = "<p class='text-muted'>No squads to display.</p>";
    }

    return html;
  }
  // --- UPGRADE 2: Manager History Modal (Optimized) ---
  async function showManagerHistoryModal(managerId) {
    const managerNameBtn = document.querySelector(`.manager-link-btn[data-manager-id="${managerId}"]`);
    const managerName = managerNameBtn ? managerNameBtn.textContent : "Manager";
    
    const historyModalContent = document.getElementById("history-modal-content");
    const historyModal = document.getElementById("manager-history-modal");
    
    historyModalContent.innerHTML = `
      <h2 class="modal-title">${managerName}</h2>
      <div class="stats-loading">
        <p class="text-muted">Calculating points breakdown...</p>
        <p class="text-muted" style="font-size:11px;">Fetching history for GW1 to GW${latestGW}...</p>
      </div>
    `;
    historyModal.classList.add("is-open");

    try {
        const maxGw = latestGW; 
        if (maxGw < 1) throw new Error("Season not started");

        // 1. Fetch ALL picks for this manager (Parallel & Cached)
        const pickPromises = [];
        for(let i=1; i<=maxGw; i++) {
            const cacheKey = `${managerId}:${i}`;
            if (managerPicksCache.has(cacheKey)) {
                pickPromises.push(Promise.resolve(managerPicksCache.get(cacheKey)));
            } else {
                pickPromises.push(
                    fetch(`/api/fpl/entry/${managerId}/event/${i}/picks`)
                    .then(r => {
                        if (r.ok) return r.json();
                        return null;
                    })
                    .then(data => {
                        if (data) managerPicksCache.set(cacheKey, data);
                        return data;
                    })
                );
            }
        }
        
        // 2. Fetch Manager History
        const historyPromise = fetch(`/api/fpl/entry/${managerId}/history`).then(r => r.ok ? r.json() : null);

        const [picksResults, historyData] = await Promise.all([Promise.all(pickPromises), historyPromise]);
        
        // 3. Identify ALL unique players owned
        const uniquePlayerIds = new Set();
        picksResults.forEach(p => {
            if(p && p.picks) p.picks.forEach(pick => uniquePlayerIds.add(pick.element));
        });

        // 4. Fetch per-gameweek stats for ONLY these players (Parallel & Cached)
        const playerHistoryMap = new Map(); // key: playerId, val: array of GW stats
        const playerPromises = [];
        
        for (const pid of uniquePlayerIds) {
            if (playerHistoryCache.has(pid)) {
                playerHistoryMap.set(pid, playerHistoryCache.get(pid));
            } else {
                playerPromises.push(
                    fetch(`/api/fpl/element-summary/${pid}`)
                    .then(r => r.ok ? r.json() : null)
                    .then(data => {
                        if (data && data.history) {
                            playerHistoryCache.set(pid, data.history); // Cache it globally
                            playerHistoryMap.set(pid, data.history);
                        }
                    })
                );
            }
        }
        
        await Promise.all(playerPromises);

        // 5. THE CALCULATION LOOP
        const playerTotals = new Map(); // key: pid, val: { games, points, name, team, pos }

        for (const pid of uniquePlayerIds) {
            const pInfo = playerCache.get(pid);
            if(pInfo) {
                playerTotals.set(pid, {
                    name: pInfo.name,
                    pos: pInfo.position,
                    team: teamCache.get(pInfo.teamId) || "",
                    games: 0,
                    points: 0,
                    currentlyOwned: false
                });
            }
        }

        for(let i=0; i<picksResults.length; i++) {
            const gw = i + 1;
            const pickData = picksResults[i];
            if (!pickData) continue;

            const chipName = (historyData.chips || []).find(c => c.event === gw)?.name;
            const isBB = chipName === "bboost";
            const isTC = chipName === "3xc";

            const teamPicks = pickData.picks.map(p => {
                const pHist = playerHistoryMap.get(p.element);
                const gwStats = pHist ? pHist.find(h => h.round === gw) : null;
                const minutes = gwStats ? gwStats.minutes : 0;
                
                return {
                    position: p.position,
                    playerId: p.element,
                    isCaptain: p.is_captain,
                    isViceCaptain: p.is_vice_captain,
                    playerPosition: playerCache.get(p.element)?.position || "MID",
                    dnp: minutes === 0
                };
            });

            const squadWithSubs = applyAutoSubsKeepAll(teamPicks, chipName || "None");

            for (const p of squadWithSubs) {
                const stats = playerTotals.get(p.playerId);
                if (!stats) continue;

                if (gw === maxGw) stats.currentlyOwned = true;

                const isStarter = p.position <= 11;
                const played = (isStarter && !p.subOff) || p.subOn || (isBB && !isStarter);

                if (played) {
                    stats.games++;
                    
                    const pHist = playerHistoryMap.get(p.playerId);
                    const gwStats = pHist ? pHist.find(h => h.round === gw) : null;
                    const rawPoints = gwStats ? gwStats.total_points : 0;

                    let multiplier = 1;
                    if (p.isCaptain && !p.dnp) multiplier = isTC ? 3 : 2;
                    else if (p.isViceCaptain && !p.dnp && squadWithSubs.find(s => s.isCaptain)?.dnp) multiplier = isTC ? 3 : 2;

                    stats.points += (rawPoints * multiplier);
                }
            }
        }

        // 6. Build UI
        const rows = Array.from(playerTotals.values());
        
        rows.sort((a, b) => b.points - a.points);

        const totalPointsSum = rows.reduce((acc, r) => acc + r.points, 0);

        let html = `
            <h2 class="modal-title">${managerName}</h2>
            <p class="text-muted" style="margin-bottom:1rem;">
                Contribution History (GW1 - GW${maxGw}) <br>
                <span class="text-success">Total Contributed: ${totalPointsSum} pts</span>
            </p>
            
            <div class="table-container" style="max-height: 50vh; overflow-y:auto;">
                <table class="data-table">
                    <thead>
                        <tr>
                            <th style="text-align:left;">Player</th>
                            <th style="text-align:center;">Pos</th>
                            <th style="text-align:center;">Games</th>
                            <th style="text-align:center;">Pts</th>
                        </tr>
                    </thead>
                    <tbody>
        `;

        for (const r of rows) {
            if (r.points === 0 && r.games === 0) continue; 

            const rowStyle = r.currentlyOwned ? "font-weight:600;" : "";

            html += `
                <tr style="${rowStyle}">
                    <td class="player-cell">
                        ${r.name} 
                        <span class="text-muted" style="font-size:10px;">${r.team}</span>
                    </td>
                    <td style="text-align:center;">${r.pos}</td>
                    <td style="text-align:center;">${r.games}</td>
                    <td style="text-align:center;" class="points-positive">${r.points}</td>
                </tr>
            `;
        }

        html += `
                    </tbody>
                </table>
            </div>
        `;
        
        historyModalContent.innerHTML = html;

    } catch (e) {
        console.error(e);
        historyModalContent.innerHTML = `<p class="status status--error">Error calculating history.</p>`;
    }
  }

  async function fetchPlayerDefconStats(playerId: number): Promise<{ totalDefcon: number; gamesWithDefcon: number }> {
    try {
      const { data, error } = await supabase
        .from('player_defensive_stats')
        .select('defcon_points')
        .eq('player_id', playerId);
      
      if (error || !data) return { totalDefcon: 0, gamesWithDefcon: 0 };
      
      const totalDefcon = data.reduce((sum, row) => sum + (row.defcon_points || 0), 0);
      const gamesWithDefcon = data.filter(row => row.defcon_points > 0).length;
      
      return { totalDefcon, gamesWithDefcon };
    } catch (e) {
      console.error('Error fetching DEFCON stats:', e);
      return { totalDefcon: 0, gamesWithDefcon: 0 };
    }
  }

  // FPL Point Calculation Helper Functions
  function getGoalPoints(position, goals) {
    if (!goals) return 0;
    const pointsPerGoal = position === "GK" || position === "DEF" ? 6 :
                          position === "MID" ? 5 : 4;
    return goals * pointsPerGoal;
  }

  function getAssistPoints(assists) {
    return (assists || 0) * 3;
  }

  function getCleanSheetPoints(position, cleanSheets) {
    if (!cleanSheets) return 0;
    const pointsPerCleanSheet = position === "GK" || position === "DEF" ? 4 :
                                position === "MID" ? 1 : 0;
    return cleanSheets * pointsPerCleanSheet;
  }

  function getPenaltySavedPoints(penaltiesSaved) {
    return (penaltiesSaved || 0) * 5;
  }

  function getYellowCardPoints(yellowCards) {
    return (yellowCards || 0) * -1;
  }

  function getRedCardPoints(redCards) {
    return (redCards || 0) * -3;
  }

  function formatPoints(points) {
    if (points === 0) return "â€”";
    return points > 0 ? `+${points}` : `${points}`;
  }

  function getPointsClass(points) {
    if (points > 0) return "points-positive";
    if (points < 0) return "points-negative";
    return "";
  }

  async function showPlayerModal(playerId) {
    const player = playerCache.get(playerId);
    
    if (!player) {
      const playerModalContent = document.getElementById("player-modal-content");
      const playerModal = document.getElementById("player-modal");
      playerModalContent.innerHTML = "<p class='status status--error'>Player not found.</p>";
      playerModal.classList.add("is-open");
      return;
    }

    const teamName = teamCache.get(player.teamId) || "???";
    
    // Fetch DEFCON stats for outfield players
    const isOutfieldPlayer = player.position !== "GK";
    let defconStats = { totalDefcon: 0, gamesWithDefcon: 0 };
    if (isOutfieldPlayer) {
      defconStats = await fetchPlayerDefconStats(playerId);
    }

    // Calculate FPL points for each stat
    const goalPoints = getGoalPoints(player.position, player.goalsScored);
    const assistPoints = getAssistPoints(player.assists);
    const cleanSheetPoints = getCleanSheetPoints(player.position, player.cleanSheets);
    const penaltySavedPoints = getPenaltySavedPoints(player.penaltiesSaved);
    const yellowCardPoints = getYellowCardPoints(player.yellowCards);
    const redCardPoints = getRedCardPoints(player.redCards);
    const bonusPoints = player.bonus || 0;

    let html = `
      <div class="player-modal-header">
        <div class="player-modal-info">
          <h2 class="player-modal-name">${player.name}</h2>
          <div class="player-modal-meta">
            <span class="player-modal-team">${teamName}</span>
            <span class="player-modal-pos">${player.position}</span>
          </div>
        </div>
        <div class="player-modal-points">
          <span class="player-modal-total">${player.totalPoints || 0}</span>
          <span class="player-modal-pts-label">pts</span>
        </div>
      </div>

      <div class="player-modal-breakdown">
        <h3 class="player-modal-section-title">Season Statistics</h3>
        <div class="breakdown-list">
          <div class="breakdown-row">
            <span class="breakdown-label">Total Points</span>
            <span class="breakdown-value">${player.totalPoints || 0}</span>
            <span class="breakdown-points">â€”</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Selected By</span>
            <span class="breakdown-value">${player.selectedByPercent || 0}%</span>
            <span class="breakdown-points">â€”</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Goals Scored</span>
            <span class="breakdown-value">${player.goalsScored || 0}</span>
            <span class="breakdown-points ${getPointsClass(goalPoints)}">${formatPoints(goalPoints)}</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Assists</span>
            <span class="breakdown-value">${player.assists || 0}</span>
            <span class="breakdown-points ${getPointsClass(assistPoints)}">${formatPoints(assistPoints)}</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Clean Sheets</span>
            <span class="breakdown-value">${player.cleanSheets || 0}</span>
            <span class="breakdown-points ${getPointsClass(cleanSheetPoints)}">${formatPoints(cleanSheetPoints)}</span>
          </div>
          ${player.position === "GK" ? `
          <div class="breakdown-row">
            <span class="breakdown-label">Penalties Saved</span>
            <span class="breakdown-value">${player.penaltiesSaved || 0}</span>
            <span class="breakdown-points ${getPointsClass(penaltySavedPoints)}">${formatPoints(penaltySavedPoints)}</span>
          </div>
          ` : ''}
          ${isOutfieldPlayer && defconStats.totalDefcon > 0 ? `
          <div class="breakdown-row">
            <span class="breakdown-label">DEFCON Points</span>
            <span class="breakdown-value">${defconStats.gamesWithDefcon} games</span>
            <span class="breakdown-points points-positive">+${defconStats.totalDefcon}</span>
          </div>
          ` : ''}
          <div class="breakdown-row">
            <span class="breakdown-label">Yellow Cards</span>
            <span class="breakdown-value">${player.yellowCards || 0}</span>
            <span class="breakdown-points ${getPointsClass(yellowCardPoints)}">${formatPoints(yellowCardPoints)}</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Red Cards</span>
            <span class="breakdown-value">${player.redCards || 0}</span>
            <span class="breakdown-points ${getPointsClass(redCardPoints)}">${formatPoints(redCardPoints)}</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Bonus Points</span>
            <span class="breakdown-value">${player.bonus || 0}</span>
            <span class="breakdown-points ${getPointsClass(bonusPoints)}">${formatPoints(bonusPoints)}</span>
          </div>
        </div>
      </div>
    `;

    const playerModalContent = document.getElementById("player-modal-content");
    const playerModal = document.getElementById("player-modal");
    playerModalContent.innerHTML = html;
    playerModal.classList.add("is-open");
    
    // Make player name clickable to show GW points
    const playerNameEl = playerModalContent.querySelector('.player-modal-name');
    if (playerNameEl && gwPointsModal) {
      makePlayerNameClickable(playerNameEl, playerId, player.name, gwPointsModal, teamCache);
    }
  }

  function attachPlayerButtons() {
    document.querySelectorAll('.player-name-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = e.target as HTMLElement;
        const playerId = parseInt(button.dataset.playerId || '0');
        if (playerId) showPlayerModal(playerId);
      });
    });
  }

  // --- UPGRADE: Attach Manager Link Buttons ---
  function attachManagerLinkButtons() {
    document.querySelectorAll('.manager-link-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = e.target as HTMLElement;
        const managerId = parseInt(button.dataset.managerId || '0');
        if (managerId) showManagerHistoryModal(managerId);
      });
    });
  }

  function renderOutput() {
    const viewType = viewFilter.value;
    const managerFilterValue = managerFilter.value;

    if (viewType === "captain" || viewType === "vice") {
      out.innerHTML = makeCaptainTable(allSquadsData, managerFilterValue, viewType);
    } else {
      out.innerHTML = makeSquadsDisplay(allSquadsData, managerFilterValue);
    }
    
    attachPlayerButtons();
    attachManagerLinkButtons(); // Bind the new clicks
  }

  async function loadSquads(ids, gw, opts?: { force?: boolean }) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    if (!gw) {
      out.innerHTML = "<p class='status status--warning'>Please select a gameweek.</p>";
      return;
    }

    const force = !!opts?.force;

    // Generate load token for cancellation
    const loadToken = ++currentLoadToken;

    // Disable refresh button during loading
    refreshBtn.disabled = true;

    allSquadsData = [];
    out.innerHTML = "";
   loadingStatus.textContent = `Fetching latest data...`;

    // Only bust caches when force=true (Refresh button)
    const cacheBuster = force ? Date.now().toString() : undefined;

    // Fetch fixtures and live GW data first
    try {
      await Promise.all([
        fetchFixtures({ gw, fixturesCache, projectedBonusCache, teamStatusCache, includeFinishedProvisional: false, cacheBuster }),
        fetchLiveGW({ gw, livePointsCache, cacheBuster })
      ]);
    } catch (e) {
      console.error("Failed to load live caches:", e);
      out.innerHTML = "<p class='status status--error'>Failed to load live data. Try refresh.</p>";
      loadingStatus.textContent = "";
      refreshBtn.disabled = false;
      return;
    }

    if (loadToken !== currentLoadToken) {
      console.log("Load superseded, aborting");
      return;
    }

    const squadResults = await mapWithConcurrency(
      ids,
      8,
      async (id) => {
        try {
          return await fetchManagerData(id, gw, cacheBuster);
        } catch (e) {
          console.error(`Failed to load manager ${id}:`, e);
          return null;
        }
      },
      (completed, total) => {
        loadingStatus.textContent = `Fetching ${completed}/${total}...`;
      }
    );

    if (loadToken !== currentLoadToken) {
      console.log("Load superseded after fetching managers, aborting");
      return;
    }

    allSquadsData = squadResults.filter((data) => data !== null);

    // Render
    renderSquadsFromState();

    loadingStatus.innerHTML = `<span class="text-success font-bold">âœ… Loaded ${allSquadsData.length} managers for GW${gw}</span>`;

    // Persist snapshot
    saveSquadsSnapshot(gw);

    refreshBtn.disabled = false;
  }


  async function init() {
    loadingStatus.textContent = "Loading...";

    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (authenticated === false) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    // Try cached render first (no network)
    const snap = loadSquadsSnapshot();

    if (
      snap &&
      sameManagerIds(snap.managerIds, managerIds) &&
      Array.isArray(snap.allSquadsData) &&
      snap.allSquadsData.length > 0
    ) {
      allSquadsData = snap.allSquadsData;
      latestGW = snap.latestGW || latestGW;

      populateGWSelector(latestGW);

      if (typeof snap.ui?.gwFilter === "string" && snap.ui.gwFilter) {
        gwFilterSelect.value = snap.ui.gwFilter;
      } else {
        gwFilterSelect.value = String(snap.gw || latestGW);
      }

      if (typeof snap.ui?.managerFilter === "string") {
        managerFilter.value = snap.ui.managerFilter;
      }
      if (typeof snap.ui?.viewFilter === "string") {
        viewFilter.value = snap.ui.viewFilter;
      }

      renderSquadsFromState();
      loadingStatus.textContent = "Loaded from cache.";
      return;
    }

    // No cache -> one normal load (not forced)
    loadingStatus.textContent = "Loading player data...";
    await fetchBootstrapData();

    await updateDisplay();
  }


  async function updateDisplay() {
    managerCountEl.textContent = `${managerIds.length} managers`;
    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    const urlParams = new URLSearchParams(window.location.search);
    const managerParam = urlParams.get('manager');

    const gw = parseInt(gwFilterSelect.value) || latestGW;

    if (managerParam) {
      const managerId = parseInt(managerParam);
      await loadSquads([managerId], gw, { force: false });


      const checkAndSetFilter = () => {
        if (managerFilter.options.length > 1) {
          managerFilter.value = managerId.toString();
        } else {
          setTimeout(checkAndSetFilter, 50);
        }
      };
      setTimeout(checkAndSetFilter, 50);
    } else {
      await loadSquads(managerIds, gw, { force: false });
    }
  }

  gwFilterSelect.addEventListener("change", async () => {
    const gw = parseInt(gwFilterSelect.value as any);
    if (!(gw && gw >= 1 && gw <= 38)) return;

    const snap = loadSquadsSnapshot();
    if (
      snap &&
      sameManagerIds(snap.managerIds, managerIds) &&
      Number(snap.gw) === Number(gw) &&
      Array.isArray(snap.allSquadsData) &&
      snap.allSquadsData.length > 0
    ) {
      allSquadsData = snap.allSquadsData;
      renderSquadsFromState();
      loadingStatus.textContent = "Loaded from cache.";
      return;
    }

    await loadSquads(managerIds, gw, { force: false });
  });

  managerFilter.addEventListener("change", () => {
    renderOutput();
    const gw = parseInt(gwFilterSelect.value as any) || latestGW;
    saveSquadsSnapshot(gw);
  });


  viewFilter.addEventListener("change", () => {
    renderOutput();
    const gw = parseInt(gwFilterSelect.value as any) || latestGW;
    saveSquadsSnapshot(gw);
  });

  refreshBtn.addEventListener("click", async () => {
    localStorage.removeItem(SQUADS_SNAPSHOT_KEY);

    // Also clear these two so refresh truly refetches picks/element-summary where needed
    managerPicksCache.clear();
    playerHistoryCache.clear();

    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (authenticated === false) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    const bust = Date.now().toString();
    await fetchBootstrapData(bust);

    await updateDisplay(); // updateDisplay now calls loadSquads(..., { force:false }) by default
    // Force an actual refetch for the current GW dataset:
    const gw = parseInt(gwFilterSelect.value as any) || latestGW;
    await loadSquads(managerIds, gw, { force: true });
  });


  // Modal close handlers
  const playerModal = document.getElementById("player-modal");
  const closePlayerModal = document.getElementById("close-player-modal");
  if (playerModal && closePlayerModal) {
    closePlayerModal.addEventListener("click", () => {
      playerModal.classList.remove("is-open");
    });
  }

  // Initialize GW Points Modal
  const gwPointsModal = initGWPointsModal('gw-points-modal');

  const historyModal = document.getElementById("manager-history-modal");
  const closeHistoryModal = document.getElementById("close-history-modal");
  if (historyModal && closeHistoryModal) {
    closeHistoryModal.addEventListener("click", () => {
      historyModal.classList.remove("is-open");
    });
  }

  init();
</script>

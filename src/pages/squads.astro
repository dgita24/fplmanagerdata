---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="Manager Squads - FPL Manager Data">
  <Nav />

  <main class="page squads-page-v1">
    <header class="page-header">
      <h1 class="page-title">Manager Squads</h1>
      <p class="page-subtitle">View each manager's squad for any gameweek.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">âš™ Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="manager-filter">Manager</label>
        <select class="select-small" id="manager-filter">
          <option value="">All</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="view-filter">View</label>
        <select class="select-small" id="view-filter">
          <option value="all">All Players</option>
          <option value="captain">Captains</option>
          <option value="vice">Vice Captains</option>
        </select>
      </div>
    </div>

    <div class="status-row">
      <div id="loading-status" class="status-text"></div>
      <button id="refresh-btn" class="btn-refresh" type="button">ðŸ”„ Refresh</button>
    </div>

    <section id="squads-output" aria-live="polite"></section>
  </main>

  <!-- Player Stats Modal -->
  <div id="player-modal" class="modal modal--nested">
    <div class="modal-panel modal-panel--compact">
      <button id="close-player-modal" class="btn btn--danger btn--small modal-close" type="button">âœ•</button>
      <div id="player-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 11px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 32px;
    padding: 4px 6px;
    font-family: inherit;
    font-size: 12px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .status-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-2);
  }

  .status-text {
    font-size: var(--text-sm);
    color: var(--color-text-secondary);
  }

  .btn-refresh {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 32px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
    white-space: nowrap;
  }

  .btn-refresh:hover {
    background: var(--color-primary-hover);
  }

  :global(.squad-card) {
    margin-bottom: var(--space-4);
  }

  :global(.squad-header) {
    padding: var(--space-2) var(--space-3);
    background: var(--color-surface-alt);
    border-bottom: 1px solid var(--color-border);
    font-size: var(--text-sm);
    text-align: center;
  }

  :global(.bench-row) {
    background: var(--color-surface-alt);
  }

  :global(.sub-on-row) {
    background: rgb(22 163 74 / 0.1);
  }

  :global(.sub-off-row) {
    background: rgb(220 38 38 / 0.1);
  }

  :global(.dnp-row) {
    background: rgb(220 38 38 / 0.05);
    opacity: 0.7;
  }

  :global(.squad-chip-indicator) {
    text-align: center;
    padding: var(--space-1) var(--space-3);
    font-size: var(--text-sm);
    font-weight: 600;
    color: var(--color-warning);
    border-bottom: 1px solid var(--color-border);
  }

  :global(.player-name-btn) {
    background: none;
    border: none;
    color: var(--color-primary);
    cursor: pointer;
    font-family: inherit;
    font-size: inherit;
    padding: 0;
    text-align: left;
    text-decoration: underline;
    text-decoration-color: transparent;
    transition: text-decoration-color 0.2s;
  }

  :global(.player-name-btn:hover) {
    text-decoration-color: var(--color-primary);
  }

  @media (min-width: 640px) {
    :global(.squads-page-v1 table.squad-table) {
      table-layout: fixed !important;
      width: 100% !important;
    }

    :global(.squads-page-v1 .squad-table .pos-num) { width: 90px !important; }
    :global(.squads-page-v1 .squad-table .team-col) { width: 90px !important; }
    :global(.squads-page-v1 .squad-table .pts-col) { width: 90px !important; }
    :global(.squads-page-v1 .squad-table .cap-col) { width: 90px !important; }

    :global(.squads-page-v1 .squad-table td) {
      overflow-wrap: anywhere;
    }
  }

</style>

<script>
  import { supabase } from '../lib/supabase.ts'
  import { fetchFixtures, fetchLiveGW, getPlayerLiveComputed, getTeamGwStatus, type FixtureInfo, type LiveStatLine, type TeamStatus } from '../lib/fplLive.ts'

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("squads-output");
  const gwFilterSelect = document.getElementById("gw-filter");
  const managerFilter = document.getElementById("manager-filter");
  const viewFilter = document.getElementById("view-filter");
  const loadingStatus = document.getElementById("loading-status");
  const managerCountEl = document.getElementById("manager-count");
  const refreshBtn = document.getElementById("refresh-btn");

  let managerIds = [];
  let allSquadsData = [];
  let latestGW = null;

  let playerCache = new Map();
  let teamCache = new Map();
  let livePointsCache = new Map<number, LiveStatLine>();
  let teamStatusCache = new Map<string, TeamStatus>();
  let projectedBonusCache = new Map<string, number>();
  let fixturesCache: FixtureInfo[] = [];

  function populateGWSelector(currentGW) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = i;
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  function getTeamGwStatusLocal(teamId, gw) {
    return getTeamGwStatus(teamStatusCache, teamId, gw);
  }

  function getPlayerLiveComputedLocal(playerId, teamId, gw) {
    return getPlayerLiveComputed({
      playerId,
      teamId,
      gw,
      livePointsCache,
      projectedBonusCache,
      teamStatusCache,
      bonusConfirmedOnProvisional: false
    });
  }

  function applyCaptaincyToSquadDisplay(teamPicks, chipCode) {
    const capFactor = (chipCode === "TC") ? 3 : 2;

    const cap = teamPicks.find(p => p.isCaptain);
    const vc = teamPicks.find(p => p.isViceCaptain);

    const capId = cap ? cap.playerId : null;
    const vcId = vc ? vc.playerId : null;

    const capDnp = cap ? !!cap.dnp : true;
    const vcDnp = vc ? !!vc.dnp : true;

    const actingCaptainId =
      (!capDnp && capId !== null) ? capId :
      (!vcDnp && vcId !== null) ? vcId :
      null;

    return teamPicks.map(p => {
      const mult = (actingCaptainId !== null && p.playerId === actingCaptainId) ? capFactor : 1;
      return { ...p, gwPointsCap: (Number(p.gwPoints) || 0) * mult };
    });
  }

  function applyAutoSubsKeepAll(teamPicks, chipCode) {
    const isBB = chipCode === "BB";

    const sorted = [...teamPicks].sort((a, b) => a.position - b.position);
    const starters = sorted.slice(0, 11);
    const bench = sorted.slice(11);

    if (isBB) {
      return sorted.map(p => ({ ...p, subOn: false, subOff: false }));
    }

    let active = starters.filter(p => !p.dnp);
    const benchRemaining = [];

    for (const cand of bench) {
      if (active.length >= 11) {
        benchRemaining.push(cand);
        continue;
      }

      if (cand.dnp) {
        benchRemaining.push(cand);
        continue;
      }

      const gkCount = active.filter(p => p.playerPosition === "GK").length;
      const defCount = active.filter(p => p.playerPosition === "DEF").length;

      const pos = cand.playerPosition;
      const validGK = (pos === "GK" && gkCount === 0);
      const validDefSave = (pos === "DEF" && defCount < 3);
      const validGeneral = (pos !== "GK" && gkCount > 0 && defCount >= 3);

      if (validGK || validDefSave || validGeneral) {
        active = [...active, cand];
      } else {
        benchRemaining.push(cand);
      }
    }

    const activeIds = new Set(active.map(p => p.playerId));

    return sorted.map(p => {
      const wasStarter = p.position <= 11;
      const inXI = activeIds.has(p.playerId);
      return {
        ...p,
        subOn: (!wasStarter && inXI),
        subOff: (wasStarter && !inXI)
      };
    });
  }

  async function fetchBootstrapData() {
    try {
      const res = await fetch('/api/fpl/bootstrap-static');
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      playerCache.clear();
      teamCache.clear();

      data.elements.forEach(player => {
        playerCache.set(player.id, {
          name: player.web_name,
          position: player.element_type === 1 ? "GK" :
                    player.element_type === 2 ? "DEF" :
                    player.element_type === 3 ? "MID" : "FWD",
          teamId: player.team,
          // Season stats:
          totalPoints: player.total_points,
          selectedByPercent: player.selected_by_percent,
          goalsScored: player.goals_scored,
          assists: player.assists,
          cleanSheets: player.clean_sheets,
          penaltiesSaved: player.penalties_saved,
          yellowCards: player.yellow_cards,
          redCards: player.red_cards,
          bonus: player.bonus
        });
      });

      data.teams.forEach(team => {
        teamCache.set(team.id, team.short_name);
      });

      const currentEvent = data.events?.find(e => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;

      populateGWSelector(latestGW);

      return data;
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
      latestGW = 1;
      return null;
    }
  }

  async function fetchSquadForGW(entryId, gw) {
    try {
      const res = await fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks`);
      if (!res.ok) throw new Error("Failed to fetch picks");

      const data = await res.json();
      const picks = data.picks || [];

      return picks.map(pick => {
        const info = playerCache.get(pick.element) || { name: "Unknown", position: "?", teamId: 0 };
        const teamName = teamCache.get(info.teamId) || "???";

        const computed = getPlayerLiveComputedLocal(pick.element, info.teamId, gw);

        return {
          position: Number(pick.position),
          playerId: Number(pick.element),
          playerName: info.name,
          playerPosition: info.position,
          teamId: info.teamId,
          teamName,

          isCaptain: !!pick.is_captain,
          isViceCaptain: !!pick.is_vice_captain,

          minutes: computed.minutes,
          status: computed.status,
          dnp: (computed.minutes === 0 && computed.status === "Fin"),

          gwPoints: Math.trunc(Number(computed.liveTotal) || 0),

          subOn: false,
          subOff: false
        };
      });
    } catch (e) {
      console.error(`Error fetching squad for ${entryId} GW${gw}:`, e);
      return [];
    }
  }

  async function fetchManagerData(entryId, gw) {
    try {
      const [summaryRes, historyRes] = await Promise.all([
        fetch(`/api/fpl/entry/${entryId}`),
        fetch(`/api/fpl/entry/${entryId}/history`)
      ]);

      if (!summaryRes.ok || !historyRes.ok) throw new Error("Failed to fetch manager data");

      const summaryData = await summaryRes.json();
      const historyData = await historyRes.json();

      const managerName = `${summaryData.player_first_name} ${summaryData.player_last_name}`;
      const teamName = summaryData.name;

      const chips = historyData.chips || [];
      const chipThisGW = chips.find(c => c.event === gw);
      const chipPlayed = chipThisGW ?
        (chipThisGW.name === "wildcard" ? "WC" :
        chipThisGW.name === "bboost" ? "BB" :
        chipThisGW.name === "3xc" ? "TC" :
        chipThisGW.name === "freehit" ? "FH" : chipThisGW.name) : "";

      const squadRaw = await fetchSquadForGW(entryId, gw);
      const squadWithIndicators = applyAutoSubsKeepAll(squadRaw, chipPlayed || "None");
      const squad = applyCaptaincyToSquadDisplay(squadWithIndicators, chipPlayed || "None");

      return {
        entryId,
        managerName,
        teamName,
        chipPlayed,
        squad
      };
    } catch (e) {
      console.error(`Error fetching manager ${entryId}:`, e);
      return null;
    }
  }

  function populateManagerFilter() {
    managerFilter.innerHTML = '<option value="">All</option>';

    const sortedManagers = [...allSquadsData].sort((a, b) =>
      a.managerName.localeCompare(b.managerName)
    );

    for (const manager of sortedManagers) {
      const option = document.createElement('option');
      option.value = manager.entryId;
      option.textContent = manager.managerName;
      managerFilter.appendChild(option);
    }
  }

  function getChipFullName(chipCode) {
    switch (chipCode) {
      case "WC": return "Wildcard";
      case "FH": return "Free Hit";
      case "BB": return "Bench Boost";
      case "TC": return "Triple Captain";
      default: return chipCode;
    }
  }

  function makeCaptainTable(squadsData, managerFilterValue = "", viewType = "captain") {
    let filteredManagers = squadsData;

    if (managerFilterValue) {
      filteredManagers = squadsData.filter(m => m.entryId.toString() === managerFilterValue);
    }

    const isCaptainView = viewType === "captain";

    // Collect captain/vc data
    const rows = [];
    for (const manager of filteredManagers) {
      const target = manager.squad.find(p => isCaptainView ? p.isCaptain : p.isViceCaptain);
      if (target) {
        rows.push({
          managerName: manager.managerName,
          chipPlayed: manager.chipPlayed,
          playerId: target.playerId,
          playerName: target.playerName,
          teamName: target.teamName,
          points: target.gwPointsCap ?? target.gwPoints,
          rawPoints: target.gwPoints,
          isCaptain: target.isCaptain,
          isViceCaptain: target.isViceCaptain
        });
      }
    }

    // Sort by points descending
    rows.sort((a, b) => b.points - a.points);

    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table captain-table">
            <thead>
              <tr>
                <th>Manager</th>
                <th>Player</th>
                <th class="team-col">Team</th>
                <th class="pts-col">Pts</th>
              </tr>
            </thead>
            <tbody>
    `;

    for (const row of rows) {
      const chipBadge = row.chipPlayed ? `<span class="badge" style="margin-left:4px;font-size:9px;padding:1px 4px;">${row.chipPlayed}</span>` : '';

      html += `
        <tr>
          <td class="manager-cell">${row.managerName}${chipBadge}</td>
          <td class="player-cell">
            <button type="button" class="player-name-btn" data-player-id="${row.playerId}">${row.playerName}</button>
          </td>
          <td class="team-col">${row.teamName}</td>
          <td class="pts-col">${row.points}</td>
        </tr>
      `;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

    return html;
  }

  function makeSquadsDisplay(squadsData, managerFilterValue = "") {
    let filteredManagers = squadsData;

    if (managerFilterValue) {
      filteredManagers = squadsData.filter(m => m.entryId.toString() === managerFilterValue);
    }

    let html = "";

    for (const manager of filteredManagers) {
      const squad = [...(manager.squad || [])].sort((a, b) => a.position - b.position);

      html += `
        <div class="card squad-card">
          <div class="squad-header">
            <strong>${manager.managerName}</strong>
            <span class="text-muted"> â€” ${manager.teamName}</span>
          </div>
          ${manager.chipPlayed ? `<div class="squad-chip-indicator">${getChipFullName(manager.chipPlayed)} played</div>` : ''}
          <div class="table-scroll">
            <table class="data-table squad-table">
              <thead>
                <tr>
                  <th class="num pos-num">#</th>
                  <th>Player</th>
                  <th class="num team-col">Team</th>
                  <th class="num pts-col">Pts</th>
                  <th class="num cap-col">C</th>
                </tr>
              </thead>
              <tbody>
      `;

      for (const player of squad) {
        const isBench = player.position > 11;
        
        let rowClass = "";
        if (player.subOn) rowClass = "sub-on-row";
        else if (player.subOff) rowClass = "sub-off-row";
        else if (player.dnp) rowClass = "dnp-row";
        else if (isBench) rowClass = "bench-row";

        const captainLabel = player.isCaptain ? "C" : (player.isViceCaptain ? "V" : "");
        const captainClass = player.isCaptain ? "text-danger" : (player.isViceCaptain ? "text-primary" : "");

        let statusBadge = "";
        if (player.subOn) statusBadge = `<span class="badge badge--success" style="font-size:9px;padding:1px 4px;margin-left:4px;">ON</span>`;
        else if (player.subOff) statusBadge = `<span class="badge badge--danger" style="font-size:9px;padding:1px 4px;margin-left:4px;">OFF</span>`;
        else if (player.dnp) statusBadge = `<span class="badge" style="font-size:9px;padding:1px 4px;margin-left:4px;">DNP</span>`;

        html += `
          <tr class="${rowClass}">
            <td class="num pos-num">${player.position}</td>
            <td class="player-name">
              <button type="button" class="player-name-btn" data-player-id="${player.playerId}">${player.playerName}</button>
              ${statusBadge}
            </td>
            <td class="num team-col">${player.teamName}</td>
            <td class="num pts-col">${player.gwPointsCap ?? player.gwPoints}</td>
            <td class="num cap-col ${captainClass}">${captainLabel}</td>
          </tr>
        `;
      }

      html += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    }

    if (!html) {
      html = "<p class='text-muted'>No squads to display.</p>";
    }

    return html;
  }

  async function fetchPlayerDefconStats(playerId: number): Promise<{ totalDefcon: number; gamesWithDefcon: number }> {
    try {
      const { data, error } = await supabase
        .from('player_defensive_stats')
        .select('defcon_points')
        .eq('player_id', playerId);
      
      if (error || !data) return { totalDefcon: 0, gamesWithDefcon: 0 };
      
      const totalDefcon = data.reduce((sum, row) => sum + (row.defcon_points || 0), 0);
      const gamesWithDefcon = data.filter(row => row.defcon_points > 0).length;
      
      return { totalDefcon, gamesWithDefcon };
    } catch (e) {
      console.error('Error fetching DEFCON stats:', e);
      return { totalDefcon: 0, gamesWithDefcon: 0 };
    }
  }

  // FPL Point Calculation Helper Functions
  function getGoalPoints(position, goals) {
    if (!goals) return 0;
    const pointsPerGoal = position === "GK" || position === "DEF" ? 6 :
                          position === "MID" ? 5 : 4;
    return goals * pointsPerGoal;
  }

  function getAssistPoints(assists) {
    return (assists || 0) * 3;
  }

  function getCleanSheetPoints(position, cleanSheets) {
    if (!cleanSheets) return 0;
    const pointsPerCleanSheet = position === "GK" || position === "DEF" ? 4 :
                                position === "MID" ? 1 : 0;
    return cleanSheets * pointsPerCleanSheet;
  }

  function getPenaltySavedPoints(penaltiesSaved) {
    return (penaltiesSaved || 0) * 5;
  }

  function getYellowCardPoints(yellowCards) {
    return (yellowCards || 0) * -1;
  }

  function getRedCardPoints(redCards) {
    return (redCards || 0) * -3;
  }

  function formatPoints(points) {
    if (points === 0) return "â€”";
    return points > 0 ? `+${points}` : `${points}`;
  }

  function getPointsClass(points) {
    if (points > 0) return "points-positive";
    if (points < 0) return "points-negative";
    return "";
  }

  async function showPlayerModal(playerId) {
    const player = playerCache.get(playerId);
    
    if (!player) {
      const playerModalContent = document.getElementById("player-modal-content");
      const playerModal = document.getElementById("player-modal");
      playerModalContent.innerHTML = "<p class='status status--error'>Player not found.</p>";
      playerModal.classList.add("is-open");
      return;
    }

    const teamName = teamCache.get(player.teamId) || "???";
    
    // Fetch DEFCON stats for outfield players
    const isOutfieldPlayer = player.position !== "GK";
    let defconStats = { totalDefcon: 0, gamesWithDefcon: 0 };
    if (isOutfieldPlayer) {
      defconStats = await fetchPlayerDefconStats(playerId);
    }

    // Calculate FPL points for each stat
    const goalPoints = getGoalPoints(player.position, player.goalsScored);
    const assistPoints = getAssistPoints(player.assists);
    const cleanSheetPoints = getCleanSheetPoints(player.position, player.cleanSheets);
    const penaltySavedPoints = getPenaltySavedPoints(player.penaltiesSaved);
    const yellowCardPoints = getYellowCardPoints(player.yellowCards);
    const redCardPoints = getRedCardPoints(player.redCards);
    const bonusPoints = player.bonus || 0;

    let html = `
      <div class="player-modal-header">
        <div class="player-modal-info">
          <h2 class="player-modal-name">${player.name}</h2>
          <div class="player-modal-meta">
            <span class="player-modal-team">${teamName}</span>
            <span class="player-modal-pos">${player.position}</span>
          </div>
        </div>
        <div class="player-modal-points">
          <span class="player-modal-total">${player.totalPoints || 0}</span>
          <span class="player-modal-pts-label">pts</span>
        </div>
      </div>

      <div class="player-modal-breakdown">
        <h3 class="player-modal-section-title">Season Statistics</h3>
        <div class="breakdown-list">
          <div class="breakdown-row">
            <span class="breakdown-label">Total Points</span>
            <span class="breakdown-value">${player.totalPoints || 0}</span>
            <span class="breakdown-points">â€”</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Selected By</span>
            <span class="breakdown-value">${player.selectedByPercent || 0}%</span>
            <span class="breakdown-points">â€”</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Goals Scored</span>
            <span class="breakdown-value">${player.goalsScored || 0}</span>
            <span class="breakdown-points ${getPointsClass(goalPoints)}">${formatPoints(goalPoints)}</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Assists</span>
            <span class="breakdown-value">${player.assists || 0}</span>
            <span class="breakdown-points ${getPointsClass(assistPoints)}">${formatPoints(assistPoints)}</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Clean Sheets</span>
            <span class="breakdown-value">${player.cleanSheets || 0}</span>
            <span class="breakdown-points ${getPointsClass(cleanSheetPoints)}">${formatPoints(cleanSheetPoints)}</span>
          </div>
          ${player.position === "GK" ? `
          <div class="breakdown-row">
            <span class="breakdown-label">Penalties Saved</span>
            <span class="breakdown-value">${player.penaltiesSaved || 0}</span>
            <span class="breakdown-points ${getPointsClass(penaltySavedPoints)}">${formatPoints(penaltySavedPoints)}</span>
          </div>
          ` : ''}
          ${isOutfieldPlayer && defconStats.totalDefcon > 0 ? `
          <div class="breakdown-row">
            <span class="breakdown-label">DEFCON Points</span>
            <span class="breakdown-value">${defconStats.gamesWithDefcon} games</span>
            <span class="breakdown-points points-positive">+${defconStats.totalDefcon}</span>
          </div>
          ` : ''}
          <div class="breakdown-row">
            <span class="breakdown-label">Yellow Cards</span>
            <span class="breakdown-value">${player.yellowCards || 0}</span>
            <span class="breakdown-points ${getPointsClass(yellowCardPoints)}">${formatPoints(yellowCardPoints)}</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Red Cards</span>
            <span class="breakdown-value">${player.redCards || 0}</span>
            <span class="breakdown-points ${getPointsClass(redCardPoints)}">${formatPoints(redCardPoints)}</span>
          </div>
          <div class="breakdown-row">
            <span class="breakdown-label">Bonus Points</span>
            <span class="breakdown-value">${player.bonus || 0}</span>
            <span class="breakdown-points ${getPointsClass(bonusPoints)}">${formatPoints(bonusPoints)}</span>
          </div>
        </div>
      </div>
    `;

    const playerModalContent = document.getElementById("player-modal-content");
    const playerModal = document.getElementById("player-modal");
    playerModalContent.innerHTML = html;
    playerModal.classList.add("is-open");
  }

  function attachPlayerButtons() {
    document.querySelectorAll('.player-name-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = e.target as HTMLElement;
        const playerId = parseInt(button.dataset.playerId || '0');
        if (playerId) showPlayerModal(playerId);
      });
    });
  }

  function renderOutput() {
    const viewType = viewFilter.value;
    const managerFilterValue = managerFilter.value;

    if (viewType === "captain" || viewType === "vice") {
      out.innerHTML = makeCaptainTable(allSquadsData, managerFilterValue, viewType);
    } else {
      out.innerHTML = makeSquadsDisplay(allSquadsData, managerFilterValue);
    }
    
    attachPlayerButtons();
  }

  async function loadSquads(ids, gw) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    if (!gw) {
      out.innerHTML = "<p class='status status--warning'>Please select a gameweek.</p>";
      return;
    }

    allSquadsData = [];
    out.innerHTML = "";
    loadingStatus.textContent = `Loading GW${gw} data...`;

    try {
      await Promise.all([
        fetchFixtures({ gw, fixturesCache, projectedBonusCache, teamStatusCache, includeFinishedProvisional: false }),
        fetchLiveGW({ gw, livePointsCache })
      ]);
    } catch (e) {
      console.error("Failed to load live caches:", e);
      out.innerHTML = "<p class='status status--error'>Failed to load live data. Try refresh.</p>";
      loadingStatus.textContent = "";
      return;
    }

    let loaded = 0;
    for (const id of ids) {
      try {
        const data = await fetchManagerData(id, gw);
        if (data) {
          allSquadsData.push(data);
          loaded++;

          loadingStatus.textContent = `Loading ${loaded} of ${ids.length}...`;

          renderOutput();
        }
      } catch (e) {
        console.error(`Failed to load manager ${id}:`, e);
        loaded++;
      }
    }

    populateManagerFilter();

    loadingStatus.innerHTML = `<span class="text-success font-bold">âœ… Loaded ${loaded} managers for GW${gw}</span>`;
  }

  async function init() {
    loadingStatus.textContent = "Loading player data...";
    await fetchBootstrapData();

    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;

    await updateDisplay();
  }

  async function updateDisplay() {
    managerCountEl.textContent = `${managerIds.length} managers`;
    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    const urlParams = new URLSearchParams(window.location.search);
    const managerParam = urlParams.get('manager');

    const gw = parseInt(gwFilterSelect.value) || latestGW;

    if (managerParam) {
      const managerId = parseInt(managerParam);
      await loadSquads([managerId], gw);

      const checkAndSetFilter = () => {
        if (managerFilter.options.length > 1) {
          managerFilter.value = managerId.toString();
        } else {
          setTimeout(checkAndSetFilter, 50);
        }
      };
      setTimeout(checkAndSetFilter, 50);
    } else {
      await loadSquads(managerIds, gw);
    }
  }

  gwFilterSelect.addEventListener('change', async () => {
    const gw = parseInt(gwFilterSelect.value);
    if (gw && gw >= 1 && gw <= 38) {
      await loadSquads(managerIds, gw);
    }
  });

  managerFilter.addEventListener('change', () => {
    renderOutput();
  });

  viewFilter.addEventListener('change', () => {
    renderOutput();
  });

  refreshBtn.addEventListener('click', async () => {
    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;
    await updateDisplay();
  });

  // Player modal close handler
  const playerModal = document.getElementById("player-modal");
  const closePlayerModal = document.getElementById("close-player-modal");
  
  if (playerModal && closePlayerModal) {
    closePlayerModal.addEventListener("click", () => {
      playerModal.classList.remove("is-open");
    });
  }

  init();
</script>

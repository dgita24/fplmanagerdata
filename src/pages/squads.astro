---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="Manager Squads - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">Manager Squads</h1>
      <p class="page-subtitle">View each manager's squad for any gameweek.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">âš™ Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="manager-filter">Manager</label>
        <select class="select-small" id="manager-filter">
          <option value="">All</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="view-filter">View</label>
        <select class="select-small" id="view-filter">
          <option value="all">All Players</option>
          <option value="captain">Captains</option>
          <option value="vice">Vice Captains</option>
        </select>
      </div>
    </div>

    <div class="status-row">
      <div id="loading-status" class="status-text"></div>
      <button id="refresh-btn" class="btn-refresh" type="button">ðŸ”„ Refresh</button>
    </div>

    <section id="squads-output" aria-live="polite"></section>
  </main>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 11px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 32px;
    padding: 4px 6px;
    font-family: inherit;
    font-size: 12px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .status-row {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: var(--space-2);
  }

  .status-text {
    font-size: var(--text-sm);
    color: var(--color-text-secondary);
  }

  .btn-refresh {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 32px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
    white-space: nowrap;
  }

  .btn-refresh:hover {
    background: var(--color-primary-hover);
  }

  .squad-card {
    margin-bottom: var(--space-3);
  }

  .squad-header {
    padding: var(--space-2) var(--space-3);
    background: var(--color-surface-alt);
    border-bottom: 1px solid var(--color-border);
    font-size: var(--text-sm);
  }

  .bench-row {
    background: var(--color-surface-alt);
  }

  .sub-on-row {
    background: rgb(22 163 74 / 0.1);
  }

  .sub-off-row {
    background: rgb(220 38 38 / 0.1);
  }

  .dnp-row {
    background: rgb(220 38 38 / 0.05);
    opacity: 0.7;
  }
</style>

<script>
  import { supabase } from '../lib/supabase.ts'

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("squads-output");
  const gwFilterSelect = document.getElementById("gw-filter");
  const managerFilter = document.getElementById("manager-filter");
  const viewFilter = document.getElementById("view-filter");
  const loadingStatus = document.getElementById("loading-status");
  const managerCountEl = document.getElementById("manager-count");
  const refreshBtn = document.getElementById("refresh-btn");

  let managerIds = [];
  let allSquadsData = [];
  let latestGW = null;

  let playerCache = new Map();
  let teamCache = new Map();
  let livePointsCache = new Map();
  let teamStatusCache = new Map();
  let projectedBonusCache = new Map();

  function populateGWSelector(currentGW) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = i;
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  function getTeamGwStatus(teamId, gw) {
    return teamStatusCache.get(`${gw}:${teamId}`) || { started: false, finished: false };
  }

  function bonusFromBpsRows(bpsRows) {
    const rows = (bpsRows || [])
      .filter(r => r && Number.isFinite(r.value) && Number.isFinite(r.element))
      .sort((a, b) => b.value - a.value);

    const out = new Map();
    if (rows.length === 0) return out;

    const topVal = rows[0].value;
    const top = rows.filter(r => r.value === topVal);

    if (top.length >= 2) {
      for (const r of top) out.set(r.element, 3);
      if (top.length >= 3) return out;
      const next = rows.find(r => r.value < topVal);
      if (next) {
        const nextVal = next.value;
        for (const r of rows.filter(r => r.value === nextVal)) out.set(r.element, 1);
      }
      return out;
    }

    out.set(rows[0].element, 3);

    const secondRow = rows.find(r => r.value < topVal);
    if (!secondRow) return out;

    const secondVal = secondRow.value;
    const second = rows.filter(r => r.value === secondVal);

    if (second.length >= 2) {
      for (const r of second) out.set(r.element, 2);
      return out;
    }

    out.set(second[0].element, 2);

    const thirdRow = rows.find(r => r.value < secondVal);
    if (!thirdRow) return out;

    const thirdVal = thirdRow.value;
    for (const r of rows.filter(r => r.value === thirdVal)) out.set(r.element, 1);

    return out;
  }

  function getPlayerLiveComputed(playerId, teamId, gw) {
    const live = livePointsCache.get(playerId) || { points: 0, bonus: 0, minutes: 0 };
    const { started, finished } = getTeamGwStatus(teamId, gw);

    const officialTotal = Number(live.points) || 0;
    const confirmedBonus = Number(live.bonus) || 0;
    const minutes = Number(live.minutes) || 0;

    const locked = finished ? officialTotal : (officialTotal - confirmedBonus);
    const projBonus = finished ? 0 : (Number(projectedBonusCache.get(`${gw}:${playerId}`)) || 0);
    const liveTotal = locked + projBonus;

    const status = finished ? "Fin" : (started ? "Live" : "NS");
    const dnp = (minutes === 0 && status === "Fin");

    return { locked, projBonus, liveTotal, status, minutes, dnp };
  }

  function applyCaptaincyToSquadDisplay(teamPicks, chipCode) {
    const capFactor = (chipCode === "TC") ? 3 : 2;

    const cap = teamPicks.find(p => p.isCaptain);
    const vc = teamPicks.find(p => p.isViceCaptain);

    const capId = cap ? cap.playerId : null;
    const vcId = vc ? vc.playerId : null;

    const capDnp = cap ? !!cap.dnp : true;
    const vcDnp = vc ? !!vc.dnp : true;

    const actingCaptainId =
      (!capDnp && capId !== null) ? capId :
      (!vcDnp && vcId !== null) ? vcId :
      null;

    return teamPicks.map(p => {
      const mult = (actingCaptainId !== null && p.playerId === actingCaptainId) ? capFactor : 1;
      return { ...p, gwPointsCap: (Number(p.gwPoints) || 0) * mult };
    });
  }

  function applyAutoSubsKeepAll(teamPicks, chipCode) {
    const isBB = chipCode === "BB";

    const sorted = [...teamPicks].sort((a, b) => a.position - b.position);
    const starters = sorted.slice(0, 11);
    const bench = sorted.slice(11);

    if (isBB) {
      return sorted.map(p => ({ ...p, subOn: false, subOff: false }));
    }

    let active = starters.filter(p => !p.dnp);
    const benchRemaining = [];

    for (const cand of bench) {
      if (active.length >= 11) {
        benchRemaining.push(cand);
        continue;
      }

      if (cand.dnp) {
        benchRemaining.push(cand);
        continue;
      }

      const gkCount = active.filter(p => p.playerPosition === "GK").length;
      const defCount = active.filter(p => p.playerPosition === "DEF").length;

      const pos = cand.playerPosition;
      const validGK = (pos === "GK" && gkCount === 0);
      const validDefSave = (pos === "DEF" && defCount < 3);
      const validGeneral = (pos !== "GK" && gkCount > 0 && defCount >= 3);

      if (validGK || validDefSave || validGeneral) {
        active = [...active, cand];
      } else {
        benchRemaining.push(cand);
      }
    }

    const activeIds = new Set(active.map(p => p.playerId));

    return sorted.map(p => {
      const wasStarter = p.position <= 11;
      const inXI = activeIds.has(p.playerId);
      return {
        ...p,
        subOn: (!wasStarter && inXI),
        subOff: (wasStarter && !inXI)
      };
    });
  }

  async function fetchBootstrapData() {
    try {
      const res = await fetch('/api/fpl/bootstrap-static');
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      playerCache.clear();
      teamCache.clear();

      data.elements.forEach(player => {
        playerCache.set(player.id, {
          name: player.web_name,
          position: player.element_type === 1 ? "GK" :
                    player.element_type === 2 ? "DEF" :
                    player.element_type === 3 ? "MID" : "FWD",
          teamId: player.team
        });
      });

      data.teams.forEach(team => {
        teamCache.set(team.id, team.short_name);
      });

      const currentEvent = data.events?.find(e => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;

      populateGWSelector(latestGW);

      return data;
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
      latestGW = 1;
      return null;
    }
  }

  async function fetchFixtures(gw) {
    const res = await fetch(`/api/fpl/fixtures?event=${gw}`);
    if (!res.ok) throw new Error("Failed to fetch fixtures");
    const fixtures = await res.json();

    teamStatusCache.clear();
    projectedBonusCache.clear();

    const perTeam = new Map();
    function upsertTeam(teamId, started, finished) {
      const cur = perTeam.get(teamId) || { startedAny: false, finishedAll: true };
      cur.startedAny = cur.startedAny || !!started || !!finished;
      cur.finishedAll = cur.finishedAll && !!finished;
      perTeam.set(teamId, cur);
    }

    for (const fx of fixtures) {
      upsertTeam(fx.team_h, fx.started, fx.finished);
      upsertTeam(fx.team_a, fx.started, fx.finished);

      if (!fx.started || fx.finished) continue;

      const stats = Array.isArray(fx.stats) ? fx.stats : [];
      const bpsStat = stats.find(s => s && s.identifier === "bps");
      if (!bpsStat) continue;

      const h = Array.isArray(bpsStat.h) ? bpsStat.h : [];
      const a = Array.isArray(bpsStat.a) ? bpsStat.a : [];
      const all = [...h, ...a]
        .map(r => ({ element: Number(r.element), value: Number(r.value) }))
        .filter(r => Number.isFinite(r.element) && Number.isFinite(r.value));

      const bonusMap = bonusFromBpsRows(all);

      for (const [playerId, bonus] of bonusMap.entries()) {
        const key = `${gw}:${playerId}`;
        projectedBonusCache.set(key, (projectedBonusCache.get(key) || 0) + bonus);
      }
    }

    for (const [teamId, st] of perTeam.entries()) {
      teamStatusCache.set(`${gw}:${teamId}`, { started: st.startedAny, finished: st.finishedAll });
    }

    return fixtures;
  }

  async function fetchLiveGW(gw) {
    const res = await fetch(`/api/fpl/event/${gw}/live`);
    if (!res.ok) throw new Error("Failed to fetch live data");
    const data = await res.json();

    livePointsCache.clear();
    const elements = Array.isArray(data.elements) ? data.elements : [];

    for (const p of elements) {
      const stats = p.stats || {};
      livePointsCache.set(p.id, {
        points: Number(stats.total_points) || 0,
        bonus: Number(stats.bonus) || 0,
        minutes: Number(stats.minutes) || 0
      });
    }

    return data;
  }

  async function fetchSquadForGW(entryId, gw) {
    try {
      const res = await fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks`);
      if (!res.ok) throw new Error("Failed to fetch picks");

      const data = await res.json();
      const picks = data.picks || [];

      return picks.map(pick => {
        const info = playerCache.get(pick.element) || { name: "Unknown", position: "?", teamId: 0 };
        const teamName = teamCache.get(info.teamId) || "???";

        const computed = getPlayerLiveComputed(pick.element, info.teamId, gw);

        return {
          position: Number(pick.position),
          playerId: Number(pick.element),
          playerName: info.name,
          playerPosition: info.position,
          teamId: info.teamId,
          teamName,

          isCaptain: !!pick.is_captain,
          isViceCaptain: !!pick.is_vice_captain,

          minutes: computed.minutes,
          status: computed.status,
          dnp: computed.dnp,

          gwPoints: Math.trunc(Number(computed.liveTotal) || 0),

          subOn: false,
          subOff: false
        };
      });
    } catch (e) {
      console.error(`Error fetching squad for ${entryId} GW${gw}:`, e);
      return [];
    }
  }

  async function fetchManagerData(entryId, gw) {
    try {
      const [summaryRes, historyRes] = await Promise.all([
        fetch(`/api/fpl/entry/${entryId}`),
        fetch(`/api/fpl/entry/${entryId}/history`)
      ]);

      if (!summaryRes.ok || !historyRes.ok) throw new Error("Failed to fetch manager data");

      const summaryData = await summaryRes.json();
      const historyData = await historyRes.json();

      const managerName = `${summaryData.player_first_name} ${summaryData.player_last_name}`;
      const teamName = summaryData.name;

      const chips = historyData.chips || [];
      const chipThisGW = chips.find(c => c.event === gw);
      const chipPlayed = chipThisGW ?
        (chipThisGW.name === "wildcard" ? "WC" :
        chipThisGW.name === "bboost" ? "BB" :
        chipThisGW.name === "3xc" ? "TC" :
        chipThisGW.name === "freehit" ? "FH" : chipThisGW.name) : "";

      const squadRaw = await fetchSquadForGW(entryId, gw);
      const squadWithIndicators = applyAutoSubsKeepAll(squadRaw, chipPlayed || "None");
      const squad = applyCaptaincyToSquadDisplay(squadWithIndicators, chipPlayed || "None");

      return {
        entryId,
        managerName,
        teamName,
        chipPlayed,
        squad
      };
    } catch (e) {
      console.error(`Error fetching manager ${entryId}:`, e);
      return null;
    }
  }

  function populateManagerFilter() {
    managerFilter.innerHTML = '<option value="">All</option>';

    const sortedManagers = [...allSquadsData].sort((a, b) =>
      a.managerName.localeCompare(b.managerName)
    );

    for (const manager of sortedManagers) {
      const option = document.createElement('option');
      option.value = manager.entryId;
      option.textContent = manager.managerName;
      managerFilter.appendChild(option);
    }
  }

  function makeCaptainTable(squadsData, managerFilterValue = "", viewType = "captain") {
    let filteredManagers = squadsData;

    if (managerFilterValue) {
      filteredManagers = squadsData.filter(m => m.entryId.toString() === managerFilterValue);
    }

    const isCaptainView = viewType === "captain";

    // Collect captain/vc data
    const rows = [];
    for (const manager of filteredManagers) {
      const target = manager.squad.find(p => isCaptainView ? p.isCaptain : p.isViceCaptain);
      if (target) {
        rows.push({
          managerName: manager.managerName,
          chipPlayed: manager.chipPlayed,
          playerName: target.playerName,
          teamName: target.teamName,
          points: target.gwPointsCap ?? target.gwPoints,
          rawPoints: target.gwPoints,
          isCaptain: target.isCaptain,
          isViceCaptain: target.isViceCaptain
        });
      }
    }

    // Sort by points descending
    rows.sort((a, b) => b.points - a.points);

    let html = `
      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table captain-table">
            <thead>
              <tr>
                <th>Manager</th>
                <th>Player</th>
                <th class="team-col">Team</th>
                <th class="pts-col">Pts</th>
              </tr>
            </thead>
            <tbody>
    `;

    for (const row of rows) {
      const chipBadge = row.chipPlayed ? `<span class="badge" style="margin-left:4px;font-size:9px;padding:1px 4px;">${row.chipPlayed}</span>` : '';

      html += `
        <tr>
          <td class="manager-cell">${row.managerName}${chipBadge}</td>
          <td class="player-cell">${row.playerName}</td>
          <td class="team-col">${row.teamName}</td>
          <td class="pts-col">${row.points}</td>
        </tr>
      `;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

    return html;
  }

  function makeSquadsDisplay(squadsData, managerFilterValue = "") {
    let filteredManagers = squadsData;

    if (managerFilterValue) {
      filteredManagers = squadsData.filter(m => m.entryId.toString() === managerFilterValue);
    }

    let html = "";

    for (const manager of filteredManagers) {
      const squad = [...(manager.squad || [])].sort((a, b) => a.position - b.position);

      html += `
        <div class="card squad-card">
          <div class="squad-header">
            <strong>${manager.managerName}</strong>
            <span class="text-muted"> â€” ${manager.teamName}</span>
            ${manager.chipPlayed ? `<span class="badge" style="margin-left:var(--space-2);">${manager.chipPlayed}</span>` : ''}
          </div>
          <div class="table-scroll">
            <table class="data-table squad-table">
              <thead>
                <tr>
                  <th class="num pos-num">#</th>
                  <th>Player</th>
                  <th class="num team-col">Team</th>
                  <th class="num pts-col">Pts</th>
                  <th class="num cap-col">C</th>
                </tr>
              </thead>
              <tbody>
      `;

      for (const player of squad) {
        const isBench = player.position > 11;
        
        let rowClass = "";
        if (player.subOn) rowClass = "sub-on-row";
        else if (player.subOff) rowClass = "sub-off-row";
        else if (player.dnp) rowClass = "dnp-row";
        else if (isBench) rowClass = "bench-row";

        const captainLabel = player.isCaptain ? "C" : (player.isViceCaptain ? "V" : "");
        const captainClass = player.isCaptain ? "text-danger" : (player.isViceCaptain ? "text-primary" : "");

        let statusBadge = "";
        if (player.subOn) statusBadge = `<span class="badge badge--success" style="font-size:9px;padding:1px 4px;margin-left:4px;">ON</span>`;
        else if (player.subOff) statusBadge = `<span class="badge badge--danger" style="font-size:9px;padding:1px 4px;margin-left:4px;">OFF</span>`;
        else if (player.dnp) statusBadge = `<span class="badge" style="font-size:9px;padding:1px 4px;margin-left:4px;">DNP</span>`;

        html += `
          <tr class="${rowClass}">
            <td class="num pos-num">${player.position}</td>
            <td class="player-name">${player.playerName}${statusBadge}</td>
            <td class="num team-col">${player.teamName}</td>
            <td class="num pts-col">${player.gwPointsCap ?? player.gwPoints}</td>
            <td class="num cap-col ${captainClass}">${captainLabel}</td>
          </tr>
        `;
      }

      html += `
              </tbody>
            </table>
          </div>
        </div>
      `;
    }

    if (!html) {
      html = "<p class='text-muted'>No squads to display.</p>";
    }

    return html;
  }

  function renderOutput() {
    const viewType = viewFilter.value;
    const managerFilterValue = managerFilter.value;

    if (viewType === "captain" || viewType === "vice") {
      out.innerHTML = makeCaptainTable(allSquadsData, managerFilterValue, viewType);
    } else {
      out.innerHTML = makeSquadsDisplay(allSquadsData, managerFilterValue);
    }
  }

  async function loadSquads(ids, gw) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    if (!gw) {
      out.innerHTML = "<p class='status status--warning'>Please select a gameweek.</p>";
      return;
    }

    allSquadsData = [];
    out.innerHTML = "";
    loadingStatus.textContent = `Loading GW${gw} data...`;

    try {
      await Promise.all([fetchFixtures(gw), fetchLiveGW(gw)]);
    } catch (e) {
      console.error("Failed to load live caches:", e);
      out.innerHTML = "<p class='status status--error'>Failed to load live data. Try refresh.</p>";
      loadingStatus.textContent = "";
      return;
    }

    let loaded = 0;
    for (const id of ids) {
      try {
        const data = await fetchManagerData(id, gw);
        if (data) {
          allSquadsData.push(data);
          loaded++;

          loadingStatus.textContent = `Loading ${loaded} of ${ids.length}...`;

          renderOutput();
        }
      } catch (e) {
        console.error(`Failed to load manager ${id}:`, e);
        loaded++;
      }
    }

    populateManagerFilter();

    loadingStatus.innerHTML = `<span class="text-success font-bold">âœ… Loaded ${loaded} managers for GW${gw}</span>`;
  }

  async function init() {
    loadingStatus.textContent = "Loading player data...";
    await fetchBootstrapData();

    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;

    await updateDisplay();
  }

  async function updateDisplay() {
    managerCountEl.textContent = `${managerIds.length} managers`;
    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    const urlParams = new URLSearchParams(window.location.search);
    const managerParam = urlParams.get('manager');

    const gw = parseInt(gwFilterSelect.value) || latestGW;

    if (managerParam) {
      const managerId = parseInt(managerParam);
      await loadSquads([managerId], gw);

      const checkAndSetFilter = () => {
        if (managerFilter.options.length > 1) {
          managerFilter.value = managerId.toString();
        } else {
          setTimeout(checkAndSetFilter, 50);
        }
      };
      setTimeout(checkAndSetFilter, 50);
    } else {
      await loadSquads(managerIds, gw);
    }
  }

  gwFilterSelect.addEventListener('change', async () => {
    const gw = parseInt(gwFilterSelect.value);
    if (gw && gw >= 1 && gw <= 38) {
      await loadSquads(managerIds, gw);
    }
  });

  managerFilter.addEventListener('change', () => {
    renderOutput();
  });

  viewFilter.addEventListener('change', () => {
    renderOutput();
  });

  refreshBtn.addEventListener('click', async () => {
    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    managerIds = ids;
    await updateDisplay();
  });

  init();
</script>
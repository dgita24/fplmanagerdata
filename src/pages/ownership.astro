---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
import { supabase } from '../lib/supabase.ts'
import { globalCache, clearCache } from '../lib/globalStore.ts';
---
<Layout title="Player Ownership - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">Player Ownership</h1>
      <p class="page-subtitle">See which players are owned by how many managers.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">‚öô Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="position-filter">Position</label>
        <select class="select-small" id="position-filter">
          <option value="">All</option>
          <option value="GK">GK</option>
          <option value="DEF">DEF</option>
          <option value="MID">MID</option>
          <option value="FWD">FWD</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small">&nbsp;</label>
        <button id="refresh-btn" class="btn-row" type="button">üîÑ Refresh</button>
      </div>
    </div>

    <div id="loading-status" class="meta-row"></div>
    <section id="ownership-output" aria-live="polite"></section>
  </main>

  <!-- Ownership Modal -->
  <div id="ownership-modal" class="modal">
    <div class="modal-panel">
      <button id="close-ownership-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="ownership-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
    align-items: flex-end; /* Align button with inputs */
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
    min-width: 100px;
  }

  .label-small {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 36px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .btn-row {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 36px;
    padding: var(--space-2) var(--space-3);
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
    white-space: nowrap;
  }

  .btn-row:hover {
    background: var(--color-primary-hover);
  }
</style>

<script>
  import { supabase } from '../lib/supabase.ts'

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("ownership-output");
  const gwFilterSelect = document.getElementById("gw-filter");
  const positionFilter = document.getElementById("position-filter");
  const loadingStatus = document.getElementById("loading-status");
  const managerCountEl = document.getElementById("manager-count");
  const refreshBtn = document.getElementById("refresh-btn");
  const ownershipModal = document.getElementById("ownership-modal");
  const ownershipModalContent = document.getElementById("ownership-modal-content");
  const closeOwnershipModal = document.getElementById("close-ownership-modal");

  let managerIds = [];
  let ownershipData = [];
  let latestGW = null;
  let playerCache = globalCache.playerCache;
  let teamCache = globalCache.teamCache;
  let allManagerNames = [];
  let freeHitManagers = new Set();
  
  let currentLoadToken = 0;
  let ownershipCache = globalCache.ownership.squads;

  closeOwnershipModal.addEventListener("click", () => {
    ownershipModal.classList.remove("is-open");
  });

  async function mapWithConcurrency<T, R>(
    items: T[],
    limit: number,
    fn: (item: T, index: number) => Promise<R | null>,
    onProgress?: (completed: number, total: number) => void
  ): Promise<(R | null)[]> {
    const results: (R | null)[] = [];
    let currentIndex = 0;
    let completed = 0;

    async function worker() {
      while (currentIndex < items.length) {
        const index = currentIndex++;
        const item = items[index];
        try {
          results[index] = await fn(item, index);
        } catch (e) {
          console.error(`Error processing item ${index}:`, e);
          results[index] = null;
        }
        completed++;
        if (onProgress) {
          onProgress(completed, items.length);
        }
      }
    }

    const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
    await Promise.all(workers);
    return results;
  }

  function populateGWSelector(currentGW) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = i;
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  async function fetchBootstrapData(cacheBuster?: string) {
    if (globalCache.bootstrapData && !cacheBuster) {
       const data = globalCache.bootstrapData;
       const currentEvent = data.events.find((e: any) => e.is_current);
       latestGW = currentEvent ? currentEvent.id : 1;
       populateGWSelector(latestGW);
       return;
    }

    try {
      const v = cacheBuster || Date.now().toString();
      const res = await fetch(`/api/fpl/bootstrap-static?v=${v}`);
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      data.elements.forEach((player: any) => {
        playerCache.set(player.id, {
          name: player.web_name,
          position: player.element_type === 1 ? "GK" :
                    player.element_type === 2 ? "DEF" :
                    player.element_type === 3 ? "MID" : "FWD",
          team: player.team
        });
      });

      data.teams.forEach((team: any) => {
        teamCache.set(team.id, team.short_name);
      });
      
      globalCache.bootstrapData = data;

      const currentEvent = data.events.find((e: any) => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;
      
      populateGWSelector(latestGW);
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
    }
  }

  async function fetchManagerSquad(entryId: number, gw: number, cacheBuster?: string) {
    const cacheKey = `${entryId}:${gw}`;
    // Respect cache unless bust requested
    if (!cacheBuster && ownershipCache.has(cacheKey)) {
        return ownershipCache.get(cacheKey);
    }

    try {
      const v = cacheBuster || Date.now().toString();
      const [picksRes, summaryRes, historyRes] = await Promise.all([
        fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks?v=${v}`),
        fetch(`/api/fpl/entry/${entryId}?v=${v}`),
        fetch(`/api/fpl/entry/${entryId}/history?v=${v}`)
      ]);

      if (!picksRes.ok || !summaryRes.ok || !historyRes.ok) throw new Error("Failed to fetch data");

      const picksData = await picksRes.json();
      const summaryData = await summaryRes.json();
      const historyData = await historyRes.json();

      const managerName = `${summaryData.player_first_name} ${summaryData.player_last_name}`;

      const chips = historyData?.chips || [];
      const isFreeHit = chips.some((c: any) => c.name === 'freehit' && Number(c.event) === Number(gw));

      const result = {
        entryId,
        managerName,
        isFreeHit,
        picks: picksData.picks.map((p: any) => p.element)
      };
      
      ownershipCache.set(cacheKey, result);
      return result;

    } catch (e) {
      console.error(`Error fetching squad for ${entryId}:`, e);
      return null;
    }
  }

  function calculateOwnership(managerSquads) {
    const ownership = new Map();

    for (const manager of managerSquads) {
      for (const playerId of manager.picks) {
        if (!ownership.has(playerId)) {
          const playerInfo = playerCache.get(playerId) || { name: "Unknown", position: "?", team: 0 };
          const teamName = teamCache.get(playerInfo.team) || "???";

          ownership.set(playerId, {
            playerId,
            playerName: playerInfo.name,
            position: playerInfo.position,
            teamName: teamName,
            ownedBy: [],
            count: 0
          });
        }

        const entry = ownership.get(playerId);
        entry.ownedBy.push(manager.managerName);
        entry.count++;
      }
    }

    return Array.from(ownership.values());
  }

  function showOwnershipModal(playerName, position, teamName, ownedByList) {
    const totalManagers = allManagerNames.length;
    const notOwnedBy = allManagerNames.filter(n => !ownedByList.includes(n)).sort();
    const ownedBySorted = [...ownedByList].sort();
    const ownershipPct = ((ownedByList.length / totalManagers) * 100).toFixed(0);

    const allOwn = ownedByList.length === totalManagers;
    const noneOwn = ownedByList.length === 0;
    const fhCount = freeHitManagers.size;


    const nameWithFH = (name) => {
      return freeHitManagers.has(name)
        ? `${name} <span class="text-muted" title="Played Free Hit in this GW">üéØ FH</span>`
        : name;
    };


    let html = `
      <h2 class="modal-title" style="padding-right:40px;">
        ${playerName}
      </h2>
      <p class="text-muted" style="margin-bottom:var(--space-4);">
        ${position} ¬∑ ${teamName} ¬∑ <span class="text-success font-bold">${ownershipPct}%</span> ownership
      </p>
    `;
    
    if (fhCount > 0) {
      html += `
        <p class="text-muted" style="margin-top:-12px; margin-bottom:var(--space-4);">
          üéØ FH indicates the manager played Free Hit in GW${gwFilterSelect.value}.
        </p>
      `;
    }


    if (allOwn) {
      html += `
        <div class="ownership-section ownership-section--success">
          <div class="ownership-section-header">
            <span class="ownership-section-title">‚úì Owned by everyone</span>
            <span class="ownership-section-count">${totalManagers}/${totalManagers}</span>
          </div>
        </div>
      `;
    } else if (noneOwn) {
      html += `
        <div class="ownership-section ownership-section--danger">
          <div class="ownership-section-header">
            <span class="ownership-section-title">‚úó Not owned by anyone</span>
            <span class="ownership-section-count">0/${totalManagers}</span>
          </div>
        </div>
      `;
    } else {
      html += `
        <div class="ownership-section ownership-section--success">
          <div class="ownership-section-header">
            <span class="ownership-section-title">üëç Owned by</span>
            <span class="ownership-section-count">${ownedBySorted.length}/${totalManagers}</span>
          </div>
          <ul class="ownership-list">
            ${ownedBySorted.map(name => `<li class="ownership-list-item ownership-list-item--owned">${nameWithFH(name)}</li>`).join('')}
          </ul>
        </div>

        <div class="ownership-section ownership-section--danger">
          <div class="ownership-section-header">
            <span class="ownership-section-title">üëé Not owned by</span>
            <span class="ownership-section-count">${notOwnedBy.length}/${totalManagers}</span>
          </div>
          <ul class="ownership-list">
            ${notOwnedBy.map(name => `<li class="ownership-list-item ownership-list-item--not-owned">${nameWithFH(name)}</li>`).join('')}
          </ul>
        </div>
      `;
    }

    ownershipModalContent.innerHTML = html;
    ownershipModal.classList.add("is-open");
  }

  function makeOwnershipTable(ownership, positionFilterValue = "") {
    let filtered = ownership;

    if (positionFilterValue) {
      filtered = ownership.filter(p => p.position === positionFilterValue);
    }

    filtered.sort((a, b) => {
      if (b.count !== a.count) return b.count - a.count;
      return a.playerName.localeCompare(b.playerName);
    });

    const totalManagers = allManagerNames.length;

    let html = `
      <div class="meta-row" style="margin-bottom:8px;">
        <span>Managers: <strong>${totalManagers}</strong></span>
        <span>Players: <strong>${filtered.length}</strong></span>
      </div>

      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table ownership-table">
            <thead>
              <tr>
                <th>Player</th>
                <th class="pos-cell">Pos</th>
                <th class="team-cell">Team</th>
                <th class="pct-cell">%</th>
              </tr>
            </thead>
            <tbody>
    `;

    for (const player of filtered) {
      const ownershipPct = ((player.count / totalManagers) * 100).toFixed(0);
      const ownedByJson = JSON.stringify(player.ownedBy).replace(/"/g, '&quot;');

      html += `
        <tr>
          <td class="player-cell">
            <button type="button" class="player-btn"
              data-player="${player.playerName}"
              data-position="${player.position}"
              data-team="${player.teamName}"
              data-owned="${ownedByJson}"
            >
              <span class="player-name">${player.playerName}</span>
              <span class="player-count">${player.count} of ${totalManagers}</span>
            </button>
          </td>
          <td class="pos-cell">${player.position}</td>
          <td class="team-cell">${player.teamName}</td>
          <td class="pct-cell">${ownershipPct}%</td>
        </tr>
      `;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

    return html;
  }

  function attachPlayerButtons() {
    document.querySelectorAll('.player-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = e.target.closest('.player-btn');
        const playerName = button.dataset.player;
        const position = button.dataset.position;
        const teamName = button.dataset.team;
        const ownedBy = JSON.parse(button.dataset.owned);
        showOwnershipModal(playerName, position, teamName, ownedBy);
      });
    });
  }

  // Updated to handle forceRefresh logic
  async function loadOwnership(ids, gw, forceRefresh = false) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    if (!gw) {
      out.innerHTML = "<p class='status status--warning'>Please select a gameweek.</p>";
      return;
    }

    const loadToken = ++currentLoadToken;
    refreshBtn.disabled = true;

    allManagerNames = [];
    freeHitManagers = new Set();
    out.innerHTML = "";
    loadingStatus.textContent = `Fetching latest data...`;

    // Pass null if not forcing refresh (allows cache to be used)
    const cacheBuster = forceRefresh ? Date.now().toString() : null;
    
    // Fetch manager squads concurrently with limit of 8
    const squadResults = await mapWithConcurrency(
      ids,
      8,
      async (id) => {
        try {
          return await fetchManagerSquad(id, gw, cacheBuster);
        } catch (e) {
          console.error(`Failed to load manager ${id}:`, e);
          return null;
        }
      },
      (completed, total) => {
        loadingStatus.textContent = `Fetching ${completed}/${total}...`;
      }
    );

    if (loadToken !== currentLoadToken) return;

    const managerSquads = squadResults.filter((data): data is NonNullable<typeof data> => data !== null);
    allManagerNames = managerSquads.map(data => data.managerName);
    freeHitManagers = new Set(managerSquads.filter(data => data.isFreeHit).map(data => data.managerName));

    ownershipData = calculateOwnership(managerSquads);
    if (ownershipData.length > 0) {
      const posFilter = positionFilter.value;
      out.innerHTML = makeOwnershipTable(ownershipData, posFilter);
      attachPlayerButtons();
    }

    loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${managerSquads.length} managers for GW${gw}</span>`;
    refreshBtn.disabled = false;
  }

  async function init() {
    loadingStatus.textContent = "Loading player data...";
    await fetchBootstrapData();

    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (!authenticated) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    // Default load: Use cache if available (forceRefresh = false)
    await loadOwnership(managerIds, latestGW);
  }

  function setupPage() {
      const outElement = document.getElementById("ownership-output");
      if (!outElement) return;

      const gwSelect = document.getElementById("gw-filter") as HTMLSelectElement;
      const posSelect = document.getElementById("position-filter") as HTMLSelectElement;
      const refBtn = document.getElementById("refresh-btn");

      if (gwSelect) {
          gwSelect.onchange = async () => {
            const gw = parseInt(gwSelect.value);
            if (gw && gw >= 1 && gw <= 38) {
              await loadOwnership(managerIds, gw);
            }
          };
      }

      if (posSelect) {
          posSelect.onchange = () => {
            const posFilter = posSelect.value;
            out.innerHTML = makeOwnershipTable(ownershipData, posFilter);
            attachPlayerButtons();
          };
      }

      if (refBtn) {
          refBtn.onclick = () => {
              clearCache('ownership');
              // Force refresh: Pass true
              loadOwnership(managerIds, parseInt(gwSelect?.value) || latestGW, true);
          };
      }

      init();
  }

  document.addEventListener('astro:page-load', setupPage);
</script>
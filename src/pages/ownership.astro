---
import Layout from "../layouts/Layout.astro";
import Nav from "../components/Nav.astro";
---
<Layout title="Player Ownership - FPL Manager Data">
  <Nav />

  <main class="page">
    <header class="page-header">
      <h1 class="page-title">üë• Player Ownership</h1>
      <p class="page-subtitle">See which players are owned by how many managers.</p>
    </header>

    <div class="meta-row-wide">
      <span id="manager-count" class="badge badge-wide">Loading...</span>
      <a href="/managers" class="badge badge-wide">‚öô Manage IDs</a>
    </div>

    <div class="controls-inline">
      <div class="control-inline">
        <label class="label-small" for="gw-filter">Gameweek</label>
        <select class="select-small" id="gw-filter">
          <option value="">Select GW</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small" for="position-filter">Position</label>
        <select class="select-small" id="position-filter">
          <option value="">All</option>
          <option value="GK">GK</option>
          <option value="DEF">DEF</option>
          <option value="MID">MID</option>
          <option value="FWD">FWD</option>
        </select>
      </div>
      <div class="control-inline">
        <label class="label-small">&nbsp;</label>
        <button id="refresh-btn" class="btn-row" type="button">üîÑ Refresh</button>
      </div>
    </div>

    <div id="loading-status" class="meta-row"></div>
    <section id="ownership-output" aria-live="polite"></section>
  </main>

  <!-- Ownership Modal edit here this text to force cloudflare deploy -->
  <div id="ownership-modal" class="modal">
    <div class="modal-panel">
      <button id="close-ownership-modal" class="btn btn--danger btn--small modal-close" type="button">‚úï</button>
      <div id="ownership-modal-content"></div>
    </div>
  </div>
</Layout>

<style>
  .meta-row-wide {
    display: flex;
    gap: var(--space-2);
  }

  .badge-wide {
    flex: 1;
    justify-content: center;
    padding: var(--space-2) var(--space-3);
    text-align: center;
  }

  .controls-inline {
    display: flex;
    gap: var(--space-2);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-lg);
    padding: var(--space-2);
  }

  .control-inline {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 4px;
  }

  .label-small {
    font-size: 12px;
    font-weight: 600;
    color: var(--color-text-secondary);
    text-align: center;
  }

  .select-small {
    width: 100%;
    min-height: 32px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    color: var(--color-text);
    background: var(--color-surface);
    border: 1px solid var(--color-border);
    border-radius: var(--radius-md);
  }

  .select-small:focus {
    outline: none;
    border-color: var(--color-primary);
  }

  .btn-row {
    width: 100%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    min-height: 32px;
    padding: 6px 8px;
    font-family: inherit;
    font-size: 13px;
    font-weight: 600;
    color: white;
    background: var(--color-primary);
    border: none;
    border-radius: var(--radius-md);
    cursor: pointer;
  }

  .btn-row:hover {
    background: var(--color-primary-hover);
  }

</style>

<script>
  import { supabase } from '../lib/supabase.ts'

  async function loadManagerIdsFromSupabase() {
    const { data: { user } } = await supabase.auth.getUser()

    if (!user) {
      window.location.replace('/login')
      return { authenticated: false, managerIds: [] }
    }

    try {
      const { data, error } = await supabase
        .from('user_manager_lists')
        .select('manager_ids')
        .eq('user_id', user.id)
        .single()

      if (error && error.code !== 'PGRST116') {
        console.error('Error loading manager IDs:', error)
        return { authenticated: true, managerIds: [] }
      }

      return { authenticated: true, managerIds: data?.manager_ids || [] }
    } catch (e) {
      console.error('Error:', e)
      return { authenticated: false, managerIds: [] }
    }
  }

  const out = document.getElementById("ownership-output");
  const gwFilterSelect = document.getElementById("gw-filter");
  const positionFilter = document.getElementById("position-filter");
  const loadingStatus = document.getElementById("loading-status");
  const managerCountEl = document.getElementById("manager-count");
  const refreshBtn = document.getElementById("refresh-btn");
  const ownershipModal = document.getElementById("ownership-modal");
  const ownershipModalContent = document.getElementById("ownership-modal-content");
  const closeOwnershipModal = document.getElementById("close-ownership-modal");

  let managerIds = [];
  let ownershipData = [];
  let latestGW = null;
  let playerCache = new Map();
  let teamCache = new Map();
  let allManagerNames = [];
  // Names of managers who played Free Hit in the currently selected GW.
  // (Uses the same üéØ FH indicator you already use on the Chips page.)
  let freeHitManagers = new Set();
  
  // Load token for cancellation
  let currentLoadToken = 0;

  // ==============================
  // Persistent page cache (Ownership) - cached until Refresh
  // ==============================
  const OWNERSHIP_SNAPSHOT_KEY = "fpl_ownership_snapshot_v1";

  function safeJsonParse(value) {
    if (!value) return null;
    try { return JSON.parse(value); } catch { return null; }
  }

  function normalizeIds(ids) {
    return (Array.isArray(ids) ? ids : [])
      .map((x) => Number(x))
      .filter((n) => Number.isFinite(n));
  }

  function sameManagerIds(a, b) {
    const aa = normalizeIds(a).sort((x, y) => x - y);
    const bb = normalizeIds(b).sort((x, y) => x - y);
    if (aa.length !== bb.length) return false;
    for (let i = 0; i < aa.length; i++) if (aa[i] !== bb[i]) return false;
    return true;
  }

  function loadOwnershipSnapshot() {
    return safeJsonParse(localStorage.getItem(OWNERSHIP_SNAPSHOT_KEY));
  }

  function saveOwnershipSnapshot(gw) {
    const snap = {
      savedAt: Date.now(),
      managerIds: [...managerIds],
      gw,
      latestGW,
      ownershipData,
      allManagerNames,
      freeHitManagers: Array.from(freeHitManagers),
      ui: {
        gwFilter: gwFilterSelect.value || "",
        positionFilter: positionFilter.value || "",
      },
    };

    try {
      localStorage.setItem(OWNERSHIP_SNAPSHOT_KEY, JSON.stringify(snap));
    } catch (e) {
      console.warn("Could not save ownership snapshot", e);
    }
  }

  function renderOwnershipFromState() {
    const posFilter = positionFilter.value;
    out.innerHTML = makeOwnershipTable(ownershipData, posFilter);
    attachPlayerButtons();
  }



  closeOwnershipModal.addEventListener("click", () => {
    ownershipModal.classList.remove("is-open");
  });

  /**
   * Concurrent mapping with limited concurrency
   */
  async function mapWithConcurrency<T, R>(
    items: T[],
    limit: number,
    fn: (item: T, index: number) => Promise<R | null>,
    onProgress?: (completed: number, total: number) => void
  ): Promise<(R | null)[]> {
    const results: (R | null)[] = [];
    let currentIndex = 0;
    let completed = 0;

    async function worker() {
      while (currentIndex < items.length) {
        const index = currentIndex++;
        const item = items[index];
        try {
          results[index] = await fn(item, index);
        } catch (e) {
          console.error(`Error processing item ${index}:`, e);
          results[index] = null;
        }
        completed++;
        if (onProgress) {
          onProgress(completed, items.length);
        }
      }
    }

    const workers = Array.from({ length: Math.min(limit, items.length) }, () => worker());
    await Promise.all(workers);
    return results;
  }

  function populateGWSelector(currentGW) {
    gwFilterSelect.innerHTML = '';
    for (let i = 1; i <= 38; i++) {
      const option = document.createElement('option');
      option.value = i;
      option.textContent = `GW ${i}`;
      if (i === currentGW) option.selected = true;
      gwFilterSelect.appendChild(option);
    }
  }

  async function fetchBootstrapData(cacheBuster?: string) {
    try {
      const url = cacheBuster
        ? `/api/fpl/bootstrap-static?v=${cacheBuster}`
        : `/api/fpl/bootstrap-static`;

      const res = await fetch(url);
      if (!res.ok) throw new Error("Failed to fetch bootstrap data");
      const data = await res.json();

      playerCache.clear();
      teamCache.clear();

      data.elements.forEach(player => {
        playerCache.set(player.id, {
          name: player.web_name,
          position: player.element_type === 1 ? "GK" :
                    player.element_type === 2 ? "DEF" :
                    player.element_type === 3 ? "MID" : "FWD",
          team: player.team
        });
      });

      data.teams.forEach(team => {
        teamCache.set(team.id, team.short_name);
      });

      const currentEvent = data.events.find(e => e.is_current);
      latestGW = currentEvent ? currentEvent.id : 1;

      populateGWSelector(latestGW);
    } catch (e) {
      console.error("Error fetching bootstrap data:", e);
    }
  }

  async function fetchManagerSquad(entryId, gw, cacheBuster?: string) {
    try {
      const picksUrl = cacheBuster
        ? `/api/fpl/entry/${entryId}/event/${gw}/picks?v=${cacheBuster}`
        : `/api/fpl/entry/${entryId}/event/${gw}/picks`;

      const summaryUrl = cacheBuster
        ? `/api/fpl/entry/${entryId}?v=${cacheBuster}`
        : `/api/fpl/entry/${entryId}`;

      const historyUrl = cacheBuster
        ? `/api/fpl/entry/${entryId}/history?v=${cacheBuster}`
        : `/api/fpl/entry/${entryId}/history`;

      const [picksRes, summaryRes, historyRes] = await Promise.all([
        fetch(picksUrl),
        fetch(summaryUrl),
        fetch(historyUrl)
      ]);

      if (!picksRes.ok || !summaryRes.ok || !historyRes.ok) throw new Error("Failed to fetch data");

      const picksData = await picksRes.json();
      const summaryData = await summaryRes.json();
      const historyData = await historyRes.json();

      const managerName = `${summaryData.player_first_name} ${summaryData.player_last_name}`;

      const chips = historyData?.chips || [];
      const isFreeHit = chips.some(c => c.name === 'freehit' && Number(c.event) === Number(gw));

      return {
        entryId,
        managerName,
        isFreeHit,
        picks: picksData.picks.map(p => p.element)
      };
    } catch (e) {
      console.error(`Error fetching squad for ${entryId}:`, e);
      return null;
    }
  }


  function calculateOwnership(managerSquads) {
    const ownership = new Map();

    for (const manager of managerSquads) {
      for (const playerId of manager.picks) {
        if (!ownership.has(playerId)) {
          const playerInfo = playerCache.get(playerId) || { name: "Unknown", position: "?", team: 0 };
          const teamName = teamCache.get(playerInfo.team) || "???";

          ownership.set(playerId, {
            playerId,
            playerName: playerInfo.name,
            position: playerInfo.position,
            teamName: teamName,
            ownedBy: [],
            count: 0
          });
        }

        const entry = ownership.get(playerId);
        entry.ownedBy.push(manager.managerName);
        entry.count++;
      }
    }

    return Array.from(ownership.values());
  }

  function showOwnershipModal(playerName, position, teamName, ownedByList) {
    const totalManagers = allManagerNames.length;
    const notOwnedBy = allManagerNames.filter(n => !ownedByList.includes(n)).sort();
    const ownedBySorted = [...ownedByList].sort();
    const ownershipPct = ((ownedByList.length / totalManagers) * 100).toFixed(0);

    const allOwn = ownedByList.length === totalManagers;
    const noneOwn = ownedByList.length === 0;
    const fhCount = freeHitManagers.size;


    const nameWithFH = (name) => {
      return freeHitManagers.has(name)
        ? `${name} <span class="text-muted" title="Played Free Hit in this GW">üéØ FH</span>`
        : name;
    };


    let html = `
      <h2 class="modal-title" style="padding-right:40px;">
        ${playerName}
      </h2>
      <p class="text-muted" style="margin-bottom:var(--space-4);">
        ${position} ¬∑ ${teamName} ¬∑ <span class="text-success font-bold">${ownershipPct}%</span> ownership
      </p>
    `;
    
    if (fhCount > 0) {
      html += `
        <p class="text-muted" style="margin-top:-12px; margin-bottom:var(--space-4);">
          üéØ FH indicates the manager played Free Hit in GW${gwFilterSelect.value}.
        </p>
      `;
    }


    if (allOwn) {
      html += `
        <div class="ownership-section ownership-section--success">
          <div class="ownership-section-header">
            <span class="ownership-section-title">‚úì Owned by everyone</span>
            <span class="ownership-section-count">${totalManagers}/${totalManagers}</span>
          </div>
        </div>
      `;
    } else if (noneOwn) {
      html += `
        <div class="ownership-section ownership-section--danger">
          <div class="ownership-section-header">
            <span class="ownership-section-title">‚úó Not owned by anyone</span>
            <span class="ownership-section-count">0/${totalManagers}</span>
          </div>
        </div>
      `;
    } else {
      html += `
        <div class="ownership-section ownership-section--success">
          <div class="ownership-section-header">
            <span class="ownership-section-title">üëç Owned by</span>
            <span class="ownership-section-count">${ownedBySorted.length}/${totalManagers}</span>
          </div>
          <ul class="ownership-list">
            ${ownedBySorted.map(name => `<li class="ownership-list-item ownership-list-item--owned">${nameWithFH(name)}</li>`).join('')}
          </ul>
        </div>

        <div class="ownership-section ownership-section--danger">
          <div class="ownership-section-header">
            <span class="ownership-section-title">üëé Not owned by</span>
            <span class="ownership-section-count">${notOwnedBy.length}/${totalManagers}</span>
          </div>
          <ul class="ownership-list">
            ${notOwnedBy.map(name => `<li class="ownership-list-item ownership-list-item--not-owned">${nameWithFH(name)}</li>`).join('')}
          </ul>
        </div>
      `;
    }

    ownershipModalContent.innerHTML = html;
    ownershipModal.classList.add("is-open");
  }

  function makeOwnershipTable(ownership, positionFilterValue = "") {
    let filtered = ownership;

    if (positionFilterValue) {
      filtered = ownership.filter(p => p.position === positionFilterValue);
    }

    filtered.sort((a, b) => {
      if (b.count !== a.count) return b.count - a.count;
      return a.playerName.localeCompare(b.playerName);
    });

    const totalManagers = allManagerNames.length;

    let html = `
      <div class="meta-row" style="margin-bottom:8px;">
        <span>Managers: <strong>${totalManagers}</strong></span>
        <span>Players: <strong>${filtered.length}</strong></span>
      </div>

      <div class="table-container">
        <div class="table-scroll">
          <table class="data-table ownership-table">
            <thead>
              <tr>
                <th>Player</th>
                <th class="pos-cell">Pos</th>
                <th class="team-cell">Team</th>
                <th class="pct-cell">%</th>
              </tr>
            </thead>
            <tbody>
    `;

    for (const player of filtered) {
      const ownershipPct = ((player.count / totalManagers) * 100).toFixed(0);
      const ownedByJson = JSON.stringify(player.ownedBy).replace(/"/g, '&quot;');

      html += `
        <tr>
          <td class="player-cell">
            <button type="button" class="player-btn"
              data-player="${player.playerName}"
              data-position="${player.position}"
              data-team="${player.teamName}"
              data-owned="${ownedByJson}"
            >
              <span class="player-name">${player.playerName}</span>
              <span class="player-count">${player.count} of ${totalManagers}</span>
            </button>
          </td>
          <td class="pos-cell">${player.position}</td>
          <td class="team-cell">${player.teamName}</td>
          <td class="pct-cell">${ownershipPct}%</td>
        </tr>
      `;
    }

    html += `
            </tbody>
          </table>
        </div>
      </div>
    `;

    return html;
  }

  function attachPlayerButtons() {
    document.querySelectorAll('.player-btn').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const button = e.target.closest('.player-btn');
        const playerName = button.dataset.player;
        const position = button.dataset.position;
        const teamName = button.dataset.team;
        const ownedBy = JSON.parse(button.dataset.owned);
        showOwnershipModal(playerName, position, teamName, ownedBy);
      });
    });
  }

  async function loadOwnership(ids, gw, opts = {}) {
    if (ids.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs found. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    if (!gw) {
      out.innerHTML = "<p class='status status--warning'>Please select a gameweek.</p>";
      return;
    }

    const force = !!opts.force;

    // Generate load token for cancellation
    const loadToken = ++currentLoadToken;

    allManagerNames = [];
    freeHitManagers = new Set();
    out.innerHTML = "";
    loadingStatus.textContent = `Fetching latest data...`;

    // Only bust caches when force=true (Refresh button)
    const cacheBuster = force ? Date.now().toString() : undefined;

    // Fetch manager squads concurrently with limit of 8
    const squadResults = await mapWithConcurrency(
      ids,
      8,
      async (id) => {
        try {
          return await fetchManagerSquad(id, gw, cacheBuster);
        } catch (e) {
          console.error(`Failed to load manager ${id}:`, e);
          return null;
        }
      },
      (completed, total) => {
        loadingStatus.textContent = `Fetching ${completed}/${total}...`;
      }
    );

    // Check if this load has been superseded
    if (loadToken !== currentLoadToken) {
      console.log('Load superseded, aborting');
      return;
    }

    // Filter out nulls and update data
    const managerSquads = squadResults.filter((data) => data !== null);
    allManagerNames = managerSquads.map((data) => data.managerName);
    freeHitManagers = new Set(managerSquads.filter((data) => data.isFreeHit).map((data) => data.managerName));

    // Calculate ownership and render table once at the end
    ownershipData = calculateOwnership(managerSquads);
    if (ownershipData.length > 0) {
      const posFilter = positionFilter.value;
      out.innerHTML = makeOwnershipTable(ownershipData, posFilter);
      attachPlayerButtons();
    }

    loadingStatus.innerHTML = `<span class='text-success font-bold'>‚úÖ Loaded ${managerSquads.length} managers for GW${gw}</span>`;
    saveOwnershipSnapshot(gw);

  }

  async function init() {
    loadingStatus.textContent = "Loading...";

    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (!authenticated) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    if (managerIds.length === 0) {
      out.innerHTML = "<p class='status status--error'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</p>";
      return;
    }

    // 1) Try local snapshot first (instant, no fetch)
    const snap = loadOwnershipSnapshot();
    if (
      snap &&
      sameManagerIds(snap.managerIds, managerIds) &&
      Array.isArray(snap.ownershipData) &&
      snap.ownershipData.length > 0
    ) {
      ownershipData = snap.ownershipData || [];
      allManagerNames = snap.allManagerNames || [];
      freeHitManagers = new Set(snap.freeHitManagers || []);
      latestGW = snap.latestGW || latestGW;

      populateGWSelector(latestGW);

      if (typeof snap.ui?.gwFilter === "string" && snap.ui.gwFilter) {
        gwFilterSelect.value = snap.ui.gwFilter;
      } else if (snap.gw) {
        gwFilterSelect.value = String(snap.gw);
      }

      if (typeof snap.ui?.positionFilter === "string") {
        positionFilter.value = snap.ui.positionFilter;
      }

      renderOwnershipFromState();
      loadingStatus.textContent = "Loaded from cache.";
      return;
    }

    // 2) No snapshot -> do one normal load (NOT forced)
    loadingStatus.textContent = "Loading player data...";
    await fetchBootstrapData(); // not forced, no ?v=
    await loadOwnership(managerIds, latestGW, { force: false });
  }

  gwFilterSelect.addEventListener("change", async () => {
    const gw = parseInt(gwFilterSelect.value);
    if (!(gw && gw >= 1 && gw <= 38)) return;

    const snap = loadOwnershipSnapshot();
    if (
      snap &&
      sameManagerIds(snap.managerIds, managerIds) &&
      Number(snap.gw) === Number(gw) &&
      Array.isArray(snap.ownershipData) &&
      snap.ownershipData.length > 0
    ) {
      ownershipData = snap.ownershipData || [];
      allManagerNames = snap.allManagerNames || [];
      freeHitManagers = new Set(snap.freeHitManagers || []);
      renderOwnershipFromState();
      loadingStatus.textContent = "Loaded from cache.";
      return;
    }

    await loadOwnership(managerIds, gw, { force: false });
  });

  positionFilter.addEventListener('change', () => {
    const posFilter = positionFilter.value;
    out.innerHTML = makeOwnershipTable(ownershipData, posFilter);
    attachPlayerButtons();
    saveOwnershipSnapshot(parseInt(gwFilterSelect.value) || latestGW);
  });
  
  refreshBtn?.addEventListener("click", async () => {
    localStorage.removeItem(OWNERSHIP_SNAPSHOT_KEY);
    const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
    if (!authenticated) return;

    managerIds = ids;
    managerCountEl.textContent = `${managerIds.length} managers`;

    // Force fresh bootstrap + ownership reload
    const bust = Date.now().toString();
    await fetchBootstrapData(bust);

    const gw = parseInt(gwFilterSelect.value) || latestGW;
    await loadOwnership(managerIds, gw, { force: true });
  });


  init();
</script>

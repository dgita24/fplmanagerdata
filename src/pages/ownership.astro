---

import Nav from '../components/Nav.astro';
---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Player Ownership Dashboard - FPL Manager Data</title>
</head>
<body>
<Nav />
<h1>Player Ownership Dashboard</h1>
<p>See which players are owned by how many managers in your league, and which managers own them.</p>

<div style="margin-bottom: 1.5em;">
  <label for="view-select" style="font-weight: bold; margin-right: 0.5em;">View:</label>
  <select id="view-select" style="padding: 8px 12px; font-size: 16px; border-radius: 4px; border: 1px solid #ccc;">
    <option value="custom">My Custom Managers</option>
    <option value="top50">World Top 50</option>
  </select>
  
  <span id="manager-count" style="margin-left: 1.5em; font-weight: bold;">Loading managers...</span>
  <a href="/managers" style="margin-left: 1em; color: #3182ce;">Manage IDs</a>
</div>

<div style="margin-bottom: 1em;">
  <label for="gw-filter">Select Gameweek:</label><br>
  <input type="number" id="gw-filter" min="1" max="38" placeholder="Auto" style="width: 100px; padding: 5px;">
  <button id="refresh-btn" style="margin-left: 1em; padding: 5px 12px;">Refresh Data</button>
</div>

<div style="margin-bottom: 1em;">
  <label for="position-filter"><strong>Filter by Position:</strong></label><br>
  <select id="position-filter" style="padding: 8px; width: 200px; font-size: 14px;">
    <option value="">All Positions</option>
    <option value="GK">Goalkeepers (GK)</option>
    <option value="DEF">Defenders (DEF)</option>
    <option value="MID">Midfielders (MID)</option>
    <option value="FWD">Forwards (FWD)</option>
  </select>
</div>

<div id="loading-status" style="margin-bottom: 1em; color: #666;"></div>
<div id="ownership-output" style="margin-top:1.5em"></div>

<script>
import { supabase } from '../lib/supabase.ts'

let managerIds = []

async function loadManagerIdsFromSupabase() {
  const { data: { user } } = await supabase.auth.getUser()
  
  if (!user) {
    window.location.replace('/login')
    return { authenticated: false, managerIds: [] }
  }
  
  try {
    const { data, error } = await supabase
      .from('user_manager_lists')
      .select('manager_ids')
      .eq('user_id', user.id)
      .single()
    
    if (error && error.code !== 'PGRST116') {
      console.error('Error loading manager IDs:', error)
      return { authenticated: true, managerIds: [] }
    }
    
    return { authenticated: true, managerIds: data?.manager_ids || [] }
  } catch (e) {
    console.error('Error:', e)
    return { authenticated: false, managerIds: [] }
  }
}

const out = document.getElementById("ownership-output");
const gwFilterInput = document.getElementById("gw-filter");
const positionFilter = document.getElementById("position-filter");
const loadingStatus = document.getElementById("loading-status");
const managerCountEl = document.getElementById("manager-count");
const refreshBtn = document.getElementById("refresh-btn");
const viewSelect = document.getElementById("view-select");

let currentView = 'custom';
let customManagerIds = [];
let top50ManagerIds = [];

async function fetchTop50ManagerIds() {
  try {
    const response = await fetch('/api/fpl/leagues-classic/314/standings/?page_standings=1');
    if (!response.ok) return [];
    
    const data = await response.json();
    const standings = data.standings?.results || [];
    
    return standings.slice(0, 50).map(s => s.entry);
  } catch (error) {
    console.error('Error fetching top 50:', error);
    return [];
  }
}

let ownershipData = [];
let latestGW = null;
let playerCache = new Map();
let teamCache = new Map();
let allManagerNames = []; // Track all manager names for "All except" logic

async function fetchBootstrapData() {
  try {
    const res = await fetch('/api/fpl/bootstrap-static');
    if (!res.ok) throw new Error("Failed to fetch bootstrap data");
    const data = await res.json();
    
    data.elements.forEach(player => {
      playerCache.set(player.id, {
        name: player.web_name,
        position: player.element_type === 1 ? "GK" :
                  player.element_type === 2 ? "DEF" :
                  player.element_type === 3 ? "MID" : "FWD",
        team: player.team
      });
    });
    
    data.teams.forEach(team => {
      teamCache.set(team.id, team.short_name);
    });
    
    const currentEvent = data.events.find(e => e.is_current);
    latestGW = currentEvent ? currentEvent.id : 1;
  } catch (e) {
    console.error("Error fetching bootstrap data:", e);
  }
}

async function fetchManagerSquad(entryId, gw) {
  try {
    const [picksRes, summaryRes] = await Promise.all([
      fetch(`/api/fpl/entry/${entryId}/event/${gw}/picks`),
      fetch(`/api/fpl/entry/${entryId}`)
    ]);
    
    if (!picksRes.ok || !summaryRes.ok) throw new Error("Failed to fetch data");
    
    const picksData = await picksRes.json();
    const summaryData = await summaryRes.json();
    
    const managerName = `${summaryData.player_first_name} ${summaryData.player_last_name}`;
    const firstName = summaryData.player_first_name;
    const lastName = summaryData.player_last_name;
    
    return {
      entryId,
      managerName,
      firstName,
      lastName,
      picks: picksData.picks.map(p => p.element)
    };
  } catch (e) {
    console.error(`Error fetching squad for ${entryId}:`, e);
    return null;
  }
}

function calculateOwnership(managerSquads) {
  const ownership = new Map();
  
  for (const manager of managerSquads) {
    for (const playerId of manager.picks) {
      if (!ownership.has(playerId)) {
        const playerInfo = playerCache.get(playerId) || { name: "Unknown", position: "?", team: 0 };
        const teamName = teamCache.get(playerInfo.team) || "Unknown";
        
        ownership.set(playerId, {
          playerId,
          playerName: playerInfo.name,
          position: playerInfo.position,
          teamName: teamName,
          ownedBy: [],
          count: 0
        });
      }
      
      const entry = ownership.get(playerId);
      entry.ownedBy.push({
        firstName: manager.firstName,
        lastName: manager.lastName,
        managerName: manager.managerName
      });
      entry.count++;
    }
  }
  
  return Array.from(ownership.values());
}

function makeOwnershipTable(ownership, positionFilterValue = "") {
  let filtered = ownership;
  
  if (positionFilterValue) {
    filtered = ownership.filter(p => p.position === positionFilterValue);
  }
  
  filtered.sort((a, b) => {
    if (b.count !== a.count) return b.count - a.count;
    return a.playerName.localeCompare(b.playerName);
  });
  
  const totalManagers = allManagerNames.length;
  
  let html = `<h2>Player Ownership ${positionFilterValue ? `- ${positionFilterValue}` : '(All Positions)'}</h2>
  <p style="color: #666; margin-bottom: 1em;">Total managers: ${totalManagers} | Showing ${filtered.length} players</p>
  
  <table border="1" cellpadding="6" style="border-collapse:collapse; width: 100%; max-width: 1200px;">
    <tr style="background:#f0f0f0">
      <th>Player</th>
      <th>Position</th>
      <th>Team</th>
      <th style="background:#fffacd;">Ownership</th>
      <th style="background:#fffacd;">Count</th>
      <th style="width: 40%;">Owned By</th>
    </tr>`;
  
  for (const player of filtered) {
    const ownershipPct = ((player.count / totalManagers) * 100).toFixed(0);
    
    // Smart "Owned By" text - always show the shorter list
    let ownedByText = "";
    
    if (player.count === totalManagers) {
      // 100% ownership
      ownedByText = "All";
    } else if (player.count > totalManagers / 2) {
      // More than 50% - show who DOESN'T own them (shorter list)
      const missing = allManagerNames.filter(name => {
        return !player.ownedBy.some(owner => `${owner.firstName} ${owner.lastName}` === name);
      });
      
      if (missing.length === 0) {
        ownedByText = "All";
      } else {
        ownedByText = `All except ${missing.map(n => n.split(' ')[0]).join(", ")}`;
      }
    } else {
      // 50% or less - show who OWNS them (shorter list)
      ownedByText = player.ownedBy
        .map(m => `${m.firstName} ${m.lastName.substring(0, 2)}`)
        .join(", ");
    }
    
    // Color code by ownership level
    let ownershipColor = "#e6ffe6";
    if (player.count >= totalManagers * 0.5) ownershipColor = "#ffcccc"; // 50%+ = red
    else if (player.count >= totalManagers * 0.3) ownershipColor = "#ffe6cc"; // 30%+ = orange
    
    html += `<tr>
      <td style="font-weight: bold;">${player.playerName}</td>
      <td style="text-align: center;">${player.position}</td>
      <td>${player.teamName}</td>
      <td style="text-align: center; background:${ownershipColor}; font-weight: bold;">${ownershipPct}%</td>
      <td style="text-align: center; background:${ownershipColor}; font-weight: bold;">${player.count}</td>
      <td style="font-size: 12px;">${ownedByText}</td>
    </tr>`;
  }
  
  html += "</table>";
  
  const highly_owned = filtered.filter(p => p.count >= totalManagers * 0.5).length;
  const moderately_owned = filtered.filter(p => p.count >= totalManagers * 0.3 && p.count < totalManagers * 0.5).length;
  const differential = filtered.filter(p => p.count === 1).length;
  
  html += `<div style="margin-top: 2em; padding: 1em; background: #f7fafc; border-left: 4px solid #38a169; max-width: 1200px;">
    <h3>Ownership Summary</h3>
    <ul style="line-height: 1.8;">
      <li><strong>Highly Owned (50%+):</strong> ${highly_owned} players</li>
      <li><strong>Moderately Owned (30-50%):</strong> ${moderately_owned} players</li>
      <li><strong>Differentials (1 manager only):</strong> ${differential} players</li>
      <li><strong>Total Unique Players:</strong> ${filtered.length}</li>
    </ul>
  </div>`;
  
  return html;
}

async function loadOwnership(ids, gw) {
  if (ids.length === 0) {
    out.innerHTML = "<span style='color:red'>No manager IDs found. <a href='/managers'>Add managers here</a>.</span>";
    return;
  }
  
  if (!gw) {
    out.innerHTML = "<span style='color:orange'>Please select a gameweek.</span>";
    return;
  }

  const managerSquads = [];
  allManagerNames = []; // Reset for this load
  out.innerHTML = "";
  loadingStatus.textContent = `Loading 0 of ${ids.length} managers for GW${gw}...`;
  
  let loaded = 0;
  for (const id of ids) {
    try {
      const data = await fetchManagerSquad(id, gw);
      if (data) {
        managerSquads.push(data);
        allManagerNames.push(data.managerName); // Store all manager names
        loaded++;
        
        loadingStatus.textContent = `Loading ${loaded} of ${ids.length} managers...`;
        
        ownershipData = calculateOwnership(managerSquads);
        const posFilter = positionFilter.value;
        out.innerHTML = makeOwnershipTable(ownershipData, posFilter);
      }
    } catch (e) {
      console.error(`Failed to load manager ${id}:`, e);
      loaded++;
    }
  }
  
  loadingStatus.innerHTML = `<span style='color:#38a169'>âœ… Loaded ${loaded} of ${ids.length} managers for GW${gw}</span>`;
}

async function init() {
  loadingStatus.textContent = "Loading player and team data...";
  await fetchBootstrapData();
  
  gwFilterInput.value = latestGW;
  gwFilterInput.placeholder = `Latest: GW${latestGW}`;
  
  const { authenticated, managerIds: ids } = await loadManagerIdsFromSupabase();
  if (!authenticated) return; // Stop if not authenticated (redirect in progress)
  
  customManagerIds = ids;
  
  await updateDisplay();
  
  viewSelect.addEventListener('change', () => {
    currentView = viewSelect.value;
    updateDisplay();
  });
}

async function updateDisplay() {
  const ids = currentView === 'custom' ? customManagerIds : top50ManagerIds;
  
  if (currentView === 'custom') {
    managerCountEl.textContent = `${customManagerIds.length} manager(s) configured`;
    if (customManagerIds.length === 0) {
      out.innerHTML = "<span style='color:red'>No manager IDs configured. <a href='/managers'>Add managers here</a>.</span>";
      return;
    }
  } else {
    managerCountEl.textContent = `Top 50 managers`;
    if (top50ManagerIds.length === 0) {
      loadingStatus.textContent = 'Fetching Top 50 managers...';
      top50ManagerIds = await fetchTop50ManagerIds();
      if (top50ManagerIds.length === 0) {
        out.innerHTML = "<span style='color:red'>Failed to fetch Top 50 managers. Please try again later.</span>";
        loadingStatus.textContent = '';
        return;
      }
    }
  }
  
  managerIds = ids;
  await loadOwnership(ids, latestGW);
}

gwFilterInput.addEventListener('change', async () => {
  const gw = parseInt(gwFilterInput.value);
  if (gw && gw >= 1 && gw <= 38) {
    loadOwnership(managerIds, gw);
  }
});

positionFilter.addEventListener('change', () => {
  const posFilter = positionFilter.value;
  out.innerHTML = makeOwnershipTable(ownershipData, posFilter);
});

refreshBtn.addEventListener('click', async () => {
  if (currentView === 'custom') {
    const { managerIds: ids } = await loadManagerIdsFromSupabase();
    customManagerIds = ids;
  } else {
    top50ManagerIds = await fetchTop50ManagerIds();
  }
  await updateDisplay();
});

init();
</script>

<style>
  table {
    font-family: Arial, sans-serif;
    font-size: 14px;
  }
  th {
    font-weight: bold;
    padding: 8px;
  }
  td {
    padding: 6px;
  }
  h2 {
    margin-top: 1.5em;
    margin-bottom: 0.5em;
  }
  button, select {
    background: #3182ce;
    color: white;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    padding: 5px 12px;
  }
  button:hover {
    background: #2c5aa0;
  }
  select {
    background: white;
    color: #2d3748;
    border: 1px solid #cbd5e0;
    font-weight: normal;
  }
</style></body>
</html>
